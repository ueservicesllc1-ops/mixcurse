<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MultiTrack Player - Professional DAW</title>
    <link rel="icon" type="image/x-icon" href="./assets/favicon.ico">
    <link rel="shortcut icon" href="./assets/favicon.ico">
    <!-- JSZip library for ZIP file handling -->
    <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
    <!-- Tone.js library for advanced audio processing -->
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <!-- Offline System -->
    <script src="../cache-system.js"></script>
    <script src="../offline-manager.js"></script>
    <script src="../offline-integration.js"></script>
    <script src="../additional-functions.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0f0f0f;
            color: #ffffff;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        /* Hide scrollbars */
        ::-webkit-scrollbar {
            width: 0px;
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: transparent;
        }

        * {
            scrollbar-width: none;
            /* Firefox */
            -ms-overflow-style: none;
            /* IE and Edge */
        }


        .master-volume-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-right: 20px;
            min-width: 240px;
        }

        .master-label {
            color: #ffffff;
            font-weight: bold;
            font-size: 12px;
            min-width: 50px;
        }

        .master-volume-slider {
            flex: 1;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            appearance: none;
        }

        .master-volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #007AFF;
            border-radius: 50%;
            cursor: pointer;
        }

        .master-volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #007AFF;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .master-volume-value {
            color: #ffffff;
            font-size: 11px;
            min-width: 35px;
            text-align: right;
        }

        .transport-controls {
            display: flex;
            gap: 10px;
            margin-right: 30px;
        }

        .transport-btn {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            color: white;
            border: 1px solid #444;
            width: 50px;
            height: 50px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            position: relative;
            box-shadow:
                0 4px 8px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.2s ease;
        }

        .transport-btn::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 10px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .transport-btn:hover {
            transform: translateY(-1px);
            box-shadow:
                0 6px 12px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .transport-btn.active::before {
            opacity: 1;
            background: radial-gradient(circle, rgba(0, 255, 0, 0.3) 0%, transparent 70%);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6);
        }

        .transport-btn.stop-btn::before {
            background: radial-gradient(circle, rgba(255, 0, 0, 0.3) 0%, transparent 70%);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.6);
        }

        .transport-btn.stop-btn {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
        }

        .transport-btn.stop-btn:hover {
            transform: translateY(-1px);
        }

        .transport-btn.cache-btn {
            background: linear-gradient(145deg, #1e3a8a, #1e40af);
            color: #93c5fd;
            border: 1px solid #3b82f6;
            font-size: 16px;
        }

        .transport-btn.cache-btn:hover {
            background: linear-gradient(145deg, #1d4ed8, #2563eb);
            color: #dbeafe;
            border-color: #60a5fa;
            box-shadow:
                0 6px 12px rgba(59, 130, 246, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .transport-btn.cache-btn::before {
            background: radial-gradient(circle, rgba(59, 130, 246, 0.3) 0%, transparent 70%);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.6);
        }

        .time-display {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-right: 30px;
        }

        .center-time-display {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            margin: 0 30px;
        }

        .time-info {
            font-size: 24px;
            color: #3DA9FC;
            font-weight: bold;
            background: linear-gradient(135deg, #0D0D0D 0%, #1F1F1F 100%);
            border: 3px solid #E0E0E0;
            border-radius: 12px;
            padding: 16px 24px;
            text-shadow: 0 0 12px #3DA9FC;
            position: relative;
            box-shadow:
                0 0 15px rgba(61, 169, 252, 0.4),
                inset 0 0 15px rgba(61, 169, 252, 0.2);
            min-width: 220px;
            text-align: center;
            overflow: hidden;
            letter-spacing: 2px;
        }

        .time-info::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(61, 169, 252, 0.3), transparent);
            animation: ledScan 4s infinite;
        }

        .bpm-display {
            background: #333;
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .bpm-btn {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            color: white;
            border: 1px solid #444;
            width: 24px;
            height: 24px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow:
                0 2px 4px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .bpm-btn:hover {
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            border-color: #555;
            transform: translateY(-1px);
            box-shadow:
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .bpm-btn:active {
            transform: translateY(0);
            box-shadow:
                0 1px 2px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .bpm-reset-btn {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            color: #ff6b6b;
            border: 1px solid #444;
            width: 24px;
            height: 24px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            margin-left: 4px;
            box-shadow:
                0 2px 4px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .bpm-reset-btn:hover {
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            border-color: #555;
            color: #ff5252;
            transform: translateY(-1px);
            box-shadow:
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .bpm-reset-btn:active {
            transform: translateY(0);
            box-shadow:
                0 1px 2px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .key-display {
            background: #333;
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .key-btn {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            color: white;
            border: 1px solid #444;
            width: 24px;
            height: 24px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow:
                0 2px 4px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .key-btn:hover {
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            border-color: #555;
            transform: translateY(-1px);
            box-shadow:
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .key-btn:active {
            transform: translateY(0);
            box-shadow:
                0 1px 2px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .key-reset-btn {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            color: #ff6b6b;
            border: 1px solid #444;
            width: 24px;
            height: 24px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            margin-left: 4px;
            box-shadow:
                0 2px 4px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .key-reset-btn:hover {
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            border-color: #555;
            color: #ff5252;
            transform: translateY(-1px);
            box-shadow:
                0 4px 8px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .key-reset-btn:active {
            transform: translateY(0);
            box-shadow:
                0 1px 2px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }


        .midi-indicators {
            display: flex;
            gap: 10px;
            margin-right: 20px;
        }

        .midi-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #333;
        }

        .midi-indicator.active {
            background: #00ff00;
        }

        .upload-btn {
            background: #34C759;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            margin-right: 15px;
        }

        .upload-btn:hover {
            background: #28A745;
        }

        .library-btn {
            background: #FF9500;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            margin-right: 15px;
        }

        .library-btn:hover {
            background: #E6850E;
        }

        .test-b2-btn {
            background: #FF6B35;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            margin-right: 15px;
        }

        .test-b2-btn:hover {
            background: #E55A2B;
        }

        .auth-btn {
            background: #007AFF;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            margin-right: 15px;
        }

        .auth-btn:hover {
            background: #0056CC;
        }

        .settings-btn {
            background: none;
            border: none;
            color: #ccc;
            font-size: 20px;
            cursor: pointer;
        }

        /* Main Content */
        .main-content {
            display: flex;
            height: 100vh;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
        }


        /* Mixer Section */
        .mixer-section {
            flex: 7;
            background: #1a1a1a;
            border-right: 1px solid #333;
            padding: 0;
            overflow-y: auto;
            height: 100vh;
        }

        /* Track Selection Panel */
        .track-selection-panel {
            background: #2a2a2a;
            border-bottom: 2px solid #444;
            padding: 15px;
            margin-bottom: 10px;
        }

        .track-selection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .track-selection-header h3 {
            color: #00FF41;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin: 0;
            text-shadow: 0 0 5px #00FF41;
        }

        .close-selection-btn {
            background: #333;
            border: 1px solid #555;
            color: #ccc;
            width: 25px;
            height: 25px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-selection-btn:hover {
            background: #444;
            color: #fff;
        }

        .track-selection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
        }

        .track-selection-btn {
            background: linear-gradient(145deg, #1a1a1a, #0f0f0f);
            border: 2px solid #444;
            color: #3DA9FC;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .track-selection-btn:hover {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            border-color: #555;
            color: #00FF41;
            text-shadow: 0 0 5px #00FF41;
        }

        .track-selection-btn.selected {
            background: linear-gradient(145deg, #C0C0C0, #A8A8A8);
            border-color: #C0C0C0;
            color: #000;
            box-shadow: 0 0 10px rgba(192, 192, 192, 0.5);
        }

        .led-progress-container {
            width: 100%;
            margin: 0;
            padding: 0 20px;
        }

        .led-progress-bar {
            width: 100%;
            height: 8px;
            background: linear-gradient(135deg, #0D0D0D 0%, #1F1F1F 100%);
            border: 1px solid #E0E0E0;
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            overflow: hidden;
            box-shadow:
                0 0 10px rgba(61, 169, 252, 0.2),
                inset 0 0 10px rgba(61, 169, 252, 0.1);
        }

        .led-progress-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(61, 169, 252, 0.4), transparent);
            animation: ledScan 4s infinite;
        }

        .led-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3DA9FC, #00D4FF);
            border-radius: 6px;
            width: 0%;
            transition: width 0.1s ease;
            box-shadow: 0 0 8px rgba(61, 169, 252, 0.6);
        }

        .led-progress-thumb {
            position: absolute;
            top: -3px;
            width: 14px;
            height: 14px;
            background: #3DA9FC;
            border-radius: 50%;
            left: 0%;
            transition: left 0.1s ease;
            cursor: pointer;
            box-shadow:
                0 0 8px rgba(61, 169, 252, 0.6),
                0 0 4px rgba(61, 169, 252, 0.3);
            border: 1px solid #E0E0E0;
        }

        .led-progress-thumb:hover {
            background: #00D4FF;
            transform: scale(1.2);
            box-shadow:
                0 0 16px rgba(0, 212, 255, 0.9),
                0 0 8px rgba(0, 212, 255, 0.5);
        }

        .tracks-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 4px;
            padding: 4px 8px 8px 8px;
            height: calc(66.2vh - 120px);
        }

        .track-channel {
            background: #222;
            border-radius: 6px;
            padding: 4px;
            text-align: center;
            min-width: 70px;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            transition: all 0.3s ease;
        }

        .track-channel.playing {
            background: #333;
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.3);
            border: 1px solid rgba(0, 255, 65, 0.4);
        }

        .track-name {
            font-size: 11px;
            font-weight: bold;
            color: #3DA9FC;
            margin-bottom: 10px;
            height: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #0D0D0D 0%, #1F1F1F 100%);
            border-radius: 6px;
            border: 2px solid #E0E0E0;
            text-shadow: 0 0 8px #3DA9FC;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 2px 6px;
            position: relative;
            box-shadow:
                0 0 10px rgba(61, 169, 252, 0.3),
                inset 0 0 10px rgba(61, 169, 252, 0.1);
            width: 100%;
        }

        .track-name::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(61, 169, 252, 0.4), transparent);
            animation: ledScan 4s infinite;
        }

        @keyframes ledScan {
            0% {
                left: -100%;
            }

            100% {
                left: 100%;
            }
        }

        .track-name-text {
            font-family: 'Courier New', 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 11px;
            font-weight: normal;
            color: #00FF41;
            margin-bottom: 0px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 100%;
            line-height: 1.1;
            letter-spacing: 0.6px;
            text-transform: uppercase;
        }

        .track-volume-indicator {
            font-size: 9px;
            color: #a0aec0;
            font-weight: normal;
        }


        .track-name.muted {
            background: linear-gradient(135deg, #0D0D0D 0%, #1F1F1F 100%);
            border-color: #ff6b6b;
            box-shadow:
                0 0 10px rgba(255, 107, 107, 0.3),
                inset 0 0 10px rgba(255, 107, 107, 0.1);
        }

        .track-name.muted::before {
            background: linear-gradient(90deg, transparent, rgba(255, 107, 107, 0.4), transparent);
        }

        .track-name.solo {
            background: linear-gradient(135deg, #0D0D0D 0%, #1F1F1F 100%);
            border-color: #ffd700;
            box-shadow:
                0 0 10px rgba(255, 215, 0, 0.3),
                inset 0 0 10px rgba(255, 215, 0, 0.1);
        }

        .track-name.solo::before {
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.4), transparent);
        }

        .track-name.muted .track-name-text {
            color: #FF0040;
        }

        .track-name.solo .track-name-text {
            color: #FFD700;
        }

        .track-name.click-cue {
            background: linear-gradient(135deg, #0D0D0D 0%, #1F1F1F 100%);
            border-color: #ff6b6b;
            font-weight: bold;
            box-shadow:
                0 0 10px rgba(255, 107, 107, 0.3),
                inset 0 0 10px rgba(255, 107, 107, 0.1);
        }

        .track-name.click-cue::before {
            background: linear-gradient(90deg, transparent, rgba(255, 107, 107, 0.4), transparent);
        }

        .track-name.click-cue .track-name-text {
            color: #FF0040;
        }

        .track-channel.click-cue {
            border-left: 4px solid #dc3545;
        }

        .led-meter-container {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            height: 133px;
            gap: 3px;
            padding-bottom: 0px;
            margin-top: 0px;
        }

        .led-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #333;
            border: 1px solid #555;
            transition: all 0.1s ease;
        }

        .led-dot.active {
            background: #00FF41;
            box-shadow: 0 0 8px #00FF41;
            border-color: #00FF41;
        }

        .led-dot.warning {
            background: #FFD700;
            box-shadow: 0 0 8px #FFD700;
            border-color: #FFD700;
        }

        .led-dot.danger {
            background: #FF4444;
            box-shadow: 0 0 8px #FF4444;
            border-color: #FF4444;
        }

        .click-led-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 133px;
            margin-top: 57px;
        }

        .click-led-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #333;
            border: 2px solid #555;
            transition: all 0.1s ease;
        }

        .click-led-dot.active {
            background: #FF0000;
            box-shadow: 0 0 12px #FF0000;
            border-color: #FF0000;
        }

        /* Track Styles - Fixed Position */
        .track-channel {
            transition: box-shadow 0.2s ease;
        }

        .track-channel:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .vu-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(to top,
                    rgba(0, 255, 0, 0.8) 0%,
                    rgba(128, 255, 0, 0.8) 30%,
                    rgba(255, 255, 0, 0.8) 60%,
                    rgba(255, 128, 0, 0.8) 80%,
                    rgba(255, 0, 0, 0.8) 100%);
            border-radius: 3px;
        }

        .track-channel.click-cue .fader-level {
            background: linear-gradient(180deg, #dc3545, #c82333);
        }

        .track-channel.click-cue .fader-thumb {
            background: #dc3545;
        }

        /* Digital Console LED Screen Styles */
        .console-led-screen {
            width: calc(96% - 40px);
            min-height: 200px;
            background:
                linear-gradient(135deg, #0A0A0A 0%, #1A1A1A 25%, #0F0F0F 50%, #1A1A1A 75%, #0A0A0A 100%),
                radial-gradient(circle at 30% 20%, rgba(0, 255, 65, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 70% 80%, rgba(61, 169, 252, 0.08) 0%, transparent 50%);
            border: 8px solid #2A2A2A;
            border-radius: 12px;
            margin: 22px auto;
            box-shadow:
                inset 0 3px 0 rgba(255, 255, 255, 0.15),
                inset 0 -3px 0 rgba(0, 0, 0, 0.4);
            overflow: hidden;
            position: relative;
            display: block !important;
            visibility: visible !important;
            /* Fix LED screen position to prevent movement during loading */
            transform: translateZ(0);
            will-change: auto;
            backface-visibility: hidden;
        }


        .console-led-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                linear-gradient(45deg,
                    transparent 0%,
                    rgba(255, 255, 255, 0.02) 15%,
                    transparent 30%,
                    rgba(255, 255, 255, 0.01) 45%,
                    transparent 60%,
                    rgba(255, 255, 255, 0.02) 75%,
                    transparent 100%);
            pointer-events: none;
        }

        .led-screen-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background:
                linear-gradient(90deg, #0F0F0F 0%, #1A1A1A 25%, #2A2A2A 50%, #1A1A1A 75%, #0F0F0F 100%);
            border-bottom: 2px solid #333;
            border-top: 1px solid #444;
            position: relative;
            z-index: 2;
            box-shadow:
                0 2px 10px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .led-screen-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .led-control-btn {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            color: #3DA9FC;
            border: 1px solid #444;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            transition: all 0.2s ease;
            min-width: 50px;
            text-align: center;
        }

        .led-control-btn:hover {
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            color: #00FF41;
            text-shadow: 0 0 5px #00FF41;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .led-screen-title {
            display: flex;
            align-items: center;
        }

        .led-screen-title .master-volume-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0;
        }

        .led-screen-title .master-label {
            font-family: 'Courier New', 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 12px;
            font-weight: bold;
            color: #3DA9FC;
            text-shadow: 0 0 5px #3DA9FC;
            letter-spacing: 1px;
            margin: 0;
        }

        .led-screen-title .master-volume-slider {
            width: 120px;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .led-screen-title .master-volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #3DA9FC;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(61, 169, 252, 0.5);
        }

        .led-screen-title .master-volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #3DA9FC;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(61, 169, 252, 0.5);
        }

        .led-screen-title .master-volume-value {
            font-family: 'Courier New', 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 10px;
            font-weight: bold;
            color: #00FF41;
            text-shadow: 0 0 3px #00FF41;
            min-width: 30px;
            text-align: center;
        }

        .led-screen-tabs {
            display: flex;
            gap: 4px;
            padding: 0 5px;
        }

        .led-tab {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            color: #3DA9FC;
            border: 1px solid #444;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .led-tab:hover {
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            border-color: #555;
            color: #00FF41;
            text-shadow: 0 0 5px #00FF41;
        }

        .led-tab.active {
            background: linear-gradient(145deg, #C0C0C0, #A8A8A8);
            color: #000;
            border-color: #C0C0C0;
            box-shadow: 0 0 10px rgba(192, 192, 192, 0.5);
        }

        .led-screen-content {
            padding: 25px;
            height: 266px;
            overflow: hidden;
            position: relative;
            z-index: 1;
            background:
                linear-gradient(135deg, rgba(0, 0, 0, 0.3) 0%, transparent 50%);
            border-radius: 0 0 20px 20px;
            display: block !important;
            visibility: visible !important;
        }

        .led-progress-section {
            padding: 5px 20px;
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
            border-bottom: 1px solid #333;
            margin-bottom: 15px;
        }

        .main-display .led-progress-section {
            margin: 0 0 15px 0;
            border-radius: 4px;
        }

        .function-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-top: 15px;
        }

        .function-btn {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            color: #3DA9FC;
            border: 1px solid #444;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
            transition: all 0.2s ease;
            text-align: center;
        }

        .function-btn:hover {
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            color: #00FF41;
            text-shadow: 0 0 5px #00FF41;
            transform: translateY(-1px);
        }

        .function-btn:active {
            transform: translateY(0);
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* About Mode Styles */
        .about-display {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            padding: 20px;
        }

        .about-content {
            text-align: center;
            color: #fff;
        }

        .about-logo {
            width: 120px;
            height: 120px;
            margin-bottom: 20px;
            filter: drop-shadow(0 0 20px #007AFF);
            animation: logoPulse 3s ease-in-out infinite;
        }

        .about-text {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .about-company {
            font-size: 24px;
            font-weight: bold;
            color: #00FF41;
            text-shadow: 0 0 10px #00FF41;
        }

        .about-version {
            font-size: 18px;
            color: #007AFF;
            font-weight: bold;
        }

        .about-copyright {
            font-size: 14px;
            color: #888;
            font-style: italic;
        }

        /* Main Mode Styles */
        .main-display {
            padding: 15px;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .main-title {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            color: #00FF41;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 5px #00FF41;
            letter-spacing: 2px;
            position: relative;
        }

        .main-controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            height: 100%;
            align-items: center;
        }

        .left-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .center-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .right-controls {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .transport-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .transport-btn {
            background:
                linear-gradient(145deg, #1A1A1A, #0F0F0F),
                radial-gradient(circle at 30% 30%, rgba(0, 255, 65, 0.1) 0%, transparent 50%);
            color: #3DA9FC;
            border: 2px solid #333;
            width: 100px;
            height: 100px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow:
                0 8px 16px rgba(0, 0, 0, 0.4),
                inset 0 2px 0 rgba(255, 255, 255, 0.1),
                inset 0 -2px 0 rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }


        .transport-btn:hover {
            background:
                linear-gradient(145deg, #2A2A2A, #1A1A1A);
            color: #00FF41;
            text-shadow: 0 0 5px #00FF41;
            transform: translateY(-3px);
            box-shadow:
                0 8px 16px rgba(0, 0, 0, 0.5),
                inset 0 2px 0 rgba(255, 255, 255, 0.2);
            border-color: #00FF41;
        }


        .transport-btn:active {
            transform: translateY(1px);
            box-shadow:
                0 2px 4px rgba(0, 0, 0, 0.4),
                inset 0 2px 4px rgba(0, 0, 0, 0.3);
            background:
                linear-gradient(145deg, #0F0F0F, #1A1A1A);
        }

        .time-info {
            font-family: 'Courier New', monospace;
            font-size: 22px;
            font-weight: bold;
            color: #3DA9FC;
            text-shadow: 0 0 5px #3DA9FC;
            letter-spacing: 3px;
            text-align: center;
            background:
                linear-gradient(90deg, rgba(0, 0, 0, 0.3) 0%, rgba(61, 169, 252, 0.1) 50%, rgba(0, 0, 0, 0.3) 100%);
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid rgba(61, 169, 252, 0.3);
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }


        .led-mode {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        /* F6 EQ Interface Styles */
        .f6-eq-interface {
            width: 100%;
            height: 100%;
            background: #1a1a1a;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Top Bar */
        .eq-top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 15px;
            background: #2a2a2a;
            border-bottom: 1px solid #444;
        }

        .eq-top-left,
        .eq-top-right {
            display: flex;
            gap: 5px;
        }

        .eq-top-btn {
            background: #333;
            border: 1px solid #555;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .eq-top-btn:hover {
            background: #444;
            color: #fff;
        }

        .eq-preset-name {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #00FF41;
            text-shadow: 0 0 5px #00FF41;
        }

        /* Graph Container */
        .eq-graph-container {
            display: flex;
            flex: 1;
            background: #1a1a1a;
        }

        .eq-graph {
            flex: 1;
            position: relative;
            background: #0f0f0f;
            border: 1px solid #333;
            margin: 10px;
            border-radius: 4px;
        }

        #eqCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .eq-band-handles {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .eq-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 2px solid #fff;
            border-radius: 50%;
            background: #333;
            cursor: pointer;
            pointer-events: all;
            transform: translate(-50%, -50%);
        }

        .eq-handle.band-1 {
            background: #ff4444;
        }

        .eq-handle.band-2 {
            background: #44ff44;
        }

        .eq-handle.band-3 {
            background: #4444ff;
        }

        .eq-handle.band-4 {
            background: #44ffff;
        }

        .eq-handle.band-5 {
            background: #ff44ff;
        }

        .eq-handle.band-6 {
            background: #ffff44;
        }

        /* Output Meter */
        .eq-output-meter {
            width: 30px;
            background: #0f0f0f;
            border: 1px solid #333;
            margin: 10px 10px 10px 0;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 5px;
        }

        .meter-scale {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 100%;
            font-size: 8px;
            color: #666;
        }

        .meter-bar {
            width: 8px;
            height: 100%;
            background: #222;
            border-radius: 2px;
            position: relative;
            margin: 5px 0;
        }

        .meter-level {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #ff0000, #ffff00, #00ff00);
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        /* Control Panel */
        .eq-control-panel {
            display: flex;
            align-items: center;
            padding: 10px;
            background: #2a2a2a;
            border-top: 1px solid #444;
            gap: 15px;
        }

        .eq-left-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .f6-logo {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            color: #00FF41;
            text-shadow: 0 0 5px #00FF41;
        }

        .eq-stereo-controls {
            display: flex;
            gap: 2px;
        }

        .stereo-btn {
            background: #333;
            border: 1px solid #555;
            color: #ccc;
            padding: 2px 6px;
            border-radius: 2px;
            font-size: 10px;
            cursor: pointer;
        }

        .stereo-btn.active {
            background: #00FF41;
            color: #000;
        }

        /* Band Selector */
        .eq-band-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .filter-type-icons {
            display: flex;
            gap: 8px;
        }

        .filter-icon {
            width: 20px;
            height: 20px;
            border: 1px solid #555;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #666;
        }

        .filter-icon.active {
            border-color: #00FF41;
            color: #00FF41;
        }

        .band-buttons {
            display: flex;
            gap: 3px;
        }

        .band-btn {
            width: 25px;
            height: 25px;
            background: #333;
            border: 1px solid #555;
            color: #ccc;
            border-radius: 3px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .band-btn.active {
            background: #00FF41;
            color: #000;
        }

        /* Global Controls */
        .eq-global-controls {
            display: flex;
            gap: 10px;
        }

        .global-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .global-control label {
            font-size: 10px;
            color: #ccc;
        }

        .control-value {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #00FF41;
            text-shadow: 0 0 3px #00FF41;
        }

        .control-buttons {
            display: flex;
            gap: 2px;
        }

        .control-btn {
            width: 15px;
            height: 15px;
            background: #333;
            border: 1px solid #555;
            color: #ccc;
            border-radius: 2px;
            font-size: 10px;
            cursor: pointer;
        }

        /* Band Controls */
        .eq-band-controls {
            display: flex;
            gap: 8px;
        }

        .knob-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }

        .knob-control label {
            font-size: 9px;
            color: #ccc;
            text-align: center;
        }

        .knob {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #2a2a2a 0%, #1a1a1a 100%);
            border: 2px solid #444;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
        }

        .knob-value {
            font-family: 'Courier New', monospace;
            font-size: 10px;
            color: #00FF41;
            text-shadow: 0 0 3px #00FF41;
            font-weight: bold;
        }

        .knob-range {
            font-size: 7px;
            color: #666;
        }

        /* Right Section */
        .eq-right-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .solo-btn {
            width: 30px;
            height: 30px;
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
        }

        .sc-controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .sc-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .sc-control label {
            font-size: 8px;
            color: #ccc;
        }

        .sc-options {
            display: flex;
            gap: 2px;
        }

        .sc-btn {
            background: #333;
            border: 1px solid #555;
            color: #ccc;
            padding: 2px 6px;
            border-radius: 2px;
            font-size: 9px;
            cursor: pointer;
        }

        .sc-btn.active {
            background: #00FF41;
            color: #000;
        }

        /* Edit Mode Styles */
        .edit-display {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .analyzer-display,
        .settings-display {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .edit-title {
            font-family: 'Courier New', monospace;
            font-size: 16px;
            color: #FFD700;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 8px #FFD700;
            letter-spacing: 1px;
        }

        .edit-controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .edit-section {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
            border: 1px solid #333;
            border-radius: 4px;
        }

        .edit-section label {
            font-family: 'Courier New', monospace;
            color: #3DA9FC;
            font-weight: bold;
            min-width: 100px;
        }

        .led-input {
            background: #0a0a0a;
            border: 1px solid #444;
            color: #00FF41;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            flex: 1;
        }

        .led-input:focus {
            outline: none;
            border-color: #3DA9FC;
            box-shadow: 0 0 5px rgba(61, 169, 252, 0.3);
        }

        .led-btn {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            color: #3DA9FC;
            border: 1px solid #444;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            transition: all 0.2s ease;
        }

        .led-btn:hover {
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            color: #00FF41;
            text-shadow: 0 0 5px #00FF41;
        }

        .color-picker {
            display: flex;
            gap: 8px;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border: 2px solid #333;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .color-option:hover {
            border-color: #3DA9FC;
            box-shadow: 0 0 8px rgba(61, 169, 252, 0.5);
            transform: scale(1.1);
        }

        .color-option.selected {
            border-color: #00FF41;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.7);
        }

        .fader-container {
            height: 190px;
            position: relative;
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #0a0a0a;
            border-radius: 4px;
            padding: 6px;
            gap: 6px;
            border: 1px solid #333;
        }

        .fader-track {
            width: 26px;
            height: 100%;
            background: #1a1a1a;
            border-radius: 2px;
            position: relative;
            margin: 0 auto;
            border: 1px solid #444;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        .fader-thumb {
            width: 30px;
            height: 16px;
            background: linear-gradient(145deg, #e0e0e0, #c0c0c0);
            border-radius: 2px;
            position: absolute;
            left: -2px;
            cursor: pointer;
            transition: all 0.1s ease;
            box-shadow:
                0 2px 4px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            border: 1px solid #999;
        }

        .fader-thumb:hover {
            background: linear-gradient(145deg, #f0f0f0, #d0d0d0);
            box-shadow:
                0 3px 6px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }

        .fader-level {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #ff0000 0%, #ff8800 20%, #ffff00 40%, #88ff00 60%, #00ff00 80%, #00ff88 100%) !important;
            border-radius: 0 0 2px 2px;
            transition: height 0.1s ease;
            opacity: 0.9 !important;
            display: block !important;
            visibility: visible !important;
        }


        .fader-scale {
            position: absolute;
            left: -30px;
            top: 0;
            height: 100%;
            width: 25px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-size: 7px;
            color: #fff;
            text-align: right;
            font-weight: bold;
        }

        .fader-scale span {
            line-height: 1;
            opacity: 0.8;
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.3);
        }

        .track-controls {
            display: flex;
            gap: 5px;
            justify-content: center;
            flex-direction: row;
            align-items: center;
        }

        .track-control-btn {
            width: 25px;
            height: 25px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
        }

        .track-play-btn {
            width: 30px;
            height: 30px;
            background: #28a745;
            color: #fff;
            font-size: 12px;
            margin-bottom: 3px;
        }

        .track-play-btn:hover {
            background: #218838;
        }

        .track-play-btn.playing {
            background: #dc3545;
        }

        .track-play-btn.playing:hover {
            background: #c82333;
        }

        .mute-btn {
            background: #1a1a1a;
            color: #ccc;
            border: 1px solid #444;
        }

        .mute-btn.active {
            background: #8b0000;
            color: #fff;
            border: 1px solid #ff0000;
        }

        .solo-btn {
            background: #1a1a1a;
            color: #ccc;
            border: 1px solid #444;
        }

        .solo-btn.active {
            background: #8b8000;
            color: #fff;
            border: 1px solid #ffff00;
        }

        /* Right Panel */
        .right-panel {
            flex: 3;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
        }

        /* Panel Tabs */
        .panel-tabs {
            display: flex;
            background: #222;
            border-bottom: 1px solid #333;
        }

        .tab-btn {
            flex: 1;
            padding: 12px 16px;
            background: transparent;
            color: #888;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .tab-btn:hover {
            background: #333;
            color: #fff;
        }

        .tab-btn.active {
            background: #007AFF;
            color: #fff;
        }

        .tab-content {
            display: none;
            padding: 20px;
            height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .tab-content.active {
            display: block;
        }

        /* Library and Setlist Styles */
        .library-items,
        .setlist-list {
            padding: 10px 0;
        }

        .library-song-item,
        .setlist-item {
            background: #2a2a2a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            z-index: 10000;
        }

        .library-song-item:hover,
        .setlist-item:hover {
            background: #333;
            border-color: #007AFF;
        }

        .song-info,
        .setlist-info {
            flex: 1;
        }

        .song-info h4,
        .setlist-info h4 {
            margin: 0 0 4px 0;
            color: #fff;
            font-size: 14px;
        }

        .song-info p,
        .setlist-info p {
            margin: 0;
            color: #888;
            font-size: 12px;
        }

        .song-actions,
        .setlist-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            background: #444;
            border: none;
            border-radius: 4px;
            padding: 6px 8px;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }

        .action-btn:hover {
            background: #555;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #888;
        }

        .empty-state p {
            margin: 8px 0;
        }

        .create-setlist-btn {
            background: #007AFF;
            border: none;
            border-radius: 6px;
            padding: 10px 16px;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            margin-top: 12px;
            transition: background 0.3s ease;
        }

        .create-setlist-btn:hover {
            background: #0056CC;
        }

        /* Library and Setlist Items */

        .library-song-item:hover,
        .setlist-item:hover {
            background: #333;
            border-color: #007AFF;
        }

        .song-info,
        .setlist-info {
            flex: 1;
        }

        .song-info h4,
        .setlist-info h4 {
            color: #fff;
            margin: 0 0 4px 0;
            font-size: 16px;
        }

        .song-info p,
        .setlist-info p {
            color: #888;
            margin: 2px 0;
            font-size: 14px;
        }

        .song-date,
        .setlist-date {
            color: #666 !important;
            font-size: 12px !important;
        }

        .song-actions,
        .setlist-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            background: #444;
            border: none;
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s ease;
        }

        .action-btn:hover {
            background: #007AFF;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #888;
        }

        .empty-state p {
            margin: 8px 0;
        }

        .create-setlist-btn {
            background: #007AFF;
            color: #fff;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 16px;
        }

        .create-setlist-btn:hover {
            background: #0056b3;
        }

        .setlist-section {
            flex: 1;
            padding: 20px;
            border-bottom: 1px solid #333;
            width: 100%;
        }

        .canciones-section {
            flex: 1;
            padding: 20px;
            border-bottom: 1px solid #333;
            width: 100%;
        }

        .canciones-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .canciones-title {
            font-size: 18px;
            font-weight: bold;
            color: #007AFF;
        }

        .canciones-container {
            width: calc(100% - 40px);
            height: calc(70vh - 100px);
            background:
                linear-gradient(135deg, #0A0A0A 0%, #1A1A1A 25%, #0F0F0F 50%, #1A1A1A 75%, #0A0A0A 100%),
                radial-gradient(circle at 30% 20%, rgba(0, 255, 65, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 70% 80%, rgba(61, 169, 252, 0.08) 0%, transparent 50%);
            border: 8px solid #2A2A2A;
            border-radius: 12px;
            margin: 20px auto 10px auto;
            padding: 20px 20px 20px 20px;
            box-shadow:
                inset 0 3px 0 rgba(255, 255, 255, 0.15),
                inset 0 -3px 0 rgba(0, 0, 0, 0.4);
            overflow: hidden;
            position: relative;
        }

        .canciones-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                linear-gradient(45deg,
                    transparent 0%,
                    rgba(255, 255, 255, 0.02) 15%,
                    transparent 30%,
                    rgba(255, 255, 255, 0.01) 45%,
                    transparent 60%,
                    rgba(255, 255, 255, 0.02) 75%,
                    transparent 100%);
            pointer-events: none;
            z-index: 1;
        }

        .setlist-button-container {
            position: absolute;
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .canciones-list {
            margin-top: 75px;
            position: relative;
            z-index: 10000;
        }

        .setlist-led-display {
            background: #000;
            border: 2px solid #333;
            border-radius: 4px;
            padding: 8px 16px;
            min-width: 180px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .led-text {
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .led-line-1 {
            margin-bottom: 4px;
            line-height: 1;
        }

        .led-line-2 {
            color: #3DA9FC;
            text-shadow: 0 0 5px #3DA9FC;
            font-size: 9px;
            margin-bottom: 2px;
            line-height: 1;
        }

        /* LED Marquee */
        .led-marquee {
            width: 100%;
            overflow: hidden;
            white-space: nowrap;
        }

        .marquee-content {
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            text-shadow: 0 0 5px #00ff00;
            display: inline-block;
            animation: marquee 15s linear infinite;
            padding-left: 100%;
        }

        @keyframes marquee {
            0% {
                transform: translateX(0);
            }

            100% {
                transform: translateX(-100%);
            }
        }

        .marquee-content:hover {
            animation-play-state: paused;
        }

        /* Sampler LED Display */
        .sampler-led-container {
            width: calc(100% - 40px);
            margin: 10px auto 20px auto;
            display: flex;
            justify-content: center;
        }

        .sampler-led-display {
            background: #000;
            border: 2px solid #FF6B35;
            border-radius: 8px;
            padding: 12px 24px;
            min-width: 200px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow:
                0 0 10px rgba(255, 107, 53, 0.3),
                inset 0 0 10px rgba(255, 107, 53, 0.1);
        }

        .sampler-led-text {
            color: #FF6B35;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 8px #FF6B35;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .canciones-container {
            position: relative;
        }

        /* PADS Section */
        .pads-container {
            width: calc(100% - 40px);
            height: calc(30vh - 100px);
            background:
                linear-gradient(135deg, #0A0A0A 0%, #1A1A1A 25%, #0F0F0F 50%, #1A1A1A 75%, #0A0A0A 100%),
                radial-gradient(circle at 30% 20%, rgba(0, 255, 65, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 70% 80%, rgba(61, 169, 252, 0.08) 0%, transparent 50%);
            border: 8px solid #2A2A2A;
            border-radius: 12px;
            margin: 10px auto 20px auto;
            padding: 15px;
            box-shadow:
                inset 0 3px 0 rgba(255, 255, 255, 0.15),
                inset 0 -3px 0 rgba(0, 0, 0, 0.4);
            overflow: hidden;
            position: relative;
        }

        .pads-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                linear-gradient(45deg,
                    transparent 0%,
                    rgba(255, 255, 255, 0.02) 15%,
                    transparent 30%,
                    rgba(255, 255, 255, 0.01) 45%,
                    transparent 60%,
                    rgba(255, 255, 255, 0.02) 75%,
                    transparent 100%);
            pointer-events: none;
            z-index: 1;
        }

        .pads-header {
            position: relative;
            z-index: 2;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .pads-title-led {
            display: flex;
            align-items: center;
        }

        .pads-led-display {
            background: #000;
            border: 2px solid #00FF41;
            border-radius: 6px;
            padding: 6px 12px;
            min-width: 60px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow:
                0 0 8px rgba(0, 255, 65, 0.4),
                inset 0 0 8px rgba(0, 255, 65, 0.1);
        }

        .pads-led-text {
            color: #00FF41;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 6px #00FF41;
            white-space: nowrap;
        }

        /* Octave Selector */
        .octave-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .octave-btn {
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            color: #00FF41;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .octave-btn:hover {
            background: #444;
            border-color: #00FF41;
            box-shadow: 0 0 8px rgba(0, 255, 65, 0.3);
        }

        .octave-display {
            color: #00FF41;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 5px #00FF41;
            min-width: 20px;
            text-align: center;
        }

        .pads-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 4px;
            position: relative;
            z-index: 2;
            width: 100%;
        }

        .pad-button {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 9px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            position: relative;
            overflow: hidden;
        }

        .pad-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .pad-button:hover::before {
            left: 100%;
        }

        /* C - Azul */
        .pad-button:nth-child(1) {
            background: rgba(59, 130, 246, 0.2);
            border-color: rgba(59, 130, 246, 0.4);
            color: #60A5FA;
        }

        .pad-button:nth-child(1):hover {
            background: rgba(59, 130, 246, 0.3);
            border-color: #60A5FA;
            box-shadow: 0 0 20px rgba(96, 165, 250, 0.4);
        }

        .pad-button:nth-child(1).active {
            background: rgba(59, 130, 246, 0.6);
            border-color: #60A5FA;
            color: #FFFFFF;
            box-shadow: 0 0 25px rgba(96, 165, 250, 0.8);
        }

        /* C# - Prpura */
        .pad-button:nth-child(2) {
            background: rgba(147, 51, 234, 0.2);
            border-color: rgba(147, 51, 234, 0.4);
            color: #A78BFA;
        }

        .pad-button:nth-child(2):hover {
            background: rgba(147, 51, 234, 0.3);
            border-color: #A78BFA;
            box-shadow: 0 0 20px rgba(167, 139, 250, 0.4);
        }

        .pad-button:nth-child(2).active {
            background: rgba(147, 51, 234, 0.6);
            border-color: #A78BFA;
            color: #FFFFFF;
            box-shadow: 0 0 25px rgba(167, 139, 250, 0.8);
        }

        /* D - Verde */
        .pad-button:nth-child(3) {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.4);
            color: #4ADE80;
        }

        .pad-button:nth-child(3):hover {
            background: rgba(34, 197, 94, 0.3);
            border-color: #4ADE80;
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.4);
        }

        .pad-button:nth-child(3).active {
            background: rgba(34, 197, 94, 0.6);
            border-color: #4ADE80;
            color: #FFFFFF;
            box-shadow: 0 0 25px rgba(74, 222, 128, 0.8);
        }

        /* D# - Rosa */
        .pad-button:nth-child(4) {
            background: rgba(236, 72, 153, 0.2);
            border-color: rgba(236, 72, 153, 0.4);
            color: #F472B6;
        }

        .pad-button:nth-child(4):hover {
            background: rgba(236, 72, 153, 0.3);
            border-color: #F472B6;
            box-shadow: 0 0 20px rgba(244, 114, 182, 0.4);
        }

        .pad-button:nth-child(4).active {
            background: rgba(236, 72, 153, 0.6);
            border-color: #F472B6;
            color: #FFFFFF;
            box-shadow: 0 0 25px rgba(244, 114, 182, 0.8);
        }

        /* E - Amarillo */
        .pad-button:nth-child(5) {
            background: rgba(234, 179, 8, 0.2);
            border-color: rgba(234, 179, 8, 0.4);
            color: #FCD34D;
        }

        .pad-button:nth-child(5):hover {
            background: rgba(234, 179, 8, 0.3);
            border-color: #FCD34D;
            box-shadow: 0 0 20px rgba(252, 211, 77, 0.4);
        }

        .pad-button:nth-child(5).active {
            background: rgba(234, 179, 8, 0.6);
            border-color: #FCD34D;
            color: #FFFFFF;
            box-shadow: 0 0 25px rgba(252, 211, 77, 0.8);
        }

        /* F - Naranja */
        .pad-button:nth-child(6) {
            background: rgba(249, 115, 22, 0.2);
            border-color: rgba(249, 115, 22, 0.4);
            color: #FB923C;
        }

        .pad-button:nth-child(6):hover {
            background: rgba(249, 115, 22, 0.3);
            border-color: #FB923C;
            box-shadow: 0 0 20px rgba(251, 146, 60, 0.4);
        }

        .pad-button:nth-child(6).active {
            background: rgba(249, 115, 22, 0.6);
            border-color: #FB923C;
            color: #FFFFFF;
            box-shadow: 0 0 25px rgba(251, 146, 60, 0.8);
        }

        /* F# - Rojo */
        .pad-button:nth-child(7) {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.4);
            color: #F87171;
        }

        .pad-button:nth-child(7):hover {
            background: rgba(239, 68, 68, 0.3);
            border-color: #F87171;
            box-shadow: 0 0 20px rgba(248, 113, 113, 0.4);
        }

        .pad-button:nth-child(7).active {
            background: rgba(239, 68, 68, 0.6);
            border-color: #F87171;
            color: #FFFFFF;
            box-shadow: 0 0 25px rgba(248, 113, 113, 0.8);
        }

        /* G - Cian */
        .pad-button:nth-child(8) {
            background: rgba(6, 182, 212, 0.2);
            border-color: rgba(6, 182, 212, 0.4);
            color: #22D3EE;
        }

        .pad-button:nth-child(8):hover {
            background: rgba(6, 182, 212, 0.3);
            border-color: #22D3EE;
            box-shadow: 0 0 20px rgba(34, 211, 238, 0.4);
        }

        .pad-button:nth-child(8).active {
            background: rgba(6, 182, 212, 0.6);
            border-color: #22D3EE;
            color: #FFFFFF;
            box-shadow: 0 0 25px rgba(34, 211, 238, 0.8);
        }

        /* G# - ndigo */
        .pad-button:nth-child(9) {
            background: rgba(79, 70, 229, 0.2);
            border-color: rgba(79, 70, 229, 0.4);
            color: #818CF8;
        }

        .pad-button:nth-child(9):hover {
            background: rgba(79, 70, 229, 0.3);
            border-color: #818CF8;
            box-shadow: 0 0 20px rgba(129, 140, 248, 0.4);
        }

        .pad-button:nth-child(9).active {
            background: rgba(79, 70, 229, 0.6);
            border-color: #818CF8;
            color: #FFFFFF;
            box-shadow: 0 0 25px rgba(129, 140, 248, 0.8);
        }

        /* A - Verde Lima */
        .pad-button:nth-child(10) {
            background: rgba(132, 204, 22, 0.2);
            border-color: rgba(132, 204, 22, 0.4);
            color: #A3E635;
        }

        .pad-button:nth-child(10):hover {
            background: rgba(132, 204, 22, 0.3);
            border-color: #A3E635;
            box-shadow: 0 0 20px rgba(163, 230, 53, 0.4);
        }

        .pad-button:nth-child(10).active {
            background: rgba(132, 204, 22, 0.6);
            border-color: #A3E635;
            color: #FFFFFF;
            box-shadow: 0 0 25px rgba(163, 230, 53, 0.8);
        }

        /* Bb - Teal */
        .pad-button:nth-child(11) {
            background: rgba(20, 184, 166, 0.2);
            border-color: rgba(20, 184, 166, 0.4);
            color: #5EEAD4;
        }

        .pad-button:nth-child(11):hover {
            background: rgba(20, 184, 166, 0.3);
            border-color: #5EEAD4;
            box-shadow: 0 0 20px rgba(94, 234, 212, 0.4);
        }

        .pad-button:nth-child(11).active {
            background: rgba(20, 184, 166, 0.6);
            border-color: #5EEAD4;
            color: #FFFFFF;
            box-shadow: 0 0 25px rgba(94, 234, 212, 0.8);
        }

        /* B - Violeta */
        .pad-button:nth-child(12) {
            background: rgba(139, 92, 246, 0.2);
            border-color: rgba(139, 92, 246, 0.4);
            color: #C4B5FD;
        }

        .pad-button:nth-child(12):hover {
            background: rgba(139, 92, 246, 0.3);
            border-color: #C4B5FD;
            box-shadow: 0 0 20px rgba(196, 181, 253, 0.4);
        }

        .pad-button:nth-child(12).active {
            background: rgba(139, 92, 246, 0.6);
            border-color: #C4B5FD;
            color: #FFFFFF;
            box-shadow: 0 0 25px rgba(196, 181, 253, 0.8);
        }



        .setlist-main-btn {
            background: #555;
            color: white;
            border: none;
            padding: 8px 16px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .setlist-main-btn:hover {
            background: #666;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .setlist-sidebar {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: #1a1a1a;
            border-left: 1px solid #333;
            transition: right 0.3s ease;
            z-index: 10000;
            overflow-y: auto;
        }

        .setlist-sidebar.open {
            right: 0;
        }

        .setlist-sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #333;
            background: #2a2a2a;
        }

        .setlist-sidebar-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .setlist-sidebar-header h3 {
            color: #007AFF;
            margin: 0;
            font-size: 20px;
        }

        .close-setlist-btn {
            background: none;
            border: none;
            color: #ccc;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
        }

        .close-setlist-btn:hover {
            color: #fff;
        }

        .setlist-sidebar-content {
            padding: 20px;
        }

        .setlist-sidebar-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .setlist-sidebar-item {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            transition: all 0.3s ease;
            border: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .setlist-item-content {
            flex: 1;
            cursor: pointer;
        }

        .setlist-sidebar-item:hover {
            background: #444;
            border-color: #007AFF;
        }

        .setlist-sidebar-item h4 {
            color: #fff;
            margin: 0 0 5px 0;
            font-size: 16px;
        }

        .setlist-sidebar-item p {
            color: #ccc;
            margin: 0;
            font-size: 12px;
        }

        .setlist-number {
            color: #007AFF;
            font-weight: bold;
            margin-right: 8px;
        }

        .setlist-item-menu {
            position: relative;
        }

        .setlist-menu-btn {
            background: none;
            border: none;
            color: #888;
            font-size: 18px;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .setlist-menu-btn:hover {
            background: #555;
            color: #fff;
        }

        .setlist-menu-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            min-width: 120px;
        }

        .setlist-menu-item {
            background: none;
            border: none;
            color: #fff;
            padding: 10px 15px;
            cursor: pointer;
            width: 100%;
            text-align: left;
            font-size: 14px;
            transition: background 0.2s ease;
            border-radius: 4px;
        }

        .setlist-menu-item:hover {
            background: #444;
        }

        .canciones-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .setlist-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .setlist-title {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
        }

        .setlist-btn {
            background: #007AFF;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        .sync-btn {
            background: #333;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        .song-list {
            max-height: 400px;
            overflow-y: auto;
            width: 100%;
        }

        .song-item {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            border-radius: 4px;
            margin-bottom: 3px;
            background: #222;
            cursor: pointer;
            width: 100%;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            min-height: 32px;
        }

        .song-item:hover {
            background: #333;
            border-color: #007AFF;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.2);
        }

        .song-item.selected {
            background: #444;
            border-color: #00FF41;
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.4);
            transform: translateY(-1px);
        }

        .song-item.selected .song-title {
            color: #00FF41;
            text-shadow: 0 0 8px rgba(0, 255, 65, 0.6);
        }

        .song-item.selected .song-artist {
            color: #4ADE80;
        }

        /* Song loading states */
        .song-item.loading {
            background: #333;
            border-color: #FFA500;
            box-shadow: 0 0 10px rgba(255, 165, 0, 0.3);
        }

        .song-item.loading .song-title {
            color: #FFA500;
        }

        .song-item.loaded {
            background: #1a3d1a;
            border-color: #4CAF50;
        }

        .song-item.loaded .song-title {
            color: #4CAF50;
        }

        .song-item.pending {
            background: #2a2a2a;
            border-color: #666;
            opacity: 0.7;
        }

        .song-item.error {
            background: #3d1a1a;
            border-color: #f44336;
        }

        .song-item.error .song-title {
            color: #f44336;
        }

        .loading-spinner {
            display: none;
            width: 12px;
            height: 12px;
            border: 2px solid #333;
            border-top: 2px solid #FFA500;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 5px;
        }

        .offline-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #4CAF50;
            border-radius: 50%;
            margin-left: 5px;
            position: relative;
        }

        .offline-indicator::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            font-size: 10px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }

            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .song-item:active {
            transform: translateY(0);
            box-shadow: 0 1px 4px rgba(0, 122, 255, 0.3);
        }

        .song-number-container {
            display: flex;
            align-items: center;
            margin-right: 6px;
            position: relative;
        }

        .song-number {
            width: 16px;
            text-align: center;
            font-weight: bold;
            font-size: 11px;
        }

        .song-loading-indicator {
            position: absolute;
            top: -3px;
            left: 0;
            right: 0;
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
            z-index: 10;
        }

        .mini-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00D4FF, #007AFF);
            width: 0%;
            border-radius: 2px;
            transition: width 0.3s ease;
            animation: mini-progress-pulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 8px rgba(0, 212, 255, 0.6);
        }

        @keyframes mini-progress-pulse {
            0% {
                opacity: 0.6;
            }

            50% {
                opacity: 1;
            }

            100% {
                opacity: 0.6;
            }
        }


        .song-info {
            flex: 1;
        }

        .song-title {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 2px;
            line-height: 1.2;
        }

        .song-artist {
            font-size: 10px;
            color: #999;
            font-weight: normal;
            margin-top: 1px;
            line-height: 1.1;
        }

        .song-details {
            display: flex;
            gap: 4px;
            margin-top: 2px;
            font-size: 9px;
            color: #666;
        }

        .song-meta {
            display: flex;
            gap: 6px;
            align-items: center;
            font-size: 11px;
            color: #888;
            margin-right: 10px;
        }

        .song-tempo,
        .song-key,
        .song-time-sig {
            background: #333;
            padding: 1px 3px;
            border-radius: 2px;
            color: #ccc;
            font-size: 8px;
            white-space: nowrap;
        }

        .song-tempo {
            color: #4CAF50;
        }

        .song-key {
            color: #FF9800;
        }

        .song-time-sig {
            color: #2196F3;
        }

        .song-menu {
            position: relative;
            display: inline-block;
        }

        .menu-btn {
            background: #333;
            border: none;
            color: #ccc;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .menu-btn:hover {
            background: #444;
            color: #fff;
        }

        .menu-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            min-width: 120px;
        }

        .menu-item {
            display: block;
            width: 100%;
            padding: 10px 15px;
            background: none;
            border: none;
            color: #ccc;
            text-align: left;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s ease;
        }

        .menu-item:hover {
            background: #333;
            color: #fff;
        }

        .song-key {
            background: #2a2a2a;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            color: #007AFF;
            border: 1px solid #444;
            text-align: center;
            min-width: 50px;
        }

        .song-bpm {
            background: #2a2a2a;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            color: #4CAF50;
            border: 1px solid #444;
            text-align: center;
            min-width: 50px;
        }

        .song-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .play-btn,
        .delete-btn {
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 6px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
            min-width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .play-btn {
            color: #4CAF50;
        }

        .play-btn:hover {
            background: #4CAF50;
            color: #fff;
            border-color: #4CAF50;
        }

        .delete-btn {
            color: #f44336;
        }

        .delete-btn:hover {
            background: #f44336;
            color: #fff;
            border-color: #f44336;
        }

        /* Library Section */
        .library-section {
            flex: 1;
            padding: 20px;
        }

        .library-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .library-title {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
        }

        .edit-btn {
            background: #333;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        .library-item {
            background: #222;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
        }

        .library-item-title {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .library-item-url {
            font-size: 10px;
            color: #888;
            margin-bottom: 10px;
        }

        .library-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .waveform-icon {
            width: 20px;
            height: 20px;
            background: #444;
            border-radius: 2px;
        }

        .power-btn {
            background: #333;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
        }

        .power-btn.active {
            background: #00ff00;
            color: #000;
        }

        .pads-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            margin-top: 15px;
        }

        .pad-btn {
            background: #333;
            color: white;
            border: none;
            padding: 15px 5px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }

        .pad-btn:hover {
            background: #444;
        }

        .pad-btn.active {
            background: #007AFF;
        }

        .library-fader {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }

        .library-fader-container {
            flex: 1;
            height: 80px;
            position: relative;
        }

        .library-fader-track {
            width: 15px;
            height: 100%;
            background: #333;
            border-radius: 8px;
            position: relative;
            margin: 0 auto;
        }

        .library-fader-thumb {
            width: 20px;
            height: 6px;
            background: #007AFF;
            border-radius: 3px;
            position: absolute;
            left: -2.5px;
            cursor: pointer;
        }

        .library-fader-level {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #ff0000 0%, #ffff00 50%, #00ff00 100%);
            border-radius: 0 0 8px 8px;
        }

        .library-controls-bottom {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .library-mute-btn,
        .library-solo-btn {
            width: 20px;
            height: 20px;
            border: 1px solid #444;
            border-radius: 3px;
            cursor: pointer;
            font-size: 8px;
            font-weight: bold;
            background: #1a1a1a;
            color: #ccc;
        }

        .library-mute-btn.active {
            background: #8b0000;
            color: #fff;
            border: 1px solid #ff0000;
        }

        .library-solo-btn.active {
            background: #8b8000;
            color: #fff;
            border: 1px solid #ffff00;
        }

        /* Audio Files Section */
        .audio-files-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #222;
            border-radius: 8px;
        }

        .audio-files-header {
            margin-bottom: 15px;
        }

        .audio-files-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .audio-file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #333;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 2px;
        }

        .file-size {
            color: #888;
            font-size: 10px;
        }

        .file-actions {
            display: flex;
            gap: 5px;
        }

        .play-btn,
        .delete-btn {
            background: #333;
            color: white;
            border: none;
            padding: 5px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .play-btn:hover {
            background: #007AFF;
        }

        .delete-btn:hover {
            background: #FF3B30;
        }

        /* Google Sign In Button */
        .google-signin-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
            padding: 12px 16px;
            background: #fff;
            color: #333;
            border: 1px solid #dadce0;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            margin-bottom: 20px;
            transition: all 0.2s ease;
        }

        .google-signin-btn:hover {
            background: #f8f9fa;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .google-logo {
            width: 18px;
            height: 18px;
        }

        /* Divider */
        .divider {
            display: flex;
            align-items: center;
            margin: 20px 0;
            color: #888;
            font-size: 14px;
        }

        .divider::before,
        .divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: #333;
        }

        .divider span {
            padding: 0 15px;
            background: #1a1a1a;
        }

        /* Library Sidebar */
        .library-sidebar {
            position: fixed;
            top: 0;
            right: -60vw;
            width: 60vw;
            height: 100vh;
            background: #1a1a1a;
            border-left: 1px solid #333;
            z-index: 99999;
            transition: right 0.3s ease;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .library-sidebar.open {
            right: 0;
        }

        .library-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #333;
            background: #222;
        }

        .library-header h2 {
            color: #fff;
            font-size: 18px;
            margin: 0;
        }

        .close-library-btn {
            background: none;
            border: none;
            color: #ccc;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
        }

        .close-library-btn:hover {
            color: #fff;
        }

        .library-content {
            padding: 20px;
        }

        .library-search {
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 6px;
            background: #222;
            color: #fff;
            font-size: 14px;
        }

        .search-input:focus {
            outline: none;
            border-color: #007AFF;
        }

        .library-categories {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
        }

        .category-btn {
            padding: 8px 12px;
            background: #333;
            color: #ccc;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .category-btn:hover {
            background: #444;
            color: #fff;
        }

        .category-btn.active {
            background: #007AFF;
            color: #fff;
        }

        .library-items {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* Library Setlist Container */
        .library-setlist-container {
            display: flex;
            flex: 1;
            height: calc(75vw - 200px);
            max-height: calc(100vh - 200px);
        }

        .library-column,
        .setlist-column {
            flex: 1;
            padding: 10px;
            border-right: 1px solid #333;
        }

        .setlist-column {
            border-right: none;
        }

        .library-column h4,
        .setlist-column h4 {
            color: #fff;
            margin: 0 0 15px 0;
            padding: 10px;
            background: #333;
            border-radius: 5px;
            text-align: center;
        }

        .library-items,
        .setlist-items {
            height: calc(100% - 50px);
            overflow-y: auto;
            padding: 0;
        }

        .setlist-items {
            border: 2px dashed #555;
            border-radius: 5px;
            min-height: 200px;
            padding: 10px;
        }

        .setlist-items.drag-over {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }

        .setlist-item {
            display: flex;
            align-items: center;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            margin-bottom: 6px;
            transition: all 0.2s ease;
            position: relative;
            z-index: 10000;
        }

        .setlist-item:hover {
            background: #333;
        }

        .setlist-item-info {
            flex: 1;
            display: flex;
            align-items: center;
        }

        .setlist-item-order {
            background: #007AFF;
            color: #fff;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            margin-right: 10px;
        }

        .setlist-item-name {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            margin-right: 10px;
        }

        .setlist-item-details {
            color: #888;
            font-size: 12px;
        }

        .setlist-loading-indicator {
            width: 16px;
            height: 16px;
            border: 2px solid #333;
            border-top: 2px solid #007AFF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 8px;
            display: none;
        }

        .setlist-loading-indicator.loading {
            display: block;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* MultiTrack Player Logo Animation */
        @keyframes logoPulse {
            0% {
                transform: scale(1);
                opacity: 1;
                filter: drop-shadow(0 0 20px #007AFF);
            }

            50% {
                transform: scale(1.05);
                opacity: 0.9;
                filter: drop-shadow(0 0 25px #007AFF);
            }

            100% {
                transform: scale(1);
                opacity: 1;
                filter: drop-shadow(0 0 20px #007AFF);
            }
        }

        .remove-btn {
            background: #ff4444;
            color: #fff;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease;
        }

        .remove-btn:hover {
            background: #ff6666;
        }

        /* Setlist Buttons */
        .setlist-buttons-container {
            margin-bottom: 15px;
        }

        .setlist-buttons {
            display: flex;
            flex-direction: column;
            gap: 5px;
            max-height: 120px;
            overflow-y: auto;
        }

        .setlist-btn {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            text-align: left;
            transition: all 0.2s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .setlist-btn:hover {
            background: #444;
            border-color: #666;
        }

        .setlist-btn.active {
            background: #007AFF;
            border-color: #007AFF;
        }

        .current-setlist-header {
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #444;
        }

        .current-setlist-header h5 {
            color: #fff;
            margin: 0;
            font-size: 14px;
            font-weight: bold;
        }

        .library-item {
            display: flex;
            align-items: center;
            padding: 12px;
            background: #222;
            border-radius: 6px;
            cursor: grab;
            transition: all 0.2s ease;
            user-select: none;
        }

        .library-item:hover {
            background: #333;
        }

        .library-item:active {
            cursor: grabbing;
        }

        .library-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .library-item-icon {
            width: 40px;
            height: 40px;
            background: #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-size: 18px;
        }

        .library-item-info {
            flex: 1;
        }

        .library-item-name {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 2px;
        }

        .library-item-details {
            color: #888;
            font-size: 12px;
        }

        .library-item-actions {
            display: flex;
            gap: 5px;
        }

        .library-action-btn,
        .delete-library-btn {
            background: #333;
            color: #ccc;
            border: none;
            padding: 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .delete-library-btn {
            color: #f44336;
        }

        .delete-library-btn:hover {
            background: #f44336;
            color: #fff;
        }

        .library-action-btn:hover {
            background: #444;
            color: #fff;
        }

        /* Progress Bar Styles */
        .progress-container {
            width: 100%;
            margin: 15px 0 20px 0;
            padding: 0 20px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            position: relative;
            cursor: pointer;
            overflow: hidden;
            transition: background-color 0.2s ease;
        }

        .progress-bar.playing {
            background: #444;
            cursor: not-allowed;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007AFF, #00D4FF);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s ease;
        }

        .progress-thumb {
            position: absolute;
            top: -3px;
            width: 12px;
            height: 12px;
            background: #007AFF;
            border-radius: 50%;
            left: 0%;
            transition: left 0.1s ease;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .progress-thumb:hover {
            background: #00D4FF;
            transform: scale(1.2);
        }
    </style>
</head>

<body>

    <!-- Initial Sync Modal -->
    <div id="syncModal" class="sync-modal" style="display: none;">
        <div class="sync-modal-content">
            <div class="sync-header">
                <h2> MultiTrack Player - Configuracin Inicial</h2>
                <p>Descargando tu biblioteca para uso offline</p>
            </div>

            <div class="sync-progress-container">
                <div class="sync-progress-bar">
                    <div class="sync-progress-fill" id="syncProgressFill"></div>
                </div>
                <div class="sync-progress-text">
                    <span id="syncProgressPercent">0%</span>
                    <span id="syncProgressMessage">Iniciando sincronizacin...</span>
                </div>
            </div>

            <div class="sync-stats" id="syncStats">
                <div class="sync-stat">
                    <span class="sync-stat-label">Setlists:</span>
                    <span class="sync-stat-value" id="syncSetlistCount">0</span>
                </div>
                <div class="sync-stat">
                    <span class="sync-stat-label">Canciones:</span>
                    <span class="sync-stat-value" id="syncSongCount">0</span>
                </div>
                <div class="sync-stat">
                    <span class="sync-stat-label">Archivos de audio:</span>
                    <span class="sync-stat-value" id="syncAudioCount">0</span>
                </div>
            </div>

            <div class="sync-actions" id="syncActions" style="display: none;">
                <button class="sync-btn" id="startSyncBtn" onclick="startInitialSync()">
                    Iniciar Descarga
                </button>
                <button class="sync-btn secondary" onclick="skipSync()">
                    Omitir (Requiere conexin)
                </button>
            </div>

            <div class="sync-complete" id="syncComplete" style="display: none;">
                <div class="sync-complete-icon"></div>
                <h3>Sincronizacin Completa!</h3>
                <p>Tu biblioteca est lista para usar offline</p>
                <button class="sync-btn" onclick="closeSyncModal()">
                    Comenzar
                </button>
            </div>
        </div>
    </div>

    <style>
        .sync-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .sync-modal-content {
            background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
            border: 2px solid #3DA9FC;
            border-radius: 16px;
            padding: 40px;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 0 40px rgba(61, 169, 252, 0.4);
        }

        .sync-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .sync-header h2 {
            color: #3DA9FC;
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(61, 169, 252, 0.5);
        }

        .sync-header p {
            color: #aaa;
            font-size: 14px;
        }

        .sync-progress-container {
            margin: 30px 0;
        }

        .sync-progress-bar {
            width: 100%;
            height: 30px;
            background: #0D0D0D;
            border: 2px solid #3DA9FC;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            box-shadow:
                0 0 15px rgba(61, 169, 252, 0.3),
                inset 0 0 15px rgba(61, 169, 252, 0.1);
        }

        .sync-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3DA9FC, #00D4FF);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 20px rgba(61, 169, 252, 0.8);
        }

        .sync-progress-text {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            color: #3DA9FC;
            font-size: 14px;
        }

        .sync-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px 0;
            padding: 20px;
            background: #0D0D0D;
            border: 1px solid #3DA9FC;
            border-radius: 8px;
        }

        .sync-stat {
            text-align: center;
        }

        .sync-stat-label {
            display: block;
            color: #888;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .sync-stat-value {
            display: block;
            color: #3DA9FC;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(61, 169, 252, 0.5);
        }

        .sync-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .sync-btn {
            background: linear-gradient(145deg, #3DA9FC, #2563eb);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(61, 169, 252, 0.3);
        }

        .sync-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(61, 169, 252, 0.5);
        }

        .sync-btn.secondary {
            background: linear-gradient(145deg, #444, #333);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .sync-btn.secondary:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5);
        }

        .sync-complete {
            text-align: center;
        }

        .sync-complete-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: bounceIn 0.6s ease;
        }

        .sync-complete h3 {
            color: #00FF41;
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }

        .sync-complete p {
            color: #aaa;
            margin-bottom: 30px;
        }

        @keyframes bounceIn {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            50% {
                transform: scale(1.2);
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
    </style>

    <!-- Library Sidebar -->
    <div id="librarySidebar" class="library-sidebar">
        <div class="library-header">
            <h2> Biblioteca & Setlist</h2>
            <button class="close-library-btn" onclick="toggleLibrary()"></button>
        </div>

        <div class="library-content">
            <div class="library-search">
                <input type="text" id="librarySearch" placeholder="Buscar en biblioteca..." class="search-input">
            </div>

            <div class="library-categories">
                <button class="category-btn active" data-category="all">Todos</button>
                <button class="category-btn" data-category="loops">Loops</button>
                <button class="category-btn" data-category="samples">Samples</button>
                <button class="category-btn" data-category="instruments">Instrumentos</button>
                <button class="category-btn" data-category="vocals">Vocales</button>
            </div>

            <div class="library-setlist-container">
                <div class="library-column">
                    <h4> Biblioteca</h4>
                    <div id="sidebarLibraryItems" class="library-items">
                        <!-- Library items will be loaded here -->
                    </div>
                </div>

                <div class="setlist-column">
                    <h4>Setlists</h4>
                    <div class="setlist-buttons-container">
                        <div id="sidebarSetlistButtons" class="setlist-buttons">
                            <!-- Setlist buttons will be loaded here -->
                        </div>
                    </div>
                    <div class="current-setlist-header">
                        <h5 id="currentSetlistTitle">Setlist Actual</h5>
                    </div>
                    <div id="sidebarSetlistItems" class="setlist-items">
                        <!-- Current setlist items will be loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Mixer Section -->
        <div class="mixer-section">
            <!-- Digital Console LED Screen -->
            <div class="console-led-screen" id="consoleLedScreen">
                <div class="led-screen-header">
                    <div class="led-screen-title">
                        <div class="master-volume-container">
                            <label class="master-label">MASTER</label>
                            <input type="range" class="master-volume-slider" id="masterVolumeSlider" min="0" max="100"
                                value="80" oninput="updateMasterVolume(this.value)">
                            <span class="master-volume-value" id="masterVolumeValue">80%</span>
                        </div>
                    </div>
                    <div class="led-screen-tabs">
                        <button class="led-tab active" onclick="switchLedMode('main')" data-mode="main"> MAIN</button>
                        <button class="led-tab" onclick="switchLedMode('eq')" data-mode="eq"
                            style="display: none;">EQ</button>
                        <button class="led-tab" onclick="switchLedMode('edit')" data-mode="edit">EDIT</button>
                        <button class="led-tab" onclick="switchLedMode('analyzer')"
                            data-mode="analyzer">ANALYZER</button>
                        <button class="led-tab" onclick="switchLedMode('settings')"
                            data-mode="settings">SETTINGS</button>
                        <button class="led-tab" onclick="switchLedMode('about')" data-mode="about"> ABOUT</button>
                    </div>
                    <div class="led-screen-controls">
                        <input type="file" id="audioFileInput" accept="audio/*,.zip" style="display: none;"
                            onchange="handleFileUpload(event)">
                        <button class="led-control-btn" onclick="showTrackNamesModal()"> ZIP</button>
                        <button class="led-control-btn" onclick="toggleLibrary()"></button>
                        <button class="led-control-btn" id="authButton" onclick="showAuthModal()"></button>
                    </div>
                </div>

                <div class="led-screen-content" id="ledScreenContent">
                    <!-- Main Mode -->
                    <div class="led-mode" id="mainMode">
                        <div class="main-display">
                            <div class="main-title">AUDIO CONTROL CENTER</div>

                            <!-- Progress Bar only in Main Mode -->
                            <div class="led-progress-section">
                                <div class="led-progress-container">
                                    <div class="led-progress-bar" id="progressBar"
                                        onclick="handleProgressBarClick(event)">
                                        <div class="led-progress-fill" id="progressFill"></div>
                                        <div class="led-progress-thumb" id="progressThumb"></div>
                                    </div>
                                </div>
                            </div>

                            <div class="main-controls-grid">
                                <!-- Left Side - Tempo and Key Controls -->
                                <div class="left-controls">
                                    <div class="bpm-display">
                                        <button class="bpm-btn" onclick="decreaseBPM()">-</button>
                                        <span id="bpmDisplay">128 BPM</span>
                                        <button class="bpm-btn" onclick="increaseBPM()">+</button>
                                        <button class="bpm-reset-btn" onclick="resetBPM()"
                                            title="Reset to Original"></button>
                                    </div>
                                    <div class="key-display">
                                        <button class="key-btn" onclick="decreaseKey()">-</button>
                                        <span id="keyDisplay">C</span>
                                        <button class="key-btn" onclick="increaseKey()">+</button>
                                        <button class="key-reset-btn" onclick="resetKey()"
                                            title="Reset to Original"></button>
                                    </div>
                                </div>

                                <!-- Center - Time Display -->
                                <div class="center-controls">
                                    <div class="time-info">
                                        <span id="currentTime">00:00</span> / <span id="totalTime">00:00</span>
                                    </div>
                                </div>

                                <!-- Right Side - Transport Controls -->
                                <div class="right-controls">
                                    <div class="transport-controls">
                                        <button class="transport-btn" onclick="rewind()" title="Rewind"></button>
                                        <button class="transport-btn" id="playBtn" onclick="togglePlay()"
                                            title="Play/Pause"></button>
                                        <button class="transport-btn stop-btn" id="stopBtn" onclick="stopPlayback()"
                                            title="Stop"></button>
                                        <button class="transport-btn" onclick="fastForward()"
                                            title="Fast Forward"></button>
                                        <button class="transport-btn cache-btn" onclick="showCacheManagementModal()"
                                            title="Gestionar Cache del Disco"></button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- EQ Mode -->
                    <div class="led-mode" id="eqMode" style="display: none;">
                        <div class="f6-eq-interface">
                            <!-- Top Bar -->
                            <div class="eq-top-bar">
                                <div class="eq-top-left">
                                    <button class="eq-top-btn">W</button>
                                    <button class="eq-top-btn"></button>
                                    <button class="eq-top-btn"></button>
                                    <button class="eq-top-btn">Ca</button>
                                </div>
                                <div class="eq-preset-name">A: Full Reset</div>
                                <div class="eq-top-right">
                                    <button class="eq-top-btn"></button>
                                    <button class="eq-top-btn"></button>
                                    <button class="eq-top-btn">AB</button>
                                    <button class="eq-top-btn">Load</button>
                                    <button class="eq-top-btn">Save</button>
                                    <button class="eq-top-btn">?</button>
                                </div>
                            </div>

                            <!-- Main EQ Graph Area -->
                            <div class="eq-graph-container">
                                <div class="eq-graph">
                                    <canvas id="eqCanvas" width="600" height="200"></canvas>
                                    <div class="eq-band-handles">
                                        <div class="eq-handle band-1" data-band="1" style="left: 15%; top: 60%;"></div>
                                        <div class="eq-handle band-2" data-band="2" style="left: 25%; top: 45%;"></div>
                                        <div class="eq-handle band-3" data-band="3" style="left: 40%; top: 25%;"></div>
                                        <div class="eq-handle band-4" data-band="4" style="left: 55%; top: 45%;"></div>
                                        <div class="eq-handle band-5" data-band="5" style="left: 65%; top: 45%;"></div>
                                        <div class="eq-handle band-6" data-band="6" style="left: 80%; top: 30%;"></div>
                                    </div>
                                </div>

                                <!-- Output Meter -->
                                <div class="eq-output-meter">
                                    <div class="meter-scale">
                                        <div class="meter-mark">0</div>
                                        <div class="meter-mark">-6</div>
                                        <div class="meter-mark">-12</div>
                                        <div class="meter-mark">-18</div>
                                        <div class="meter-mark">-24</div>
                                        <div class="meter-mark">-30</div>
                                        <div class="meter-mark">-36</div>
                                        <div class="meter-mark">-40</div>
                                    </div>
                                    <div class="meter-bar">
                                        <div class="meter-level" style="height: 25%;"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Bottom Control Panel -->
                            <div class="eq-control-panel">
                                <div class="eq-left-section">
                                    <div class="f6-logo">F6</div>
                                    <div class="eq-stereo-controls">
                                        <button class="stereo-btn active">ST</button>
                                        <button class="stereo-btn">M</button>
                                        <button class="stereo-btn">S</button>
                                    </div>
                                </div>

                                <div class="eq-band-selector">
                                    <div class="filter-type-icons">
                                        <div class="filter-icon lowcut active" data-band="1"></div>
                                        <div class="filter-icon bell" data-band="2"></div>
                                        <div class="filter-icon bell" data-band="3"></div>
                                        <div class="filter-icon bell" data-band="4"></div>
                                        <div class="filter-icon bell" data-band="5"></div>
                                        <div class="filter-icon shelf" data-band="6"></div>
                                    </div>
                                    <div class="band-buttons">
                                        <button class="band-btn active" data-band="1">1</button>
                                        <button class="band-btn" data-band="2">2</button>
                                        <button class="band-btn" data-band="3">3</button>
                                        <button class="band-btn" data-band="4">4</button>
                                        <button class="band-btn" data-band="5">5</button>
                                        <button class="band-btn" data-band="6">6</button>
                                    </div>
                                </div>

                                <div class="eq-global-controls">
                                    <div class="global-control">
                                        <label>MIX</label>
                                        <div class="control-value">100</div>
                                        <div class="control-buttons">
                                            <button class="control-btn">+</button>
                                            <button class="control-btn">-</button>
                                        </div>
                                    </div>
                                    <div class="global-control">
                                        <label>OUT</label>
                                        <div class="control-value">0.0</div>
                                        <div class="control-buttons">
                                            <button class="control-btn">+</button>
                                            <button class="control-btn">-</button>
                                        </div>
                                    </div>
                                </div>

                                <div class="eq-band-controls">
                                    <div class="knob-control">
                                        <label>FREQ (Hz)</label>
                                        <div class="knob" data-param="freq">
                                            <div class="knob-value">91</div>
                                            <div class="knob-range">16-21K</div>
                                        </div>
                                    </div>
                                    <div class="knob-control">
                                        <label>Q</label>
                                        <div class="knob" data-param="q">
                                            <div class="knob-value">24.0</div>
                                            <div class="knob-range">0-60</div>
                                        </div>
                                    </div>
                                    <div class="knob-control">
                                        <label>GAIN</label>
                                        <div class="knob" data-param="gain">
                                            <div class="knob-value">-11.9</div>
                                            <div class="knob-range">-18-18</div>
                                        </div>
                                    </div>
                                    <div class="knob-control">
                                        <label>RANGE</label>
                                        <div class="knob" data-param="range">
                                            <div class="knob-value">-10.7</div>
                                            <div class="knob-range">-18-18</div>
                                        </div>
                                    </div>
                                    <div class="knob-control">
                                        <label>THRESHOLD</label>
                                        <div class="knob" data-param="threshold">
                                            <div class="knob-value">-58.7</div>
                                            <div class="knob-range">-60-0</div>
                                        </div>
                                    </div>
                                    <div class="knob-control">
                                        <label>ATTACK</label>
                                        <div class="knob" data-param="attack">
                                            <div class="knob-value">16.0</div>
                                            <div class="knob-range">0.5-500</div>
                                        </div>
                                    </div>
                                    <div class="knob-control">
                                        <label>RELEASE</label>
                                        <div class="knob" data-param="release">
                                            <div class="knob-value">160</div>
                                            <div class="knob-range">5-5K</div>
                                        </div>
                                    </div>
                                </div>

                                <div class="eq-right-section">
                                    <button class="solo-btn"></button>
                                    <div class="sc-controls">
                                        <div class="sc-control">
                                            <label>SC SOURCE</label>
                                            <div class="sc-options">
                                                <button class="sc-btn active">INT</button>
                                                <button class="sc-btn">EXT</button>
                                            </div>
                                        </div>
                                        <div class="sc-control">
                                            <label>SC MODE</label>
                                            <div class="sc-options">
                                                <button class="sc-btn active">SPLIT</button>
                                                <button class="sc-btn">WIDE</button>
                                            </div>
                                        </div>
                                        <div class="sc-control">
                                            <label>RELEASE</label>
                                            <div class="sc-options">
                                                <button class="sc-btn active">ARC</button>
                                                <button class="sc-btn">MNL</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Edit Mode -->
                    <div class="led-mode" id="editMode" style="display: none;">
                        <div class="edit-display">
                            <div class="edit-title">TRACK EDITOR</div>
                            <div class="edit-controls">
                                <div class="edit-section">
                                    <label>Track Name:</label>
                                    <input type="text" id="trackNameInput" class="led-input"
                                        placeholder="Enter track name">
                                </div>
                                <div class="edit-section">
                                    <label>Track Color:</label>
                                    <div class="color-picker" id="colorPicker">
                                        <div class="color-option" data-color="#00FF41" style="background: #00FF41;">
                                        </div>
                                        <div class="color-option" data-color="#FF0040" style="background: #FF0040;">
                                        </div>
                                        <div class="color-option" data-color="#FFD700" style="background: #FFD700;">
                                        </div>
                                        <div class="color-option" data-color="#3DA9FC" style="background: #3DA9FC;">
                                        </div>
                                        <div class="color-option" data-color="#FF8000" style="background: #FF8000;">
                                        </div>
                                        <div class="color-option" data-color="#8000FF" style="background: #8000FF;">
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="function-grid">
                                <button class="function-btn" onclick="showTrackSelection()">SELECT TRACK</button>
                                <button class="function-btn" onclick="applyTrackChanges()">APPLY CHANGES</button>
                            </div>
                        </div>
                    </div>

                    <!-- Analyzer Mode -->
                    <div class="led-mode" id="analyzerMode" style="display: none;">
                        <div class="analyzer-display">
                            <div class="analyzer-title">REAL-TIME ANALYZER</div>
                            <div class="analyzer-graph" id="analyzerGraph">
                                <canvas id="analyzerCanvas" width="600" height="120"></canvas>
                            </div>
                            <div class="function-grid">
                                <button class="function-btn" onclick="startAnalyzer()">START</button>
                                <button class="function-btn" onclick="stopAnalyzer()">STOP</button>
                                <button class="function-btn" onclick="freezeAnalyzer()">FREEZE</button>
                                <button class="function-btn" onclick="resetAnalyzer()">RESET</button>
                            </div>
                        </div>
                    </div>

                    <!-- Settings Mode -->
                    <div class="led-mode" id="settingsMode" style="display: none;">
                        <div class="settings-display">
                            <div class="settings-title">CONSOLE SETTINGS</div>
                            <div class="settings-grid">
                                <div class="setting-item">
                                    <label>Master Volume:</label>
                                    <input type="range" id="masterVolumeSlider" min="0" max="100" value="80"
                                        oninput="updateMasterVolume(this.value)">
                                    <span id="masterVolumeValue">80%</span>
                                </div>
                                <div class="setting-item">
                                    <label>VU Sensitivity:</label>
                                    <input type="range" id="vuSensitivitySlider" min="1" max="10" value="5"
                                        oninput="updateVUSensitivity(this.value)">
                                    <span id="vuSensitivityValue">5</span>
                                </div>
                            </div>
                            <div class="function-grid">
                                <button class="function-btn" onclick="saveSettings()">SAVE</button>
                                <button class="function-btn" onclick="loadSettings()">LOAD</button>
                                <button class="function-btn" onclick="resetSettings()">RESET</button>
                                <button class="function-btn" onclick="exportSettings()">EXPORT</button>
                            </div>
                        </div>
                    </div>

                    <!-- About Mode -->
                    <div class="led-mode" id="aboutMode" style="display: none;">
                        <div class="about-display">
                            <div class="about-content">
                                <img src="./assets/logo.png" alt="Judith Logo" class="about-logo">
                                <div class="about-text">
                                    <div class="about-company">Freedom Labs</div>
                                    <div class="about-version">Judith Version 1.0</div>
                                    <div class="about-copyright">Todos los derechos reservados 2025</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Track Selection Panel -->
            <div class="track-selection-panel" id="trackSelectionPanel" style="display: none;">
                <div class="track-selection-header">
                    <h3>Seleccionar Track para Editar</h3>
                    <button class="close-selection-btn" onclick="closeTrackSelection()"></button>
                </div>
                <div class="track-selection-grid" id="trackSelectionGrid">
                    <!-- Track selection buttons will be generated here -->
                </div>
            </div>

            <div class="tracks-grid" id="tracksGrid">
                <!-- Tracks will be generated here -->
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <!-- Panel Tabs -->
            <div class="panel-tabs">
                <button class="tab-btn active" onclick="switchTab('library')" style="display: none;">
                    Biblioteca</button>
                <button class="tab-btn" onclick="switchTab('setlist')" style="display: none;"> Setlist</button>
            </div>

            <!-- Library Tab Content -->
            <div id="libraryTab" class="tab-content" style="display: none;">
                <div class="library-section">
                    <div class="library-header">
                        <div class="library-title"> Mi Biblioteca</div>
                        <button class="edit-btn" onclick="loadLibrarySongs()" title="Recargar biblioteca"></button>
                        <button class="edit-btn" onclick="testLibraryLoad()" title="Test biblioteca"
                            style="margin-left: 5px;"></button>
                        <button class="edit-btn" onclick="showDeleteMultipleModal()"
                            title="Eliminar mltiples canciones"
                            style="margin-left: 5px; background: #ff4444;"></button>
                    </div>

                    <div id="libraryItems" class="library-items">
                        <!-- Library items will be loaded here -->
                    </div>
                </div>
            </div>

            <!-- Setlist Tab Content -->
            <div id="setlistTab" class="tab-content active">
                <div class="canciones-container">
                    <div class="setlist-button-container">
                        <div class="setlist-led-display" id="setlistLedDisplay">
                            <div class="led-marquee" id="ledMarquee">
                                <span class="marquee-content" id="marqueeContent">Sin Setlist - Sin Cancin</span>
                            </div>
                        </div>
                        <button class="setlist-main-btn" onclick="toggleSetlistSidebar()">Setlist</button>
                    </div>
                    <div class="canciones-list" id="cancionesList">
                        <!-- Canciones will be generated here -->
                    </div>
                </div>

                <!-- PADS Section -->
                <div class="pads-container">
                    <div class="pads-header">
                        <div class="pads-title-led">
                            <div class="pads-led-display">
                                <div class="pads-led-text">PADS</div>
                            </div>
                        </div>
                        <div class="octave-selector">
                            <button class="octave-btn" onclick="decreaseOctave()">-</button>
                            <span class="octave-display" id="octaveDisplay">4</span>
                            <button class="octave-btn" onclick="increaseOctave()">+</button>
                        </div>
                    </div>
                    <div class="pads-grid">
                        <button class="pad-button" onclick="triggerPadWithOctave('C')">C</button>
                        <button class="pad-button" onclick="triggerPadWithOctave('C#')">C#</button>
                        <button class="pad-button" onclick="triggerPadWithOctave('D')">D</button>
                        <button class="pad-button" onclick="triggerPadWithOctave('D#')">D#</button>
                        <button class="pad-button" onclick="triggerPadWithOctave('E')">E</button>
                        <button class="pad-button" onclick="triggerPadWithOctave('F')">F</button>
                        <button class="pad-button" onclick="triggerPadWithOctave('F#')">F#</button>
                        <button class="pad-button" onclick="triggerPadWithOctave('G')">G</button>
                        <button class="pad-button" onclick="triggerPadWithOctave('G#')">G#</button>
                        <button class="pad-button" onclick="triggerPadWithOctave('A')">A</button>
                        <button class="pad-button" onclick="triggerPadWithOctave('Bb')">Bb</button>
                        <button class="pad-button" onclick="triggerPadWithOctave('B')">B</button>
                    </div>

                </div>
            </div>

            <!-- Sampler LED Display -->
            <div class="sampler-led-container">
                <div class="sampler-led-display" id="samplerLedDisplay">
                    <div class="sampler-led-text" id="samplerInfo">SAMPLER READY</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Setlist Sidebar -->
    <div id="setlistSidebar" class="setlist-sidebar">
        <div class="setlist-sidebar-header">
            <h3> Mis Setlists</h3>
            <div class="setlist-sidebar-actions">
                <button class="led-tab" onclick="createNewSetlist()" title="Crear nuevo setlist"> NUEVO</button>
                <button class="close-setlist-btn" onclick="toggleSetlistSidebar()"></button>
            </div>
        </div>

        <div class="setlist-sidebar-content">
            <div class="setlist-sidebar-list" id="setlistSidebarList">
                <!-- Setlists will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Track Names Modal -->
    <div id="trackNamesModal"
        style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.8); align-items: center; justify-content: center; z-index: 10000;">
        <div
            style="background-color: #1a1a1a; border-radius: 10px; padding: 30px; width: 700px; max-width: 90vw; max-height: 90vh; border: 1px solid #333; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="color: #fff; font-size: 24px; font-weight: bold; margin: 0;"> Subir Cancin</h2>
                <button onclick="hideTrackNamesModal()"
                    style="background: none; border: none; color: #ccc; font-size: 24px; cursor: pointer; padding: 5px;"></button>
            </div>

            <!-- Song Metadata Form -->
            <div
                style="margin-bottom: 25px; padding: 20px; background: #222; border-radius: 8px; border: 1px solid #333;">
                <h3 style="color: #fff; font-size: 18px; margin: 0 0 15px 0;"> Informacin de la Cancin</h3>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div>
                        <label
                            style="color: #ccc; font-size: 14px; font-weight: bold; margin-bottom: 8px; display: block;">Nombre
                            de la Cancin *</label>
                        <input type="text" id="songName" placeholder="Ej: Mi Cancin"
                            style="width: 100%; padding: 12px; border-radius: 6px; border: 1px solid #333; background-color: #333; color: #fff; font-size: 14px;">
                    </div>
                    <div>
                        <label
                            style="color: #ccc; font-size: 14px; font-weight: bold; margin-bottom: 8px; display: block;">
                            Artista</label>
                        <input type="text" id="songArtist" placeholder="Ej: Mi Banda"
                            style="width: 100%; padding: 12px; border-radius: 6px; border: 1px solid #333; background-color: #333; color: #fff; font-size: 14px;">
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                    <div>
                        <label
                            style="color: #ccc; font-size: 14px; font-weight: bold; margin-bottom: 8px; display: block;">
                            Tempo (BPM)</label>
                        <input type="number" id="songTempo" placeholder="120" min="60" max="200"
                            style="width: 100%; padding: 12px; border-radius: 6px; border: 1px solid #333; background-color: #333; color: #fff; font-size: 14px;">
                    </div>
                    <div>
                        <label
                            style="color: #ccc; font-size: 14px; font-weight: bold; margin-bottom: 8px; display: block;">
                            Nota</label>
                        <select id="songKey"
                            style="width: 100%; padding: 12px; border-radius: 6px; border: 1px solid #333; background-color: #333; color: #fff; font-size: 14px;">
                            <option value="">Seleccionar...</option>
                            <option value="C">C</option>
                            <option value="C#">C#</option>
                            <option value="D">D</option>
                            <option value="D#">D#</option>
                            <option value="E">E</option>
                            <option value="F">F</option>
                            <option value="F#">F#</option>
                            <option value="G">G</option>
                            <option value="G#">G#</option>
                            <option value="A">A</option>
                            <option value="A#">A#</option>
                            <option value="B">B</option>
                        </select>
                    </div>
                    <div>
                        <label
                            style="color: #ccc; font-size: 14px; font-weight: bold; margin-bottom: 8px; display: block;">Comps</label>
                        <select id="songTimeSignature"
                            style="width: 100%; padding: 12px; border-radius: 6px; border: 1px solid #333; background-color: #333; color: #fff; font-size: 14px;">
                            <option value="">Seleccionar...</option>
                            <option value="4/4">4/4</option>
                            <option value="3/4">3/4</option>
                            <option value="2/4">2/4</option>
                            <option value="6/8">6/8</option>
                            <option value="12/8">12/8</option>
                            <option value="7/8">7/8</option>
                            <option value="5/4">5/4</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- File Upload Section -->
            <div
                style="margin-bottom: 25px; padding: 20px; background: #222; border-radius: 8px; border: 1px solid #333;">
                <h3 style="color: #fff; font-size: 18px; margin: 0 0 15px 0;"> Archivo ZIP</h3>
                <div
                    style="border: 2px dashed #555; border-radius: 8px; padding: 30px; text-align: center; background: #1a1a1a;">
                    <div style="color: #888; font-size: 16px; margin-bottom: 10px;"> Arrastra tu archivo ZIP aqu o
                        haz clic para seleccionar</div>
                    <input type="file" id="zipFileInput" accept=".zip" style="display: none;"
                        onchange="handleZipFileSelect(event)">
                    <button onclick="document.getElementById('zipFileInput').click()"
                        style="padding: 12px 24px; background-color: #007AFF; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer; margin-top: 10px;">Seleccionar
                        ZIP</button>
                    <div id="selectedFileInfo"
                        style="margin-top: 15px; color: #4CAF50; font-size: 14px; display: none;"></div>
                </div>
            </div>

            <!-- Track Names Section (shown after ZIP is selected) -->
            <div id="trackNamesSection" style="margin-bottom: 25px; display: none;">
                <h3 style="color: #fff; font-size: 18px; margin: 0 0 15px 0;">Tracks Encontrados</h3>
                <div id="trackNamesList"
                    style="display: flex; flex-direction: column; gap: 10px; max-height: 300px; overflow-y: auto; padding: 15px; background: #222; border-radius: 8px; border: 1px solid #333;">
                    <!-- Track names will be populated here -->
                </div>
            </div>

            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="hideTrackNamesModal()"
                    style="padding: 12px 24px; background-color: #666; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;">Cancelar</button>
                <button id="saveSongBtn" onclick="saveSongWithTracks()"
                    style="padding: 12px 24px; background-color: #007AFF; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer; display: none;">
                    Guardar Cancin</button>
            </div>
        </div>
    </div>


    <!-- Auth Modal -->
    <div id="authModal"
        style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.9); z-index: 10000;">
        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #1a1a1a; border-radius: 12px; padding: 40px; width: 450px; max-width: 90vw; border: 1px solid #444; box-shadow: 0 20px 60px rgba(0,0,0,0.8);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 id="authTitle" style="color: #fff; font-size: 24px; font-weight: bold; margin: 0;">Iniciar Sesin
                </h2>
                <button onclick="hideAuthModal()"
                    style="background: none; border: none; color: #ccc; font-size: 24px; cursor: pointer; padding: 5px;"></button>
            </div>

            <!-- Google Sign In Button (HIDDEN for desktop app) -->
            <button id="googleSignInBtn" onclick="handleGoogleSignIn()" class="google-signin-btn"
                style="display: none;">
                <img src="https://developers.google.com/identity/images/g-logo.png" alt="Google" class="google-logo">
                Continuar con Google
            </button>

            <div class="divider" style="display: none;">
                <span>o</span>
            </div>

            <form id="authForm" onsubmit="handleAuthSubmit(event)"
                style="display: flex; flex-direction: column; gap: 15px;">
                <div id="displayNameGroup" style="display: none; flex-direction: column; gap: 5px;">
                    <label style="color: #ccc; font-size: 14px; font-weight: bold;">Nombre de Usuario</label>
                    <input type="text" id="displayName" placeholder="Tu nombre de usuario"
                        style="padding: 12px; border-radius: 6px; border: 1px solid #333; background-color: #222; color: #fff; font-size: 16px;">
                </div>

                <div style="display: flex; flex-direction: column; gap: 5px;">
                    <label style="color: #ccc; font-size: 14px; font-weight: bold;">Email</label>
                    <input type="email" id="email" placeholder="tu@email.com" required
                        style="padding: 12px; border-radius: 6px; border: 1px solid #333; background-color: #222; color: #fff; font-size: 16px;">
                </div>

                <div style="display: flex; flex-direction: column; gap: 5px;">
                    <label style="color: #ccc; font-size: 14px; font-weight: bold;">Contrasea</label>
                    <input type="password" id="password" placeholder="Tu contrasea" required minlength="6"
                        style="padding: 12px; border-radius: 6px; border: 1px solid #333; background-color: #222; color: #fff; font-size: 16px;">
                </div>

                <div id="authError"
                    style="color: #ff4444; font-size: 14px; text-align: center; padding: 10px; background-color: rgba(255, 68, 68, 0.1); border-radius: 6px; display: none;">
                </div>

                <button type="submit" id="authSubmit"
                    style="padding: 15px; background-color: #007AFF; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer; margin-top: 10px;">Iniciar
                    Sesin</button>
            </form>

            <div style="margin-top: 20px; text-align: center;">
                <p style="color: #666; font-size: 13px; margin: 0;">
                    No tienes cuenta? Regstrate en <a href="https://mixcurse-production.up.railway.app"
                        target="_blank" style="color: #007AFF; text-decoration: none;">la pgina web</a>
                </p>
            </div>
        </div>
    </div>

    <!-- Create Setlist Modal -->
    <div id="createSetlistModal"
        style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.85); align-items: center; justify-content: center; z-index: 10000;">
        <div
            style="background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%); border-radius: 16px; padding: 40px; width: 500px; max-width: 90vw; border: 2px solid #007AFF; box-shadow: 0 20px 60px rgba(0, 122, 255, 0.3); animation: modalSlideIn 0.3s ease-out;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                <div>
                    <h2 style="color: #fff; font-size: 28px; font-weight: bold; margin: 0;">
                        Nuevo Setlist
                    </h2>
                    <p style="color: #888; font-size: 14px; margin: 5px 0 0 0;">Crea un nuevo setlist para organizar tus
                        canciones</p>
                </div>
                <button onclick="hideCreateSetlistModal()"
                    style="background: rgba(255, 255, 255, 0.1); border: none; color: #ccc; font-size: 28px; cursor: pointer; padding: 5px 12px; border-radius: 8px; transition: all 0.2s;"
                    onmouseover="this.style.background='rgba(255,255,255,0.2)'; this.style.color='#fff';"
                    onmouseout="this.style.background='rgba(255,255,255,0.1)'; this.style.color='#ccc';"></button>
            </div>

            <form id="createSetlistForm" onsubmit="handleCreateSetlistSubmit(event)"
                style="display: flex; flex-direction: column; gap: 20px;">
                <div style="display: flex; flex-direction: column; gap: 8px;">
                    <label style="color: #fff; font-size: 16px; font-weight: 600;">
                        Nombre del Setlist *
                    </label>
                    <input type="text" id="setlistNameInput" placeholder="Ej: Concierto de Verano 2024" required
                        style="padding: 14px; border-radius: 10px; border: 2px solid #333; background-color: #222; color: #fff; font-size: 16px; transition: all 0.2s; outline: none;"
                        onfocus="this.style.borderColor='#007AFF'; this.style.boxShadow='0 0 0 3px rgba(0, 122, 255, 0.1)';"
                        onblur="this.style.borderColor='#333'; this.style.boxShadow='none';">
                </div>

                <div style="display: flex; flex-direction: column; gap: 8px;">
                    <label style="color: #fff; font-size: 16px; font-weight: 600;">
                        Fecha del Evento *
                    </label>
                    <input type="date" id="setlistDateInput" required
                        style="padding: 14px; border-radius: 10px; border: 2px solid #333; background-color: #222; color: #fff; font-size: 16px; transition: all 0.2s; outline: none;"
                        onfocus="this.style.borderColor='#007AFF'; this.style.boxShadow='0 0 0 3px rgba(0, 122, 255, 0.1)';"
                        onblur="this.style.borderColor='#333'; this.style.boxShadow='none';">
                </div>

                <div id="setlistError"
                    style="color: #ff4444; font-size: 14px; text-align: center; padding: 12px; background-color: rgba(255, 68, 68, 0.1); border-radius: 8px; border: 1px solid rgba(255, 68, 68, 0.3); display: none;">
                </div>

                <div style="display: flex; gap: 12px; margin-top: 10px;">
                    <button type="button" onclick="hideCreateSetlistModal()"
                        style="flex: 1; padding: 14px; background-color: #333; color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s;"
                        onmouseover="this.style.background='#444';" onmouseout="this.style.background='#333';">
                        Cancelar
                    </button>
                    <button type="submit"
                        style="flex: 1; padding: 14px; background: linear-gradient(135deg, #007AFF 0%, #0051D5 100%); color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 15px rgba(0, 122, 255, 0.4);"
                        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0, 122, 255, 0.5)';"
                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(0, 122, 255, 0.4)';">
                        Crear Setlist
                    </button>
                </div>
            </form>
        </div>
    </div>

    <style>
        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(-20px);
            }

            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }
    </style>

    <!-- Audio Context Prompt -->
    <div id="audioContextPrompt"
        style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.9); display: flex; align-items: center; justify-content: center; z-index: 10001;">
        <div
            style="background-color: #1a1a1a; border-radius: 15px; padding: 40px; width: 500px; max-width: 90vw; border: 2px solid #007AFF; text-align: center;">
            <div style="font-size: 48px; margin-bottom: 20px;"></div>
            <h2 style="color: #fff; font-size: 24px; font-weight: bold; margin: 0 0 15px 0;">Iniciar Audio</h2>
            <p style="color: #ccc; font-size: 16px; margin: 0 0 30px 0; line-height: 1.5;">
                Para reproducir audio, necesitas hacer clic en el botn de abajo.<br>
                Esto es requerido por los navegadores modernos por seguridad.
            </p>
            <button onclick="resumeAudioContext()"
                style="padding: 15px 30px; background: linear-gradient(135deg, #007AFF, #0056CC); color: white; border: none; border-radius: 10px; font-size: 18px; font-weight: bold; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(0, 122, 255, 0.3);">
                 Iniciar Audio
            </button>
            <p style="color: #888; font-size: 12px; margin: 20px 0 0 0;">
                Solo necesitas hacer esto una vez por sesin
            </p>
        </div>
    </div>

    <!-- Loading Modal -->
    <div id="loadingModal"
        style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 10000;">
        <div
            style="background-color: #1a1a1a; border-radius: 10px; padding: 30px; width: 400px; max-width: 90vw; border: 1px solid #333; text-align: center;">
            <div style="margin-bottom: 20px;">
                <div
                    style="width: 50px; height: 50px; border: 4px solid #333; border-top: 4px solid #007AFF; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;">
                </div>
                <div id="loadingText" style="color: #fff; font-size: 18px; font-weight: bold; margin-bottom: 15px;">
                    Cargando...</div>
            </div>

            <div id="progressContainer" style="display: none;">
                <div style="background: #333; height: 8px; border-radius: 4px; overflow: hidden; margin-bottom: 10px;">
                    <div id="progressBar"
                        style="background: linear-gradient(90deg, #007AFF, #00D4FF); height: 100%; width: 0%; transition: width 0.3s ease;">
                    </div>
                </div>
                <div id="progressText" style="color: #007AFF; font-size: 14px; font-weight: bold;">0%</div>
                <div id="progressDetails" style="color: #888; font-size: 12px; margin-top: 5px;">0 / 0</div>
            </div>
        </div>
    </div>

    <style>
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>

    <!-- Cache System -->
    <script src="../cache-system.js"></script>

    <!-- Firebase SDK -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, GoogleAuthProvider, signInWithPopup } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFirestore, collection, addDoc, getDocs, doc, setDoc, getDoc, deleteDoc, updateDoc, query, where } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { getStorage, ref, uploadBytes, getDownloadURL } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyB3GHmCQB-yvJr3iJ82CxAEgUU_N8QjgBU",
            authDomain: "freedommix-c5c3e.firebaseapp.com",
            projectId: "freedommix-c5c3e",
            storageBucket: "freedommix-c5c3e.firebasestorage.app",
            messagingSenderId: "830247648726",
            appId: "1:830247648726:web:fab37de48098e10184f877"
        };

        // Configurar Firebase para desarrollo local
        if (window.location.protocol === 'file:' || window.location.hostname === 'localhost') {
            console.log(' Configurando Firebase para desarrollo local...');
        }

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);

        // Make Firebase available globally
        window.firebase = { auth, db, storage, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, collection, addDoc, getDocs, doc, setDoc, getDoc, deleteDoc, updateDoc, query, where, ref, uploadBytes, getDownloadURL };
    </script>

    <script>
        console.log(' MAIN SCRIPT STARTED - Main JavaScript is running...');
        let tracks = [];
        let isPlaying = false;
        let currentBPM = 128;
        let originalBPM = 128; // BPM original de la cancin
        let tempoMultiplier = 1.0; // Multiplicador de tempo (1.0 = tempo original)
        let currentKey = 'C';
        let originalKey = 'C'; // Key original de la cancin
        let keyOffset = 0; // Offset en semitonos (0 = tono original)
        let currentTime = 0;
        let totalTime = 0; // Will be set when audio loads
        let timeUpdateInterval = null;
        let audioStartTime = 0;
        let pausedTime = 0;
        let isLooping = false;
        let masterVolume = 0.8; // Master volume (0.0 to 1.0)
        let currentUser = null;
        let lastUsedSetlist = null; // Store last used setlist
        let currentSetlist = null; // Current active setlist
        let audioContext = null;
        let audioBuffers = new Map(); // Store loaded audio buffers
        let audioSources = new Map(); // Store active audio sources
        let gainNodes = new Map(); // Store gain nodes for volume control
        let analysers = new Map(); // Store analyser nodes for VU meters
        let toneInitialized = false; // Track Tone.js initialization
        let vuMeterInterval = null; // Interval for updating VU meters

        // EQ System
        let eqNodes = new Map(); // Store EQ filter nodes for each track
        let masterEQNodes = []; // Master EQ nodes (6 bands)
        let eqEnabled = false; // EQ on/off state
        let eqBands = [
            { freq: 60, type: 'lowshelf', gain: 0, q: 0.7, minFreq: 20, maxFreq: 200 },      // Low Shelf
            { freq: 200, type: 'peaking', gain: 0, q: 1.4, minFreq: 50, maxFreq: 500 },      // Low-Mid
            { freq: 800, type: 'peaking', gain: 0, q: 1.4, minFreq: 200, maxFreq: 2000 },    // Mid
            { freq: 2500, type: 'peaking', gain: 0, q: 1.4, minFreq: 800, maxFreq: 8000 },   // High-Mid
            { freq: 8000, type: 'peaking', gain: 0, q: 1.4, minFreq: 2000, maxFreq: 16000 }, // High
            { freq: 12000, type: 'highshelf', gain: 0, q: 0.7, minFreq: 4000, maxFreq: 20000 } // High Shelf
        ];

        // Song cache system
        let songCache = new Map(); // Cache loaded songs: songId -> {tracks, audioBuffers, metadata}
        let currentLoadedSongId = null; // Track currently loaded song
        let currentSelectedSongId = null; // Track currently selected song in list
        let isLoadingSong = false; // Prevent multiple simultaneous loads

        // Smart loading system
        let songLoadingStates = new Map(); // songId -> 'pending', 'loading', 'loaded', 'error'
        let loadingQueue = []; // Queue of songs to load automatically
        let isAutoLoading = false; // Flag to prevent user clicks from interrupting auto-loading

        // Offline caching system (like Prime/Loop Community)
        let offlineCache = new Map(); // songId -> {localPath, downloadedAt, fileSize, version}
        let cacheIndex = []; // Local index of downloaded songs
        const CACHE_STORAGE_KEY = 'multitrack_cache_index';
        const CACHE_PREFIX = 'cached_';

        // Advanced IndexedDB Cache System
        let cacheSystem = null; // Will be initialized in init()

        // Progressive loading system
        let progressiveLoadingQueue = []; // Queue of songs to load progressively
        let isProgressiveLoading = false; // Flag to control progressive loading
        let currentLoadingSongIndex = 0; // Current song being loaded

        console.log(' SCRIPT LOADED - JavaScript is running...');

        // Initialize the application
        // LED startup sequence removed - show normal controls immediately

        // Ensure LED screen content is always visible
        function ensureLEDScreenVisible() {
            const ledScreenContent = document.getElementById('ledScreenContent');
            if (ledScreenContent) {
                ledScreenContent.style.display = 'block';
                ledScreenContent.style.visibility = 'visible';
            }
        }

        function init() {
            console.log(' INIT STARTED - Initializing MultiTrack Player...');

            // Ensure LED screen is visible immediately
            ensureLEDScreenVisible();

            // Try to restore user session from localStorage
            try {
                const savedUser = localStorage.getItem('lastUser');
                if (savedUser) {
                    const userData = JSON.parse(savedUser);
                    console.log(' Restoring user session:', userData.email);
                    // Set currentUser for immediate use
                    currentUser = userData;
                    // Update auth button
                    const authButton = document.getElementById('authButton');
                    if (authButton) {
                        authButton.textContent = ' ' + (userData.displayName || userData.email);
                    }
                }
            } catch (error) {
                console.log('No saved user session found');
            }

            // Check if JSZip is loaded
            if (typeof JSZip === 'undefined') {
                console.warn('JSZip not loaded. ZIP file upload will not work.');
            }

            // Ensure loading modal is hidden on startup
            hideLoading();

            // Clear any pending upload state
            currentExtractedFiles = [];
            currentSongName = '';
            hideTrackNamesModal();

            // Initialize audio context
            initAudioContext();

            // Initialize Cache System
            initCacheSystem();

            // Initialize PADS audio context (separate from main audio)
            initPadsAudioContext();

            generateTracks();
            generateSongs();
            generatePads();
            startTimeUpdate();
            initAuth();
            initLibrary();

            // Load library songs (auto-load is now handled in onAuthStateChanged)
            setTimeout(() => {
                if (currentUser) {
                    loadLibrarySongs();
                    loadLibrarySongsForSidebar();
                }
            }, 2000);

            // Add keyboard shortcut for debug buttons (Ctrl+Shift+D)
            document.addEventListener('keydown', function (e) {
                if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                    e.preventDefault();
                    toggleDebugButtons();
                }
            });
        }

        // Initialize Cache System
        async function initCacheSystem() {
            try {
                console.log(' ========================================');
                console.log(' INITIALIZING CACHE SYSTEM');
                console.log(' ========================================');

                // Check if MultiTrackCacheSystem is available
                if (typeof MultiTrackCacheSystem === 'undefined') {
                    console.error(' MultiTrackCacheSystem not loaded!');
                    console.error(' Make sure cache-system.js is included');
                    return;
                }

                // Create cache system instance
                cacheSystem = new MultiTrackCacheSystem();

                // Initialize IndexedDB
                await cacheSystem.init();

                // Get cache statistics
                const stats = await cacheSystem.getCacheStats();
                console.log(' Cache Statistics:');
                console.log(`   - Audio Files: ${stats.audioFiles}`);
                console.log(`   - Songs: ${stats.songs}`);
                console.log(`   - Setlists: ${stats.setlists}`);
                console.log(`   - Total Size: ${(stats.totalSize / 1024 / 1024).toFixed(2)} MB`);

                console.log(' Cache System initialized successfully');
                console.log(' ========================================');
            } catch (error) {
                console.error(' Error initializing cache system:', error);
                console.error(' App will continue without offline cache');
            }
        }

        // Auto-load last used setlist and first song (with IndexedDB cache)
        async function autoLoadLastSetlist() {
            try {
                console.log(' ========================================');
                console.log(' AUTO-LOAD LAST SETLIST STARTED');
                console.log(' ========================================');

                // Wait for cache system to be ready
                if (!cacheSystem) {
                    console.log(' Cache system not initialized yet, waiting...');
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }

                if (!cacheSystem) {
                    console.log(' Cache system still not available');
                    return;
                }

                // Get last used setlist ID from IndexedDB
                const lastSetlistId = await cacheSystem.getAppState('lastSetlist');
                console.log(' Last setlist ID from cache:', lastSetlistId);

                if (!lastSetlistId) {
                    console.log(' No last setlist found in cache');
                    console.log(' TIP: Load a setlist manually first, and it will auto-load next time');
                    console.log(' ========================================');
                    return;
                }

                // Get setlist data from IndexedDB
                const setlist = await cacheSystem.getSetlist(lastSetlistId);
                console.log(' Setlist data found:', setlist ? 'YES' : 'NO');

                if (!setlist) {
                    console.log(' Setlist data not found in cache');
                    console.log(' ========================================');
                    return;
                }

                console.log(' Setlist loaded from cache:', setlist.name);
                console.log(' Songs in setlist:', setlist.songs?.length || 0);

                // Load first song if available
                if (setlist.songs && setlist.songs.length > 0) {
                    const firstSong = setlist.songs[0];
                    console.log(' First song:', firstSong.name || firstSong.id);
                    console.log(' Tracks in song:', firstSong.tracks?.length || 0);

                    // Load the song after a short delay
                    setTimeout(() => {
                        console.log(' Loading first song now...');
                        loadSongFromSetlist(firstSong);
                    }, 1500);
                } else {
                    console.log(' No songs in setlist');
                }

                console.log(' ========================================');
            } catch (error) {
                console.error(' Error in autoLoadLastSetlist:', error);
                console.error(' Error stack:', error.stack);
            }
        }


        // Load a song from setlist data (with cache support)
        async function loadSongFromSetlist(songData) {
            try {
                console.log(' ========================================');
                console.log(' LOADING SONG FROM SETLIST');
                console.log(' ========================================');
                console.log(' Song:', songData.name || songData.id);

                // Check if song is in cache first
                if (cacheSystem) {
                    const cachedSong = await cacheSystem.getSong(songData.id);
                    if (cachedSong) {
                        console.log(' Song found in cache!');
                        songData = cachedSong; // Use cached data
                    }
                }

                // Create tracks from song data
                if (songData.tracks && Array.isArray(songData.tracks)) {
                    tracks = songData.tracks.map((track, index) => ({
                        id: track.id || `track_${index + 1}`,
                        name: track.name || `Track ${index + 1}`,
                        audioUrl: track.downloadUrl || track.audioUrl,
                        downloadUrl: track.downloadUrl || track.audioUrl,
                        volume: track.volume || 0.8,
                        muted: false,
                        solo: false,
                        color: track.color || '#3DA9FC',
                        playing: false
                    }));

                    console.log(' Created', tracks.length, 'tracks');

                    // Save song to cache if not already cached
                    if (cacheSystem) {
                        await cacheSystem.saveSong(songData.id, songData);
                        console.log(' Song saved to cache');
                    }

                    // Update UI
                    updateTracksGrid();

                    // Update current song display
                    if (songData.name) {
                        updateCurrentSongLedDisplay(songData.name);
                    }

                    // Set current loaded song ID
                    currentLoadedSongId = songData.id;

                    // Load audio buffers (from cache or download)
                    console.log(' Loading audio buffers...');
                    await loadAudioBuffersWithCache(tracks, songData.id);

                    console.log(' Song loaded successfully');
                    console.log(' ========================================');
                } else {
                    console.error(' Invalid song data - no tracks found');
                }
            } catch (error) {
                console.error(' Error loading song from setlist:', error);
                console.error(' Error stack:', error.stack);
            }
        }

        // Load audio buffers with cache support
        async function loadAudioBuffersWithCache(tracksToLoad, songId) {
            try {
                console.log(' Loading audio buffers with cache...');
                let loadedFromCache = 0;
                let downloadedFromB2 = 0;

                for (const track of tracksToLoad) {
                    try {
                        // Try to load from cache first
                        let audioBuffer = null;

                        if (cacheSystem && audioContext) {
                            audioBuffer = await cacheSystem.getAudioFile(track.id, audioContext);
                        }

                        if (audioBuffer) {
                            // Loaded from cache
                            audioBuffers.set(track.id, audioBuffer);
                            loadedFromCache++;
                            console.log(` [${loadedFromCache + downloadedFromB2}/${tracksToLoad.length}] Loaded from cache: ${track.name}`);
                        } else {
                            // Download from B2
                            console.log(` [${loadedFromCache + downloadedFromB2 + 1}/${tracksToLoad.length}] Downloading: ${track.name}`);

                            const proxyUrl = `http://localhost:3001/download?url=${encodeURIComponent(track.downloadUrl)}`;
                            const response = await fetch(proxyUrl);

                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }

                            const arrayBuffer = await response.arrayBuffer();
                            audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                            // Store in memory
                            audioBuffers.set(track.id, audioBuffer);
                            downloadedFromB2++;

                            // Save to cache for next time
                            if (cacheSystem) {
                                await cacheSystem.saveAudioFile(track.id, songId, track.downloadUrl, audioBuffer);
                                console.log(` Saved to cache: ${track.name}`);
                            }
                        }
                    } catch (error) {
                        console.error(` Error loading track ${track.name}:`, error);
                    }
                }

                console.log(' Audio buffers loaded:');
                console.log(`    From cache: ${loadedFromCache}`);
                console.log(`    Downloaded: ${downloadedFromB2}`);
                console.log(`    Total: ${loadedFromCache + downloadedFromB2}/${tracksToLoad.length}`);

                // Update total time from first buffer
                if (tracksToLoad.length > 0 && audioBuffers.has(tracksToLoad[0].id)) {
                    const firstBuffer = audioBuffers.get(tracksToLoad[0].id);
                    totalTime = firstBuffer.duration;
                    updateTimeDisplay();
                    console.log(` Total time: ${totalTime.toFixed(2)}s`);
                }

            } catch (error) {
                console.error(' Error loading audio buffers:', error);
            }
        }


        // Save current setlist to IndexedDB cache
        async function saveCurrentSetlist(setlistId, setlistData) {
            try {
                if (!cacheSystem) {
                    console.warn(' Cache system not available, cannot save setlist');
                    return;
                }

                // Save setlist data
                await cacheSystem.saveSetlist(setlistId, setlistData);

                // Save as last used setlist
                await cacheSystem.saveAppState('lastSetlist', setlistId);

                console.log(' Saved setlist to IndexedDB:', setlistData.name);
                console.log(' Set as last used setlist');
            } catch (error) {
                console.error(' Error saving setlist:', error);
            }
        }


        // Placeholder functions (to be implemented)
        function loadUserSongs() {
            console.log(' loadUserSongs() called (placeholder)');
        }

        function loadLibrarySongs() {
            console.log(' loadLibrarySongs() called (placeholder)');
        }

        function loadLibrarySongsForSidebar() {
            console.log(' loadLibrarySongsForSidebar() called (placeholder)');
        }

        function updateCurrentSongLedDisplay(songName) {
            console.log(' Current song:', songName);
            // Update LED display with song name if needed
        }


        // Test Firebase connectivity
        async function testFirebaseConnectivity() {
            try {
                console.log(' Testing Firebase connectivity...');

                // Test Firestore connection
                const testCollection = window.firebase.collection(window.firebase.db, 'connectivity-test');
                const testDoc = window.firebase.doc(testCollection, 'test');

                // Try to write a test document
                await window.firebase.setDoc(testDoc, {
                    timestamp: new Date(),
                    test: true
                });
                console.log(' Firestore write test successful');

                // Try to read the test document
                const docSnap = await window.firebase.getDoc(testDoc);
                if (docSnap.exists()) {
                    console.log(' Firestore read test successful');
                }

                // Clean up test document
                await window.firebase.deleteDoc(testDoc);
                console.log(' Firestore connectivity test passed');

                return { success: true, message: 'Firebase connectivity OK' };
            } catch (error) {
                console.error(' Firebase connectivity test failed:', error);
                return { success: false, error: error.message };
            }
        }

        // Initialize Firebase Auth
        function initAuth() {
            console.log(' Initializing Firebase Auth...');
            console.log('Firebase object:', window.firebase);

            if (window.firebase) {
                console.log(' Firebase is available');
                console.log('Auth object:', window.firebase.auth);
                console.log('DB object:', window.firebase.db);

                // Test connectivity first
                testFirebaseConnectivity().then(result => {
                    if (result.success) {
                        console.log(' Firebase connectivity verified');
                    } else {
                        console.error(' Firebase connectivity issue:', result.error);
                        alert(` Firebase Connection Issue:\n\n${result.error}\n\nPlease check your internet connection and try again.`);
                    }
                });

                console.log(' SETTING UP onAuthStateChanged listener...');
                window.firebase.onAuthStateChanged(window.firebase.auth, (user) => {
                    console.log(' Auth state changed:', user ? 'User logged in' : 'User logged out');
                    currentUser = user;
                    updateAuthUI();

                    if (user) {
                        console.log(' USER AUTHENTICATED - Starting user setup...');
                        console.log(' User details:', {
                            uid: user.uid,
                            email: user.email,
                            displayName: user.displayName
                        });

                        // LED startup sequence removed - show normal controls immediately
                        ensureLEDScreenVisible();

                        // Load user's audio files and songs when logged in
                        loadUserAudioFiles();
                        loadUserSongs();
                        // Load library songs
                        setTimeout(() => {
                            loadLibrarySongs();
                            loadLibrarySongsForSidebar();
                        }, 1000);

                        // Auto-load first setlist after user is authenticated
                        console.log(' SETTING TIMEOUT for auto-load first setlist...');
                        setTimeout(() => {
                            console.log('Auto-loading first setlist...');
                            autoLoadLastSetlist();
                        }, 2000);
                    } else {
                        // Clear audio files list when logged out
                        const audioFilesContainer = document.getElementById('audioFilesList');
                        if (audioFilesContainer) {
                            audioFilesContainer.innerHTML = '';
                        }
                    }
                });
            } else {
                console.error(' Firebase not initialized');
            }
        }

        // Update UI based on auth state
        function updateAuthUI() {
            console.log(' Updating auth UI...');
            console.log(' Current user:', currentUser);

            const authButton = document.getElementById('authButton');
            if (authButton) {
                if (currentUser) {
                    console.log(' User is authenticated, updating UI...');
                    // Show user info with profile picture if available
                    const displayName = currentUser.displayName || currentUser.email;
                    const profileIcon = currentUser.photoURL ?
                        `<img src="${currentUser.photoURL}" alt="Profile" style="width: 20px; height: 20px; border-radius: 50%; margin-right: 8px;">` :
                        ' ';

                    authButton.innerHTML = `${profileIcon}${displayName}`;
                    authButton.onclick = signOutUser;
                    console.log(' Auth button updated with user info');

                    // Load user's audio files and songs when logged in
                    loadUserAudioFiles();
                    loadUserSongs();
                    // Load library songs
                    setTimeout(() => {
                        loadLibrarySongs();
                    }, 1000);
                } else {
                    console.log(' No user authenticated, showing login button');
                    authButton.textContent = ' Login';
                    authButton.onclick = showAuthModal;
                    // Clear audio files list when logged out
                    const audioFilesContainer = document.getElementById('audioFilesList');
                    if (audioFilesContainer) {
                        audioFilesContainer.innerHTML = '';
                    }
                }
            } else {
                console.error(' Auth button element not found');
            }
        }

        // Show auth modal
        function showAuthModal() {
            const modal = document.getElementById('authModal');
            if (modal) {
                modal.style.display = 'block';
                hideAuthError(); // Clear any previous errors
            }
        }

        // Hide auth modal
        function hideAuthModal() {
            const modal = document.getElementById('authModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Register user
        async function registerUser(email, password, displayName) {
            try {
                console.log(' Registering user:', email);
                const userCredential = await window.firebase.createUserWithEmailAndPassword(window.firebase.auth, email, password);
                const user = userCredential.user;
                console.log(' User created:', user.uid);

                // Create user document in Firestore
                console.log(' Creating user document in Firestore...');
                await window.firebase.setDoc(window.firebase.doc(window.firebase.db, 'users', user.uid), {
                    uid: user.uid,
                    email: user.email,
                    displayName: displayName,
                    createdAt: new Date(),
                    setlists: [],
                    preferences: {
                        theme: 'dark',
                        defaultBPM: 120,
                        defaultKey: 'C'
                    }
                });
                console.log(' User document created');

                hideAuthModal();
                return { success: true };
            } catch (error) {
                console.error(' Registration error:', error);
                return { success: false, error: error.message };
            }
        }

        // Sign in user
        async function signInUser(email, password) {
            try {
                await window.firebase.signInWithEmailAndPassword(window.firebase.auth, email, password);
                hideAuthModal();
                return { success: true };
            } catch (error) {
                console.error(' Login error:', error);

                // Translate Firebase error codes to friendly Spanish messages
                let friendlyMessage = 'Error al iniciar sesin';

                if (error.code === 'auth/invalid-credential' || error.code === 'auth/wrong-password') {
                    friendlyMessage = 'Email o contrasea incorrectos. Por favor verifica tus datos.';
                } else if (error.code === 'auth/user-not-found') {
                    friendlyMessage = 'No existe una cuenta con este email. Regstrate primero en la pgina web.';
                } else if (error.code === 'auth/invalid-email') {
                    friendlyMessage = 'El formato del email es invlido.';
                } else if (error.code === 'auth/user-disabled') {
                    friendlyMessage = 'Esta cuenta ha sido deshabilitada. Contacta soporte.';
                } else if (error.code === 'auth/too-many-requests') {
                    friendlyMessage = 'Demasiados intentos fallidos. Por favor espera unos minutos.';
                } else if (error.code === 'auth/network-request-failed') {
                    friendlyMessage = 'Error de conexin. Verifica tu internet.';
                } else {
                    friendlyMessage = `Error: ${error.message}`;
                }

                return { success: false, error: friendlyMessage };
            }
        }

        // Sign out user
        async function signOutUser() {
            try {
                await window.firebase.signOut(window.firebase.auth);
                return { success: true };
            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        // Sign in with Google
        async function signInWithGoogle() {
            try {
                console.log(' Starting Google Sign-In...');

                // Test connectivity first
                const connectivityTest = await testFirebaseConnectivity();
                if (!connectivityTest.success) {
                    throw new Error(`Firebase connectivity issue: ${connectivityTest.error}`);
                }

                const provider = new window.firebase.GoogleAuthProvider();
                console.log(' Opening Google Sign-In popup...');

                const result = await window.firebase.signInWithPopup(window.firebase.auth, provider);
                const user = result.user;
                console.log(' Google Sign-In successful:', user.email);

                // Update current user immediately
                currentUser = user;
                console.log(' Current user updated:', currentUser.uid);

                // Save user data to Firestore if it's a new user
                console.log(' Checking user document in Firestore...');
                const userRef = window.firebase.doc(window.firebase.db, 'users', user.uid);
                const userSnap = await window.firebase.getDoc(userRef);

                if (!userSnap.exists()) {
                    console.log(' Creating new user document...');
                    await window.firebase.setDoc(userRef, {
                        uid: user.uid,
                        email: user.email,
                        displayName: user.displayName,
                        photoURL: user.photoURL,
                        createdAt: new Date(),
                        setlists: [],
                        preferences: {
                            theme: 'dark',
                            defaultBPM: 120,
                            defaultKey: 'C'
                        }
                    });
                    console.log(' User document created');
                } else {
                    console.log(' User document already exists');
                }

                // Update UI immediately
                console.log(' Updating UI after successful sign-in...');
                updateAuthUI();

                return { success: true, user };
            } catch (error) {
                console.error(' Google Sign-In error:', error);

                // Provide more specific error messages
                let errorMessage = error.message;
                if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = 'Sign-in cancelled by user';
                } else if (error.code === 'auth/popup-blocked') {
                    errorMessage = 'Popup blocked by browser. Please allow popups for this site.';
                } else if (error.message.includes('client is offline')) {
                    errorMessage = 'No internet connection. Please check your connection and try again.';
                } else if (error.message.includes('Failed to fetch')) {
                    errorMessage = 'Network error. Please check your internet connection.';
                }

                return { success: false, error: errorMessage };
            }
        }

        // Upload audio file to B2 via proxy
        async function uploadAudioFile(file, userId) {
            try {
                console.log(' Uploading to B2 via proxy...');
                console.log(' Original file size:', file.size, 'bytes (', (file.size / 1024 / 1024).toFixed(2), 'MB)');
                console.log(' File type:', file.type);
                console.log(' File name:', file.name);
                console.log(' File instanceof File:', file instanceof File);
                console.log(' File constructor:', file.constructor.name);

                // Check file size limit (2GB)
                const maxSize = 2 * 1024 * 1024 * 1024; // 2GB
                if (file.size > maxSize) {
                    const errorTitle = 'Archivo Demasiado Grande';
                    const errorMessage = `El archivo "${file.name}" supera el lmite permitido.`;
                    const errorDetails = `Tamao actual: ${(file.size / 1024 / 1024).toFixed(2)} MB\nLmite mximo: 2,048 MB (2 GB)`;

                    showErrorMessage(errorTitle, errorMessage, errorDetails);
                    throw new Error(`File too large: ${(file.size / 1024 / 1024).toFixed(2)}MB > 2048MB`);
                }

                // Convert to base64 using FileReader (more reliable for large files)
                console.log(' Converting file to base64...');
                const base64Data = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const result = reader.result;
                        console.log(' FileReader result length:', result.length, 'characters');
                        console.log(' FileReader result type:', typeof result);
                        console.log(' FileReader result starts with:', result.substring(0, 50));

                        // Remove data URL prefix (data:audio/wav;base64,)
                        const base64 = result.split(',')[1];
                        console.log(' Base64 data length:', base64.length, 'characters');
                        console.log(' Base64 size estimate:', (base64.length * 0.75).toFixed(0), 'bytes');
                        console.log(' Base64 starts with:', base64.substring(0, 50));
                        console.log(' Base64 ends with:', base64.substring(base64.length - 50));

                        // Verify base64 is not empty
                        if (!base64 || base64.length === 0) {
                            console.error(' Base64 data is empty!');
                            reject(new Error('Base64 conversion resulted in empty data'));
                            return;
                        }

                        resolve(base64);
                    };
                    reader.onerror = (error) => {
                        console.error(' FileReader error:', error);
                        reject(error);
                    };
                    reader.onabort = (error) => {
                        console.error(' FileReader aborted:', error);
                        reject(new Error('FileReader was aborted'));
                    };
                    reader.onprogress = (event) => {
                        if (event.lengthComputable) {
                            const percentComplete = (event.loaded / event.total) * 100;
                            console.log(' FileReader progress:', percentComplete.toFixed(1) + '%');
                        }
                    };
                    reader.readAsDataURL(file);
                });

                const fileName = `audio/${userId}/${Date.now()}_${file.name}`;
                console.log(' Generated filename:', fileName);

                // Use single upload with retry for large files
                console.log(' Starting single upload...');

                let retryCount = 0;
                const maxRetries = 3;

                while (retryCount < maxRetries) {
                    try {
                        return await uploadSingleFile(fileName, base64Data, file.type, userId, file.size, file.name);
                    } catch (error) {
                        retryCount++;
                        console.log(` Upload attempt ${retryCount} failed:`, error.message);

                        if (retryCount < maxRetries) {
                            const delay = Math.pow(2, retryCount) * 1000; // Exponential backoff: 2s, 4s, 8s
                            console.log(` Retrying in ${delay / 1000} seconds... (attempt ${retryCount + 1}/${maxRetries})`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        } else {
                            throw error; // Re-throw on final attempt
                        }
                    }
                }

            } catch (error) {
                console.error(' B2 upload error:', error);
                return { success: false, error: error.message };
            }
        }


        // Upload single file
        async function uploadSingleFile(fileName, base64Data, contentType, userId, fileSize, originalName) {
            // Configure timeout based on file size (5 minutes per 100MB)
            const timeoutMs = Math.max(300000, (fileSize / (100 * 1024 * 1024)) * 300000); // Min 5 minutes, +5 min per 100MB

            console.log(` Upload timeout set to: ${(timeoutMs / 1000 / 60).toFixed(1)} minutes for ${(fileSize / 1024 / 1024).toFixed(2)}MB file`);

            // Create AbortController for timeout
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

            try {
                const response = await fetch('http://localhost:3001/upload', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        fileName: fileName,
                        fileData: base64Data,
                        contentType: contentType
                    }),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Upload failed');
                }

                const result = await response.json();
                console.log('B2 upload successful:', result);
                console.log('Uploaded file size from B2:', result.data.size || 'unknown');

                // Save to Firestore
                const audioFileData = {
                    userId: userId,
                    originalName: originalName,
                    fileName: fileName,
                    fileId: result.data.fileId,
                    downloadUrl: result.data.downloadUrl,
                    size: fileSize,
                    type: contentType,
                    createdAt: new Date()
                };

                const docRef = await window.firebase.addDoc(window.firebase.collection(window.firebase.db, 'audioFiles'), audioFileData);

                return {
                    success: true,
                    data: {
                        id: docRef.id,
                        ...audioFileData
                    }
                };

            } catch (error) {
                clearTimeout(timeoutId);

                if (error.name === 'AbortError') {
                    throw new Error(`Upload timeout: File too large (${(fileSize / 1024 / 1024).toFixed(2)}MB). Try with smaller files or check your internet connection.`);
                } else if (error.message.includes('Failed to fetch') || error.message.includes('ERR_CONNECTION_REFUSED')) {
                    throw new Error(`Connection failed: Please check your internet connection and try again. If the problem persists, try uploading smaller files.`);
                } else {
                    throw error;
                }
            }
        }

        // Test B2 connection via proxy
        async function testB2Connection() {
            try {
                console.log(' Testing B2 connection via proxy...');

                // Test proxy connection
                const response = await fetch('http://localhost:3001/test');

                if (!response.ok) {
                    throw new Error(`Proxy test failed: ${response.status}`);
                }

                const result = await response.json();
                console.log('B2 proxy test result:', result);

                if (result.success) {
                    alert(' B2 Connection Successful!\n\nProxy: OK\nAuth: OK\nUpload URL: OK\nStorage: Backblaze B2');
                    return { success: true };
                } else {
                    throw new Error(result.error);
                }

            } catch (error) {
                console.error(' B2 connection test failed:', error);

                let errorMessage = error.message;
                if (error.message.includes('Failed to fetch')) {
                    errorMessage = 'El servidor proxy B2 no est ejecutndose.\n\nEjecuta: node b2-proxy.js';
                }

                alert(` B2 Connection Test Failed:\n\n${errorMessage}`);
                return { success: false, error: error.message };
            }
        }

        // Get B2 upload URL (deprecated - using Firebase Storage now)
        async function getB2UploadUrl() {
            return { success: false, error: 'B2 deprecated - using Firebase Storage' };
        }

        // Handle file upload
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!currentUser) {
                alert('Debes iniciar sesin para subir archivos');
                return;
            }

            // Check if it's a ZIP file for songs
            if (file.type === 'application/zip' || file.name.toLowerCase().endsWith('.zip')) {
                // Validate ZIP file size (max 500MB)
                const maxZipSize = 500 * 1024 * 1024; // 500MB
                if (file.size > maxZipSize) {
                    alert(`El archivo ZIP es demasiado grande. Mximo 500MB. Tamao actual: ${(file.size / 1024 / 1024).toFixed(2)}MB`);
                    return;
                }
                handleSongZipUpload(file);
            } else {
                // Handle single audio file
                const allowedTypes = ['audio/mpeg', 'audio/wav', 'audio/mp3', 'audio/m4a', 'audio/aac'];
                if (!allowedTypes.includes(file.type)) {
                    alert('Tipo de archivo no soportado. Use MP3, WAV, M4A, AAC o ZIP.');
                    return;
                }

                // Validate file size (max 100MB)
                const maxSize = 100 * 1024 * 1024; // 100MB
                if (file.size > maxSize) {
                    alert(`El archivo es demasiado grande. Mximo 100MB. Tamao actual: ${(file.size / 1024 / 1024).toFixed(2)}MB`);
                    return;
                }

                // Upload single audio file
                uploadAudioFile(file, currentUser.uid).then(result => {
                    if (result.success) {
                        alert('Archivo subido correctamente');
                        loadUserAudioFiles();
                    } else {
                        alert('Error al subir archivo: ' + result.error);
                    }
                });
            }
        }

        // Handle ZIP file upload for songs
        async function handleSongZipUpload(zipFile) {
            try {
                // Show loading
                showLoading('Descomprimiendo archivo ZIP...');

                // Add timeout to prevent hanging
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Timeout: El archivo ZIP es demasiado grande o est corrupto')), 60000); // 60 seconds
                });

                // Extract ZIP file with timeout
                const extractedFiles = await Promise.race([
                    extractZipFile(zipFile),
                    timeoutPromise
                ]);

                if (extractedFiles.length === 0) {
                    hideLoading();
                    alert('El archivo ZIP est vaco o no contiene archivos de audio vlidos.');
                    return;
                }

                // Validate individual track sizes
                const maxTrackSize = 100 * 1024 * 1024; // 100MB per track
                const oversizedTracks = [];

                extractedFiles.forEach((file, index) => {
                    if (file.size > maxTrackSize) {
                        oversizedTracks.push({
                            name: file.name,
                            size: (file.size / 1024 / 1024).toFixed(2) + 'MB'
                        });
                    }
                });

                if (oversizedTracks.length > 0) {
                    hideLoading();
                    const trackList = oversizedTracks.map(t => `- ${t.name} (${t.size})`).join('\n');
                    alert(`Los siguientes tracks exceden el lmite de 100MB:\n\n${trackList}\n\nPor favor, reduce el tamao de estos archivos.`);
                    return;
                }

                // Show track names for editing
                showTrackNamesModal(extractedFiles, zipFile.name);

            } catch (error) {
                hideLoading();
                alert('Error al procesar el archivo ZIP: ' + error.message);
            }
        }

        // Extract ZIP file
        async function extractZipFile(zipFile) {
            return new Promise((resolve, reject) => {
                // Check if JSZip is available
                if (typeof JSZip === 'undefined') {
                    reject(new Error('JSZip library not loaded. Please refresh the page.'));
                    return;
                }

                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const zip = new JSZip();
                        zip.loadAsync(e.target.result).then(function (zip) {
                            const audioFiles = [];
                            const promises = [];

                            Object.keys(zip.files).forEach(function (filename) {
                                const file = zip.files[filename];
                                if (!file.dir && isAudioFile(filename)) {
                                    promises.push(
                                        file.async('blob').then(function (blob) {
                                            audioFiles.push({
                                                name: filename,
                                                blob: blob,
                                                size: blob.size,
                                                type: getAudioMimeType(filename)
                                            });
                                        })
                                    );
                                }
                            });

                            Promise.all(promises).then(() => {
                                resolve(audioFiles);
                            }).catch(reject);
                        }).catch(reject);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(zipFile);
            });
        }

        // Check if file is audio
        function isAudioFile(filename) {
            const audioExtensions = ['.mp3', '.wav', '.m4a', '.aac', '.flac', '.ogg'];
            const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            return audioExtensions.includes(ext);
        }

        // Get MIME type from filename
        function getAudioMimeType(filename) {
            const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            const mimeTypes = {
                '.mp3': 'audio/mpeg',
                '.wav': 'audio/wav',
                '.m4a': 'audio/mp4',
                '.aac': 'audio/aac',
                '.flac': 'audio/flac',
                '.ogg': 'audio/ogg'
            };
            return mimeTypes[ext] || 'audio/mpeg';
        }

        // Load user's audio files
        async function loadUserAudioFiles() {
            if (!currentUser) return;

            try {
                const q = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'audioFiles'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );

                const querySnapshot = await window.firebase.getDocs(q);
                const audioFiles = [];

                querySnapshot.forEach((doc) => {
                    audioFiles.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });

                displayAudioFiles(audioFiles);
            } catch (error) {
                console.error('Error loading audio files:', error);
            }
        }

        // Display audio files in UI
        function displayAudioFiles(files) {
            const audioFilesContainer = document.getElementById('audioFilesList');
            if (!audioFilesContainer) return;

            audioFilesContainer.innerHTML = '';

            files.forEach(file => {
                const fileItem = document.createElement('div');
                fileItem.className = 'audio-file-item';
                fileItem.innerHTML = `
                    <div class="file-info">
                        <div class="file-name">${file.originalName}</div>
                        <div class="file-size">${(file.size / 1024 / 1024).toFixed(2)} MB</div>
                    </div>
                    <div class="file-actions">
                        <button onclick="playAudioFile('${file.downloadUrl}')" class="play-btn"></button>
                        <button onclick="deleteAudioFile('${file.id}')" class="delete-btn"></button>
                    </div>
                `;
                audioFilesContainer.appendChild(fileItem);
            });
        }

        // Play audio file
        function playAudioFile(url) {
            const audio = new Audio(url);
            audio.play().catch(error => {
                console.error('Error playing audio:', error);
                alert('Error al reproducir el archivo');
            });
        }

        // Delete audio file
        async function deleteAudioFile(fileId) {
            if (!confirm('Ests seguro de que quieres eliminar este archivo?')) return;

            try {
                await window.firebase.deleteDoc(window.firebase.doc(window.firebase.db, 'audioFiles', fileId));
                loadUserAudioFiles();
                alert('Archivo eliminado correctamente');
            } catch (error) {
                console.error('Error deleting file:', error);
                alert('Error al eliminar el archivo');
            }
        }

        // Handle Google Sign In
        async function handleGoogleSignIn() {
            try {
                const result = await signInWithGoogle();
                if (result.success) {
                    hideAuthModal();
                    // UI is already updated in signInWithGoogle()
                    console.log(' Google Sign-In completed successfully');
                } else {
                    showAuthError(result.error);
                }
            } catch (error) {
                showAuthError('Error al iniciar sesin con Google: ' + error.message);
            }
        }

        // Show auth error
        function showAuthError(message) {
            const errorDiv = document.getElementById('authError');
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
            }
        }

        // Hide auth error
        function hideAuthError() {
            const errorDiv = document.getElementById('authError');
            if (errorDiv) {
                errorDiv.style.display = 'none';
            }
        }

        // Library functions
        let libraryOpen = false;
        let currentCategory = 'all';

        function toggleLibrary() {
            console.log(' Toggle library called, current state:', libraryOpen);
            const sidebar = document.getElementById('librarySidebar');
            if (sidebar) {
                libraryOpen = !libraryOpen;
                console.log(' New library state:', libraryOpen);
                if (libraryOpen) {
                    sidebar.classList.add('open');
                    console.log(' Loading library items...');
                    loadLibraryItems();
                } else {
                    sidebar.classList.remove('open');
                    console.log(' Library sidebar closed');
                }
            } else {
                console.error(' Library sidebar element not found');
            }
        }

        function loadLibraryItems() {
            const libraryItems = document.getElementById('sidebarLibraryItems');
            if (!libraryItems) return;

            // Load real library songs
            loadLibrarySongsForSidebar();

            // Load setlist buttons
            loadSetlistButtonsForSidebar();

            // Load current setlist
            loadCurrentSetlistForSidebar();
        }

        // Load library songs for sidebar (using the working logic from loadLibrarySongs)
        async function loadLibrarySongsForSidebar() {
            try {
                console.log(' Loading library songs for sidebar...');
                const libraryItems = document.getElementById('sidebarLibraryItems');
                if (!libraryItems) {
                    console.error(' sidebarLibraryItems element not found');
                    return;
                }

                libraryItems.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">Cargando biblioteca...</div>';

                console.log(' Current user:', currentUser ? currentUser.uid : 'No user');
                if (!currentUser) {
                    console.log(' No user logged in');
                    libraryItems.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">Inicia sesin para ver tu biblioteca</div>';
                    return;
                }

                console.log(' Querying Firestore for songs...');
                const songsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'songs'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );

                const querySnapshot = await window.firebase.getDocs(songsQuery);
                const songs = [];

                console.log(' Query snapshot size:', querySnapshot.size);

                querySnapshot.forEach((doc) => {
                    const songData = { id: doc.id, ...doc.data() };
                    console.log(' Found song:', songData.name, 'with', songData.tracks?.length || 0, 'tracks');
                    songs.push(songData);
                });

                console.log(' Library songs loaded:', songs.length);
                displayLibrarySongsForSidebar(songs);

            } catch (error) {
                console.error(' Error loading library songs for sidebar:', error);
                const libraryItems = document.getElementById('sidebarLibraryItems');
                if (libraryItems) {
                    libraryItems.innerHTML = '<div style="text-align: center; padding: 20px; color: #ff4444;">Error al cargar biblioteca: ' + error.message + '</div>';
                }
            }
        }

        // Display library songs for sidebar
        function displayLibrarySongsForSidebar(songs) {
            console.log(' Displaying library songs for sidebar:', songs.length);
            const libraryItems = document.getElementById('sidebarLibraryItems');

            if (!libraryItems) {
                console.error(' Sidebar library items element not found');
                return;
            }

            if (songs.length === 0) {
                console.log(' No songs found, showing empty state');
                libraryItems.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #888;">
                        <p>No tienes canciones en tu biblioteca</p>
                    </div>
                `;
                return;
            }

            let songsHTML = '';
            songs.forEach((song) => {
                songsHTML += `
                    <div class="library-item" draggable="true" data-song-id="${song.id}" data-song-name="${song.name}" data-song-tracks="${song.tracks?.length || 0}">
                        <div class="library-item-info">
                            <div class="library-item-name">${song.name}</div>
                            <div class="library-item-details">${song.tracks?.length || 0} tracks</div>
                        </div>
                        <div class="library-item-actions">
                            <button class="delete-library-btn" onclick="deleteSongFromLibrary('${song.id}', '${song.name}')" title="Eliminar cancin"></button>
                        </div>
                    </div>
                `;
            });

            libraryItems.innerHTML = songsHTML;
            console.log(' Generated HTML for', songs.length, 'songs in sidebar');

            // Add drag event listeners
            addDragListeners();
        }

        // Load setlist buttons for sidebar
        async function loadSetlistButtonsForSidebar() {
            try {
                console.log('Loading setlist buttons for sidebar...');
                const setlistButtons = document.getElementById('sidebarSetlistButtons');

                if (!setlistButtons) {
                    console.error(' Sidebar setlist buttons element not found');
                    return;
                }

                if (!currentUser) {
                    console.log(' No user logged in');
                    setlistButtons.innerHTML = '<div style="text-align: center; padding: 10px; color: #888; font-size: 12px;">Inicia sesin para ver setlists</div>';
                    return;
                }

                console.log(' Querying Firestore for setlists...');
                const setlistsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'setlists'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );

                const querySnapshot = await window.firebase.getDocs(setlistsQuery);
                const setlists = [];

                console.log(' Setlists query result:', querySnapshot.size, 'setlists found');

                querySnapshot.forEach((doc) => {
                    const setlistData = { id: doc.id, ...doc.data() };
                    console.log('Found setlist:', setlistData.name, 'with', setlistData.songs?.length || 0, 'songs');
                    setlists.push(setlistData);
                });

                if (setlists.length === 0) {
                    console.log(' No setlists found');
                    setlistButtons.innerHTML = '<div style="text-align: center; padding: 10px; color: #888; font-size: 12px;">No hay setlists creados</div>';
                    return;
                }

                let buttonsHTML = '';
                setlists.forEach((setlist) => {
                    const isActive = currentSetlist && currentSetlist.id === setlist.id;
                    buttonsHTML += `
                        <button class="setlist-btn ${isActive ? 'active' : ''}" 
                                onclick="switchToSetlist('${setlist.id}')" 
                                title="${setlist.name} (${setlist.songs?.length || 0} canciones)">
                            ${setlist.name}
                        </button>
                    `;
                });

                setlistButtons.innerHTML = buttonsHTML;
                console.log(' Generated HTML for', setlists.length, 'setlist buttons');

            } catch (error) {
                console.error(' Error loading setlist buttons for sidebar:', error);
                const setlistButtons = document.getElementById('sidebarSetlistButtons');
                if (setlistButtons) {
                    setlistButtons.innerHTML = '<div style="text-align: center; padding: 10px; color: #ff4444; font-size: 12px;">Error al cargar setlists</div>';
                }
            }
        }

        // Load current setlist for sidebar
        function loadCurrentSetlistForSidebar() {
            console.log(' SIDEBAR - Loading current setlist for sidebar...');
            console.log(' SIDEBAR - Current setlist:', currentSetlist);
            const setlistItems = document.getElementById('sidebarSetlistItems');
            const currentSetlistTitle = document.getElementById('currentSetlistTitle');

            console.log(' SIDEBAR - setlistItems element:', setlistItems);
            console.log(' SIDEBAR - currentSetlistTitle element:', currentSetlistTitle);

            if (!setlistItems) {
                console.error(' SIDEBAR - Sidebar setlist items element not found');
                return;
            }

            // Update title
            if (currentSetlistTitle) {
                const titleText = currentSetlist ? currentSetlist.name : 'Sin Setlist';
                console.log(' SIDEBAR - Updating title to:', titleText);
                currentSetlistTitle.textContent = titleText;
            }

            if (!currentSetlist || !currentSetlist.songs || currentSetlist.songs.length === 0) {
                console.log(' No current setlist or empty setlist');
                setlistItems.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #888;">
                        <p>No hay setlist activo</p>
                        <p style="font-size: 12px; margin-top: 10px;">Arrastra canciones aqu desde la biblioteca</p>
                    </div>
                `;
                return;
            }

            let setlistHTML = '';
            currentSetlist.songs.forEach((song, index) => {
                setlistHTML += `
                    <div class="setlist-item" data-song-id="${song.id}" onclick="selectLibrarySong('${song.id}')">
                        <div class="setlist-item-info">
                            <div class="setlist-item-order">${index + 1}</div>
                            <div class="setlist-item-name">${song.name} <div class="loading-spinner"></div>${isSongCachedOffline(song.id) ? '<div class="offline-indicator"></div>' : ''}</div>
                            <div class="setlist-item-details">${song.tracks?.length || 0} tracks</div>
                            <div class="setlist-loading-indicator" id="loading-${song.id}"></div>
                        </div>
                        <button class="remove-btn" onclick="event.stopPropagation(); removeFromSetlist('${song.id}')" title="Eliminar del setlist"></button>
                    </div>
                `;
            });

            console.log(' SIDEBAR - Generated HTML:', setlistHTML);
            setlistItems.innerHTML = setlistHTML;
            console.log(' SIDEBAR - Generated HTML for', currentSetlist.songs.length, 'songs in setlist sidebar');
            console.log(' SIDEBAR - setlistItems.innerHTML length:', setlistItems.innerHTML.length);
        }

        // Add drag and drop event listeners
        function addDragListeners() {
            const libraryItems = document.querySelectorAll('.library-item');
            const setlistItems = document.getElementById('sidebarSetlistItems');

            // Add drag start listeners to library items
            libraryItems.forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragend', handleDragEnd);
            });

            // Add drop listeners to setlist area
            if (setlistItems) {
                setlistItems.addEventListener('dragover', handleDragOver);
                setlistItems.addEventListener('drop', handleDrop);
                setlistItems.addEventListener('dragenter', handleDragEnter);
                setlistItems.addEventListener('dragleave', handleDragLeave);
            }
        }

        // Drag and drop event handlers
        function handleDragStart(e) {
            const songId = e.target.dataset.songId;
            const songName = e.target.dataset.songName;
            const songTracks = e.target.dataset.songTracks;

            e.dataTransfer.setData('text/plain', JSON.stringify({
                songId: songId,
                songName: songName,
                songTracks: songTracks
            }));

            e.target.classList.add('dragging');
            console.log(' Drag started for song:', songName);
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            console.log(' Drag ended');
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            e.target.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.target.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.target.classList.remove('drag-over');

            try {
                const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                console.log(' Dropped song:', data);

                // Add song to current setlist
                addSongToSetlist(data.songId, data.songName, data.songTracks);

            } catch (error) {
                console.error(' Error handling drop:', error);
            }
        }

        // Add song to setlist
        async function addSongToSetlist(songId, songName, songTracks) {
            try {
                if (!currentSetlist) {
                    alert(' No hay setlist activo. Crea un setlist primero.');
                    return;
                }

                // Check if song is already in setlist
                const existingSong = currentSetlist.songs.find(song => song.id === songId);
                if (existingSong) {
                    alert(' Esta cancin ya est en el setlist.');
                    return;
                }

                // Get full song data from Firestore to include artist, tempo, etc.
                const songRef = window.firebase.doc(window.firebase.db, 'songs', songId);
                const songSnap = await window.firebase.getDoc(songRef);

                if (!songSnap.exists()) {
                    alert(' Cancin no encontrada en la biblioteca.');
                    return;
                }

                const fullSongData = songSnap.data();
                console.log(' Full song data for setlist:', fullSongData);

                // Add song to setlist with complete information
                const newSong = {
                    id: songId,
                    name: fullSongData.name || songName,
                    artist: fullSongData.artist || '',
                    tempo: fullSongData.tempo || null,
                    key: fullSongData.key || '',
                    timeSignature: fullSongData.timeSignature || '',
                    tracks: fullSongData.tracks || [],
                    order: currentSetlist.songs.length + 1
                };

                currentSetlist.songs.push(newSong);

                // Save to Firebase
                await saveSetlistToFirebase(currentSetlist);

                // Update display
                loadCurrentSetlistForSidebar();

                // Update main setlist display if it's currently shown
                if (currentSetlist && currentSetlist.id) {
                    console.log(' Updating main setlist display after adding song...');
                    await displaySetlistSongs(currentSetlist);
                }

                console.log(' Song added to setlist:', songName);
                alert(` "${songName}" agregada al setlist`);

            } catch (error) {
                console.error(' Error adding song to setlist:', error);
                alert(' Error al agregar cancin al setlist: ' + error.message);
            }
        }

        // Delete song from library
        async function deleteSongFromLibrary(songId, songName) {
            try {
                if (!currentUser) {
                    alert(' Debes iniciar sesin para eliminar canciones');
                    return;
                }

                if (!confirm(`Eliminar "${songName}" de la biblioteca?\n\nEsta accin eliminar la cancin permanentemente y no se puede deshacer.`)) {
                    return;
                }

                console.log(' Deleting song from library:', songId, songName);

                // Delete from Firestore
                const songRef = window.firebase.doc(window.firebase.db, 'songs', songId);
                await window.firebase.deleteDoc(songRef);

                console.log(' Song deleted from Firestore');

                // Reload library to update display
                await loadLibrarySongsForSidebar();

                alert(` "${songName}" eliminada de la biblioteca`);

            } catch (error) {
                console.error(' Error deleting song from library:', error);
                alert(' Error al eliminar cancin: ' + error.message);
            }
        }

        // Remove song from setlist
        async function removeFromSetlist(songId) {
            try {
                if (!currentSetlist || !currentSetlist.songs) {
                    return;
                }

                const songIndex = currentSetlist.songs.findIndex(song => song.id === songId);
                if (songIndex === -1) {
                    return;
                }

                const songName = currentSetlist.songs[songIndex].name;

                if (confirm(`Eliminar "${songName}" del setlist?`)) {
                    currentSetlist.songs.splice(songIndex, 1);

                    // Update order numbers
                    currentSetlist.songs.forEach((song, index) => {
                        song.order = index + 1;
                    });

                    // Save to Firebase
                    await saveSetlistToFirebase(currentSetlist);

                    // Update display
                    loadCurrentSetlistForSidebar();
                    updateSetlistDisplay();

                    // Update main setlist display
                    if (currentSetlist.songs && currentSetlist.songs.length > 0) {
                        displaySongs(currentSetlist.songs);
                    } else {
                        displayEmptySetlist();
                    }

                    console.log(' Song removed from setlist:', songName);
                }

            } catch (error) {
                console.error(' Error removing song from setlist:', error);
                alert(' Error al eliminar cancin del setlist: ' + error.message);
            }
        }

        // Switch to a different setlist
        async function switchToSetlist(setlistId) {
            try {
                console.log(' Switching to setlist:', setlistId);

                if (!currentUser) {
                    alert(' Debes iniciar sesin para cambiar de setlist');
                    return;
                }

                // Load the setlist from Firebase
                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistDoc = await window.firebase.getDoc(setlistRef);

                if (!setlistDoc.exists()) {
                    alert(' El setlist no existe');
                    return;
                }

                const setlistData = { id: setlistDoc.id, ...setlistDoc.data() };

                // Set as current setlist
                currentSetlist = setlistData;

                // Save to localStorage and Firestore
                saveLastUsedSetlist(currentSetlist);

                // Update displays
                loadCurrentSetlistForSidebar();
                loadSetlistButtonsForSidebar(); // Refresh buttons to show active state
                updateSetlistDisplay();

                console.log(' Switched to setlist:', setlistData.name);
                alert(` Cambiado a setlist: "${setlistData.name}"`);

            } catch (error) {
                console.error(' Error switching to setlist:', error);
                alert(' Error al cambiar de setlist: ' + error.message);
            }
        }

        // Select and load a song from library
        async function selectLibrarySong(songId) {
            try {
                console.log(' Selecting library song:', songId);
                console.log(' About to call loadSong with ID:', songId);
                await loadSong(songId);
                console.log(' loadSong completed for ID:', songId);
            } catch (error) {
                console.error(' Error selecting library song:', error);
                console.error(' Error details:', error.message);
                console.error(' Error stack:', error.stack);
            }
        }

        // Download song locally
        async function downloadSong(songId) {
            try {
                console.log(' Downloading song:', songId);
                // TODO: Implement local download
                alert('Funcionalidad de descarga local en desarrollo');
            } catch (error) {
                console.error(' Error downloading song:', error);
            }
        }

        // Test library load function
        async function testLibraryLoad() {
            console.log(' Testing library load...');
            console.log(' Current user:', currentUser);
            console.log(' Firebase object:', window.firebase);

            if (!currentUser) {
                alert(' No hay usuario autenticado');
                return;
            }

            if (!window.firebase) {
                alert(' Firebase no est disponible');
                return;
            }

            try {
                await loadLibrarySongs();
                alert(' Test de biblioteca completado. Revisa la consola para detalles.');
            } catch (error) {
                alert(' Error en test de biblioteca: ' + error.message);
            }
        }

        // Load tracks for a specific song
        async function loadSongTracks(songData, useModal = true) {
            console.log(' Loading song tracks:', songData);
            console.log(' Song name:', songData.name);
            console.log(' Song tracks:', songData.tracks);

            // CRITICAL: Clear ALL previous data completely
            console.log(' COMPLETE CLEANUP - Clearing all previous tracks and audio buffers...');

            // Stop all audio sources first
            stopAllAudioSources();

            // Clear all arrays and maps
            tracks = [];
            audioBuffers.clear();
            audioSources.clear();
            gainNodes.clear();
            analysers.clear();
            eqNodes.clear();

            // Reset audio context state
            if (audioContext) {
                // Disconnect all nodes to prevent memory leaks
                audioContext.close().then(() => {
                    console.log(' AudioContext closed for cleanup');
                }).catch(err => {
                    console.warn(' Error closing AudioContext:', err);
                });

                // Create new audio context
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log(' New AudioContext created after cleanup');
            }

            // Clear tracks grid
            const tracksGrid = document.getElementById('tracksGrid');
            if (tracksGrid) {
                tracksGrid.innerHTML = '';
            }

            // Show loading indicator
            updateTracksGrid();

            console.log(' COMPLETE CLEANUP finished - all previous data cleared');

            // Load tracks based on song data
            console.log(' Song data structure:', songData);
            console.log(' Song tracks:', songData.tracks);

            // Handle different track data structures
            let trackData = [];
            if (songData.tracks && Array.isArray(songData.tracks)) {
                // Check if tracks are objects or strings
                if (typeof songData.tracks[0] === 'object' && songData.tracks[0] !== null) {
                    // Tracks are objects with name, downloadUrl, etc.
                    trackData = songData.tracks;
                } else {
                    // Tracks are just names (strings)
                    trackData = songData.tracks.map(name => ({ name: name }));
                }
            } else {
                // Fallback to default track names
                trackData = [
                    { name: 'Drums' },
                    { name: 'Bass' },
                    { name: 'Guitar' },
                    { name: 'Keys' },
                    { name: 'Vocals' },
                    { name: 'Backing Vocals' }
                ];
            }

            tracks = trackData.map((track, index) => {
                // Extract track name properly
                let trackName = '';
                if (typeof track === 'string') {
                    trackName = track;
                } else if (track && typeof track === 'object') {
                    trackName = track.name || track.title || `Track ${index + 1}`;
                } else {
                    trackName = `Track ${index + 1}`;
                }

                const trackObj = {
                    id: index + 1,
                    name: trackName,
                    volume: 0.8,
                    muted: false,
                    solo: false,
                    playing: false,
                    audioUrl: track.downloadUrl || track.audioUrl || null
                };
                console.log(` Created track ${index + 1}:`, trackObj);
                return trackObj;
            });

            // Load audio files for each track (online playback from B2)
            let maxDuration = 0;
            console.log(' Starting to load audio files for', tracks.length, 'tracks');

            // Start loading tracks
            console.log(' Starting to load audio files for', tracks.length, 'tracks');

            for (let i = 0; i < tracks.length; i++) {
                const track = tracks[i];
                let audioUrl = track.audioUrl;

                // Update loading progress
                const progress = Math.round((i / tracks.length) * 100);
                if (!useModal) {
                    // Update small progress bar for the song being loaded
                    updateSongLoadingProgress(songData.id, progress);
                }

                console.log(` Processing track ${track.id} (${track.name}):`);
                console.log('  - track.audioUrl:', track.audioUrl);
                console.log('  - track.originalUrl:', track.originalUrl);
                console.log('  - track.downloadUrl:', track.downloadUrl);
                console.log('  - Full track object:', track);

                // Use B2 URLs for online playback
                if (track.originalUrl) {
                    console.log(' Using B2 URL for online playback:', track.name);
                    audioUrl = track.originalUrl;
                } else if (track.downloadUrl) {
                    console.log(' Using download URL for online playback:', track.name);
                    audioUrl = track.downloadUrl;
                }

                if (audioUrl) {
                    console.log(' Loading audio for track:', track.name, 'from B2 (online playback)');
                    console.log(' Audio URL:', audioUrl);
                    console.log(' Track ID:', track.id);

                    // Log progress
                    console.log(` Loading track ${i + 1}/${tracks.length}: ${track.name}`);

                    try {
                        console.log(' Calling loadAudioFile for track:', track.id);
                        const audioBuffer = await loadAudioFile(audioUrl, track.id);
                        console.log(' loadAudioFile returned:', audioBuffer ? 'SUCCESS' : 'FAILED');

                        if (audioBuffer) {
                            maxDuration = Math.max(maxDuration, audioBuffer.duration);
                            console.log(' Track duration:', audioBuffer.duration, 'seconds');
                            console.log(' Track duration formatted:', formatTime(audioBuffer.duration));
                            console.log(' Max duration so far:', maxDuration, 'seconds');
                            console.log(' Audio buffer stored for track:', track.id);
                            console.log(' Audio buffers map size:', audioBuffers.size);
                            console.log(' Buffer exists in map:', audioBuffers.has(track.id));
                        } else {
                            console.error(' Failed to load audio buffer for track:', track.id);
                            console.error(' loadAudioFile returned null/undefined');
                        }
                    } catch (error) {
                        console.error(' Error loading audio for track:', track.id, error);
                        console.error(' Error details:', error.message);
                        console.error(' Error stack:', error.stack);
                    }
                } else {
                    console.warn(' No audio URL for track:', track.name);
                    console.warn(' Track object:', track);
                }

                // Log progress for this track
                console.log(` Track ${i + 1}/${tracks.length} completed: ${track.name}`);
            }

            console.log(' Finished loading audio files. Total buffers:', audioBuffers.size);
            console.log(' Available buffer IDs:', Array.from(audioBuffers.keys()));

            // Verify all tracks have buffers
            const missingBuffers = tracks.filter(track => !audioBuffers.has(track.id));
            if (missingBuffers.length > 0) {
                console.warn(' Tracks without buffers:', missingBuffers.map(t => `${t.id} (${t.name})`));
                console.warn(' This will cause playback issues');
            } else {
                console.log(' All tracks have audio buffers loaded');
            }

            // Preload all buffers for perfect synchronization
            await preloadAllBuffersForSync();

            // Set total time to the longest track duration
            if (maxDuration > 0) {
                totalTime = maxDuration;
                console.log(' Total song duration set to:', totalTime, 'seconds');
                updateTimeDisplay();
            }

            updateTracksGrid();

            // Update BPM and Key displays with song metadata
            console.log(' Song metadata - tempo:', songData.tempo, 'key:', songData.key);
            console.log(' Song metadata type - tempo:', typeof songData.tempo, 'key:', typeof songData.key);

            // Force BPM update from song metadata
            updateBPMFromSongData(songData);

            // Force update BPM display to ensure it's visible
            setTimeout(() => {
                console.log(' Force updating BPM display after song load...');
                updateBPMDisplay();
            }, 100);

            if (songData.key) {
                console.log(' Setting key from song metadata:', songData.key);
                setOriginalKey(songData.key);
            } else {
                console.log(' No key found in song metadata, keeping default key:', currentKey);
            }

            // Debug: Check loaded buffers
            console.log(' Debug: Checking loaded audio buffers...');
            console.log(' Total tracks:', tracks.length);
            console.log(' Audio buffers map size:', audioBuffers.size);
            console.log(' Available buffer IDs:', Array.from(audioBuffers.keys()));

            // Check each track
            tracks.forEach(track => {
                const hasBuffer = audioBuffers.has(track.id);
                console.log(` Track ${track.id} (${track.name}): ${hasBuffer ? ' Has buffer' : ' No buffer'}`);
                console.log(`  - Audio URL: ${track.audioUrl || 'None'}`);
            });

            console.log(' Finished loading all tracks');

            // Loading complete - tracks will be shown in updateTracksGrid()
        }

        // Clear tracks when no song is selected
        function clearTracks() {
            tracks = [];
            updateTracksGrid();
        }

        // Global variables for song upload
        let currentExtractedFiles = [];
        let currentSongName = '';

        // Show track names modal
        // Show track names modal (new version for form-based upload)
        function showTrackNamesModal() {
            const modal = document.getElementById('trackNamesModal');

            // Reset form
            document.getElementById('songName').value = '';
            document.getElementById('songArtist').value = '';
            document.getElementById('songTempo').value = '';
            document.getElementById('songKey').value = '';
            document.getElementById('songTimeSignature').value = '';

            // Hide sections that will be shown after ZIP selection
            document.getElementById('trackNamesSection').style.display = 'none';
            document.getElementById('saveSongBtn').style.display = 'none';
            document.getElementById('selectedFileInfo').style.display = 'none';

            modal.style.display = 'flex';
        }

        // Handle ZIP file selection
        async function handleZipFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                console.log(' ZIP file selected:', file.name);

                // Show file info
                const fileInfo = document.getElementById('selectedFileInfo');
                fileInfo.innerHTML = ` Archivo seleccionado: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
                fileInfo.style.display = 'block';

                // Show loading
                showLoading('Descomprimiendo archivo ZIP...');

                // Extract ZIP file
                await extractZipFile(file);

                // Hide loading
                hideLoading();

                // Show track names section
                showTrackNamesSection();

            } catch (error) {
                console.error(' Error processing ZIP file:', error);
                hideLoading();
                alert(' Error al procesar el archivo ZIP: ' + error.message);
            }
        }

        // Extract ZIP file
        async function extractZipFile(zipFile) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        JSZip.loadAsync(e.target.result).then(function (zip) {
                            const files = [];
                            let processedCount = 0;
                            const totalFiles = Object.keys(zip.files).length;

                            if (totalFiles === 0) {
                                reject(new Error('El archivo ZIP est vaco'));
                                return;
                            }

                            Object.keys(zip.files).forEach(function (filename) {
                                const file = zip.files[filename];

                                // Skip directories and non-audio files
                                if (file.dir || !isAudioFile(filename)) {
                                    processedCount++;
                                    if (processedCount === totalFiles) {
                                        if (files.length === 0) {
                                            reject(new Error('No se encontraron archivos de audio en el ZIP'));
                                        } else {
                                            currentExtractedFiles = files;
                                            resolve(files);
                                        }
                                    }
                                    return;
                                }

                                // Extract audio file
                                file.async('blob').then(function (content) {
                                    const audioFile = new File([content], filename, { type: getAudioMimeType(filename) });
                                    files.push(audioFile);

                                    processedCount++;
                                    if (processedCount === totalFiles) {
                                        if (files.length === 0) {
                                            reject(new Error('No se encontraron archivos de audio vlidos en el ZIP'));
                                        } else {
                                            currentExtractedFiles = files;
                                            resolve(files);
                                        }
                                    }
                                }).catch(function (error) {
                                    console.error('Error extracting file:', filename, error);
                                    processedCount++;
                                    if (processedCount === totalFiles) {
                                        if (files.length === 0) {
                                            reject(new Error('Error al extraer archivos del ZIP'));
                                        } else {
                                            currentExtractedFiles = files;
                                            resolve(files);
                                        }
                                    }
                                });
                            });
                        }).catch(function (error) {
                            reject(new Error('Error al leer el archivo ZIP: ' + error.message));
                        });
                    } catch (error) {
                        reject(new Error('Error al procesar el archivo ZIP: ' + error.message));
                    }
                };
                reader.onerror = function () {
                    reject(new Error('Error al leer el archivo'));
                };
                reader.readAsArrayBuffer(zipFile);
            });
        }

        // Check if file is audio
        function isAudioFile(filename) {
            const audioExtensions = ['.mp3', '.wav', '.m4a', '.aac', '.ogg', '.flac'];
            const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            return audioExtensions.includes(ext);
        }

        // Get MIME type for audio file
        function getAudioMimeType(filename) {
            const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            const mimeTypes = {
                '.mp3': 'audio/mpeg',
                '.wav': 'audio/wav',
                '.m4a': 'audio/mp4',
                '.aac': 'audio/aac',
                '.ogg': 'audio/ogg',
                '.flac': 'audio/flac'
            };
            return mimeTypes[ext] || 'audio/mpeg';
        }

        // Show track names section
        function showTrackNamesSection() {
            const trackNamesSection = document.getElementById('trackNamesSection');
            const trackNamesList = document.getElementById('trackNamesList');
            const saveSongBtn = document.getElementById('saveSongBtn');

            // Populate track names
            trackNamesList.innerHTML = '';
            currentExtractedFiles.forEach((file, index) => {
                const trackItem = document.createElement('div');
                trackItem.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 10px; background: #333; border-radius: 6px;';

                const trackName = file.name.replace(/\.[^/.]+$/, ""); // Remove extension

                trackItem.innerHTML = `
                    <div style="color: #888; font-size: 12px; min-width: 30px;">${index + 1}</div>
                    <input type="text" value="${trackName}" data-index="${index}" 
                           style="flex: 1; padding: 8px; border: 1px solid #555; border-radius: 4px; background: #444; color: #fff; font-size: 14px;">
                    <div style="color: #888; font-size: 12px;">${(file.size / 1024 / 1024).toFixed(2)} MB</div>
                `;

                trackNamesList.appendChild(trackItem);
            });

            // Show sections
            trackNamesSection.style.display = 'block';
            saveSongBtn.style.display = 'inline-block';
        }

        // Hide track names modal
        function hideTrackNamesModal() {
            const modal = document.getElementById('trackNamesModal');
            modal.style.display = 'none';
            currentExtractedFiles = [];
        }

        // Show loading indicator for specific song in setlist
        function showSetlistLoading(songId) {
            console.log(' Showing loading indicator for song:', songId);
            const loadingIndicator = document.getElementById(`loading-${songId}`);
            console.log(' Loading indicator element:', loadingIndicator);
            if (loadingIndicator) {
                loadingIndicator.classList.add('loading');
                console.log(' Loading indicator activated for song:', songId);
            } else {
                console.error(' Loading indicator not found for song:', songId);
                console.error(' Expected ID:', `loading-${songId}`);
            }
        }

        // Hide loading indicator for specific song in setlist
        function hideSetlistLoading(songId) {
            console.log(' Hiding loading indicator for song:', songId);
            const loadingIndicator = document.getElementById(`loading-${songId}`);
            console.log(' Loading indicator element:', loadingIndicator);
            if (loadingIndicator) {
                loadingIndicator.classList.remove('loading');
                console.log(' Loading indicator deactivated for song:', songId);
            } else {
                console.error(' Loading indicator not found for song:', songId);
                console.error(' Expected ID:', `loading-${songId}`);
            }
        }

        // Show loading modal
        function showLoading(text = 'Procesando...') {
            const modal = document.getElementById('loadingModal');
            const loadingText = document.getElementById('loadingText');
            const progressContainer = document.getElementById('progressContainer');

            if (modal) {
                modal.style.display = 'flex';
            }

            if (loadingText) {
                loadingText.textContent = text;
            }

            if (progressContainer) {
                progressContainer.style.display = 'none'; // Hide progress bar by default
            }
        }

        // Show loading modal with progress bar
        function showLoadingWithProgress(text = 'Procesando...', total = 0) {
            const modal = document.getElementById('loadingModal');
            const loadingText = document.getElementById('loadingText');
            const progressContainer = document.getElementById('progressContainer');
            const progressText = document.getElementById('progressText');
            const progressDetails = document.getElementById('progressDetails');
            const progressBar = document.getElementById('progressBar');

            if (modal) {
                modal.style.display = 'flex';
            }

            if (loadingText) {
                loadingText.textContent = text;
            }

            if (progressContainer) {
                progressContainer.style.display = 'block';
            }

            if (progressText) {
                progressText.textContent = '0%';
            }

            if (progressDetails) {
                progressDetails.textContent = `0 / ${total}`;
            }

            if (progressBar) {
                progressBar.style.width = '0%';
            }
        }

        // Update progress bar
        function updateProgress(current, total, text = '', fileInfo = {}) {
            const progressText = document.getElementById('progressText');
            const progressDetails = document.getElementById('progressDetails');
            const progressBar = document.getElementById('progressBar');
            const loadingText = document.getElementById('loadingText');

            // Check if elements exist before updating
            if (progressText) {
                const percentage = Math.round((current / total) * 100);
                progressText.textContent = `${percentage}%`;
            }

            if (progressDetails) {
                let detailsText = `${current} / ${total}`;
                if (fileInfo.size) {
                    const sizeMB = (fileInfo.size / 1024 / 1024).toFixed(2);
                    detailsText += ` (${sizeMB}MB)`;
                }
                if (fileInfo.retryCount && fileInfo.retryCount > 0) {
                    detailsText += ` - Reintento ${fileInfo.retryCount}/3`;
                }
                progressDetails.textContent = detailsText;
            }

            if (progressBar) {
                const percentage = Math.round((current / total) * 100);
                progressBar.style.width = `${percentage}%`;
            }

            if (text && loadingText) {
                let displayText = text;
                if (fileInfo.size && fileInfo.size > 100 * 1024 * 1024) { // > 100MB
                    displayText += ` (Archivo grande: ${(fileInfo.size / 1024 / 1024).toFixed(2)}MB - Esto puede tomar varios minutos)`;
                }
                loadingText.textContent = displayText;
            }
        }

        // Update loading progress for cache operations
        function updateLoadingProgress(text, progress) {
            const modal = document.getElementById('loadingModal');
            const loadingText = document.getElementById('loadingText');
            const progressContainer = document.getElementById('progressContainer');
            const progressText = document.getElementById('progressText');
            const progressBar = document.getElementById('progressBar');

            // Ensure modal is shown
            if (modal) {
                modal.style.display = 'flex';
            }

            // Update loading text
            if (loadingText) {
                loadingText.textContent = text;
            }

            // Show and update progress bar
            if (progressContainer) {
                progressContainer.style.display = 'block';
            }

            if (progressText) {
                progressText.textContent = `${progress}%`;
            }

            if (progressBar) {
                progressBar.style.width = `${progress}%`;
            }
        }

        // Hide loading modal
        function hideLoading() {
            const modal = document.getElementById('loadingModal');
            const progressContainer = document.getElementById('progressContainer');

            if (modal) {
                modal.style.display = 'none';
            }
            if (progressContainer) {
                progressContainer.style.display = 'none';
            }
        }

        // Show error message modal
        // Show success notification
        function showSuccessNotification(message, duration = 3000) {
            // Remove existing notification if any
            const existing = document.getElementById('successNotification');
            if (existing) {
                existing.remove();
            }

            const notification = document.createElement('div');
            notification.id = 'successNotification';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(135deg, #34C759 0%, #28A745 100%);
                color: white;
                padding: 16px 24px;
                border-radius: 12px;
                box-shadow: 0 8px 24px rgba(52, 199, 89, 0.4);
                z-index: 10001;
                font-size: 16px;
                font-weight: 600;
                display: flex;
                align-items: center;
                gap: 12px;
                animation: slideInRight 0.3s ease-out;
                max-width: 400px;
            `;

            notification.innerHTML = `
                <span>${message}</span>
            `;

            document.body.appendChild(notification);

            // Auto remove after duration
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.3s ease-out';
                setTimeout(() => {
                    if (notification.parentElement) {
                        notification.remove();
                    }
                }, 300);
            }, duration);
        }

        function showErrorMessage(title, message, details = '') {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;

            modal.innerHTML = `
                <div style="
                    background-color: #1a1a1a;
                    border-radius: 10px;
                    padding: 30px;
                    text-align: center;
                    border: 1px solid #333;
                    max-width: 500px;
                    width: 90vw;
                ">
                    <div style="color: #ff4444; font-size: 48px; margin-bottom: 20px;"></div>
                    <div style="color: #fff; font-size: 20px; font-weight: bold; margin-bottom: 15px;">${title}</div>
                    <div style="color: #ccc; font-size: 16px; margin-bottom: 20px; line-height: 1.5;">${message}</div>
                    ${details ? `<div style="color: #888; font-size: 14px; margin-bottom: 20px; background: #222; padding: 10px; border-radius: 5px; font-family: monospace;">${details}</div>` : ''}
                    <button onclick="this.parentElement.parentElement.remove()" style="
                        padding: 12px 24px;
                        background-color: #007AFF;
                        color: white;
                        border: none;
                        border-radius: 6px;
                        font-size: 14px;
                        cursor: pointer;
                    ">Entendido</button>
                </div>
            `;

            document.body.appendChild(modal);
        }

        // Save song with tracks
        async function saveSongWithTracks() {
            try {
                if (!currentUser) {
                    alert('Debes iniciar sesin para guardar canciones');
                    return;
                }

                // Get form data
                const songName = document.getElementById('songName').value.trim();
                const songArtist = document.getElementById('songArtist').value.trim();
                const songTempo = document.getElementById('songTempo').value;
                const songKey = document.getElementById('songKey').value;
                const songTimeSignature = document.getElementById('songTimeSignature').value;

                // Validate required fields
                if (!songName) {
                    alert('Por favor ingresa un nombre para la cancin');
                    return;
                }

                if (currentExtractedFiles.length === 0) {
                    alert('No hay archivos de audio para guardar');
                    return;
                }

                // Check total song size (sum of all tracks)
                const totalSize = currentExtractedFiles.reduce((sum, file) => sum + file.size, 0);
                const maxTotalSize = 10 * 1024 * 1024 * 1024; // 10GB total limit

                if (totalSize > maxTotalSize) {
                    const errorTitle = 'Cancin Demasiado Grande';
                    const errorMessage = `La cancin completa supera el lmite permitido.`;
                    const errorDetails = `Tamao total: ${(totalSize / 1024 / 1024 / 1024).toFixed(2)} GB\nLmite mximo: 10 GB\nNmero de tracks: ${currentExtractedFiles.length}`;

                    showErrorMessage(errorTitle, errorMessage, errorDetails);
                    return;
                }

                // Check individual track sizes
                const oversizedTracks = currentExtractedFiles.filter(file => file.size > 2 * 1024 * 1024 * 1024);
                if (oversizedTracks.length > 0) {
                    const trackNames = oversizedTracks.map(file => file.name).join(', ');
                    const errorTitle = 'Tracks Demasiado Grandes';
                    const errorMessage = `Algunos tracks superan el lmite individual permitido.`;
                    const errorDetails = `Tracks problemticos: ${trackNames}\nLmite por track: 2 GB`;

                    showErrorMessage(errorTitle, errorMessage, errorDetails);
                    return;
                }

                // Get track names from inputs
                const trackNames = [];
                const trackInputs = document.querySelectorAll('#trackNamesList input[data-index]');
                trackInputs.forEach(input => {
                    const index = parseInt(input.dataset.index);
                    const name = input.value.trim() || `Track ${index + 1}`;
                    trackNames[index] = name;
                });

                // Show progress bar
                showLoadingWithProgress('Subiendo archivos a la nube...', currentExtractedFiles.length);

                // Upload files to B2 and save to Firestore with metadata
                const songData = await uploadSongToCloud(songName, trackNames, currentExtractedFiles, {
                    artist: songArtist,
                    tempo: songTempo ? parseInt(songTempo) : null,
                    key: songKey,
                    timeSignature: songTimeSignature
                });

                if (songData.success) {
                    hideTrackNamesModal();
                    hideLoading();
                    alert(songData.message || 'Cancin guardada exitosamente!');
                    loadLibrarySongs(); // Load updated songs list
                    loadLibrarySongsForSidebar(); // Update sidebar
                } else {
                    hideLoading();
                    alert('Error al guardar la cancin: ' + songData.error);
                }

            } catch (error) {
                hideLoading();

                // Show detailed error message
                const errorTitle = 'Error al Guardar Cancin';
                let errorMessage = 'Ocurri un error inesperado al guardar la cancin.';
                let errorDetails = error.message;

                // Provide more specific error messages
                if (error.message.includes('File too large')) {
                    errorMessage = 'Uno o ms archivos superan el lmite permitido.';
                    errorDetails = 'Lmite por archivo: 2 GB\nLmite total de cancin: 10 GB';
                } else if (error.message.includes('network') || error.message.includes('fetch')) {
                    errorMessage = 'Error de conexin. Verifica tu conexin a internet.';
                    errorDetails = 'Detalles: ' + error.message;
                } else if (error.message.includes('auth') || error.message.includes('permission')) {
                    errorMessage = 'Error de autenticacin. Inicia sesin nuevamente.';
                    errorDetails = 'Detalles: ' + error.message;
                }

                showErrorMessage(errorTitle, errorMessage, errorDetails);
            }
        }

        // Upload song to B2
        async function uploadSongToCloud(songName, trackNames, extractedFiles, metadata = {}) {
            try {
                const userId = currentUser.uid;
                const songId = Date.now().toString();

                // Upload each track file to B2
                const uploadedTracks = [];

                for (let i = 0; i < extractedFiles.length; i++) {
                    const file = extractedFiles[i];
                    const trackName = trackNames[i] || `Track ${i + 1}`;

                    // Update progress with file info
                    updateProgress(i, extractedFiles.length, `Subiendo ${trackName} a B2...`, { size: file.size });

                    console.log(` Uploading track ${i + 1}: ${trackName} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);

                    // Upload to B2 (file is already a valid File object)
                    const uploadResult = await uploadAudioFile(file, userId);
                    if (!uploadResult.success) {
                        throw new Error(`Error al subir ${trackName}: ${uploadResult.error}`);
                    }

                    console.log(` Track ${i + 1} uploaded successfully: ${trackName}`);

                    uploadedTracks.push({
                        name: trackName,
                        fileName: uploadResult.data.fileName,
                        fileId: uploadResult.data.fileId,
                        downloadUrl: uploadResult.data.downloadUrl,
                        size: file.size,
                        type: file.type,
                        storage: 'b2'
                    });
                }

                // Update progress to 100%
                updateProgress(extractedFiles.length, extractedFiles.length, 'Guardando en base de datos...');

                // Save song data to Firestore
                const songData = {
                    userId: userId,
                    songId: songId,
                    name: songName,
                    artist: metadata.artist || '',
                    tempo: metadata.tempo || null,
                    key: metadata.key || '',
                    timeSignature: metadata.timeSignature || '',
                    tracks: uploadedTracks,
                    storage: 'b2',
                    createdAt: new Date(),
                    updatedAt: new Date()
                };

                console.log(' Saving song to Firestore:', songData.name, 'with', songData.tracks.length, 'tracks');
                const docRef = await window.firebase.addDoc(window.firebase.collection(window.firebase.db, 'songs'), songData);
                console.log(' Song saved with ID:', docRef.id);

                return {
                    success: true,
                    data: songData,
                    message: 'Cancin guardada en Backblaze B2'
                };

            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        // Load user's songs
        async function loadUserSongs() {
            if (!currentUser) return;

            try {
                console.log(' Loading user songs for:', currentUser.uid);

                const q = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'songs'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );

                const querySnapshot = await window.firebase.getDocs(q);
                const songs = [];

                console.log(' Query snapshot size:', querySnapshot.size);

                querySnapshot.forEach((doc) => {
                    const songData = {
                        id: doc.id,
                        ...doc.data()
                    };
                    console.log(' Found song:', songData.name, 'with', songData.tracks?.length || 0, 'tracks');
                    songs.push(songData);
                });

                console.log(' Total songs loaded:', songs.length);
                // Note: Songs are now displayed in library tab, not setlist
            } catch (error) {
                console.error('Error loading songs:', error);
            }
        }

        // Update song data in setlist with complete information from Firestore
        async function updateSetlistSongData(songs) {
            console.log(' Updating setlist song data with complete information...');
            const updatedSongs = [];

            for (const song of songs) {
                try {
                    // If song already has complete data, keep it
                    if (song.artist && song.tempo && song.key) {
                        console.log(' Song already has complete data:', song.name);
                        updatedSongs.push(song);
                        continue;
                    }

                    // Get complete data from Firestore
                    const songRef = window.firebase.doc(window.firebase.db, 'songs', song.id);
                    const songSnap = await window.firebase.getDoc(songRef);

                    if (songSnap.exists()) {
                        const fullSongData = songSnap.data();
                        const updatedSong = {
                            ...song,
                            name: fullSongData.name || song.name,
                            artist: fullSongData.artist || song.artist || '',
                            tempo: fullSongData.tempo || song.tempo || null,
                            key: fullSongData.key || song.key || '',
                            timeSignature: fullSongData.timeSignature || song.timeSignature || '',
                            tracks: fullSongData.tracks || song.tracks || []
                        };
                        updatedSongs.push(updatedSong);
                        console.log(' Updated song data:', updatedSong.name, 'Artist:', updatedSong.artist);
                    } else {
                        console.warn(' Song not found in Firestore:', song.id);
                        updatedSongs.push(song);
                    }
                } catch (error) {
                    console.error(' Error updating song data:', song.id, error);
                    updatedSongs.push(song);
                }
            }

            return updatedSongs;
        }

        // Display songs in a specific setlist
        async function displaySongs(songs) {
            console.log(' displaySongs called with:', songs.length, 'songs');
            console.log(' First song data:', songs[0]);

            // Update song data with complete information
            const updatedSongs = await updateSetlistSongData(songs);
            console.log(' Updated songs data:', updatedSongs);

            const songList = document.getElementById('songList');
            if (!songList) return;

            songList.innerHTML = '';

            if (updatedSongs.length === 0) {
                // Show empty state message
                const emptyState = document.createElement('div');
                emptyState.className = 'empty-setlist-state';
                emptyState.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: #888;">
                        <div style="font-size: 48px; margin-bottom: 16px;"></div>
                        <div style="font-size: 16px; font-weight: bold; margin-bottom: 8px; color: #ccc;">Setlist Vaco</div>
                        <div style="font-size: 14px;">Selecciona un setlist para ver sus canciones</div>
                    </div>
                `;
                songList.appendChild(emptyState);
            } else {
                updatedSongs.forEach((song, index) => {
                    console.log(' Displaying song:', song.name, 'Artist:', song.artist, 'Full song data:', song);

                    const songElement = document.createElement('div');
                    songElement.className = 'song-item';
                    songElement.onclick = () => selectAndLoadSong(song.id);
                    songElement.innerHTML = `
                        <div class="song-number">${index + 1}</div>
                        <div class="song-info">
                            <div class="song-title">${song.name} ${song.onlinePlayback ? '' : ''}</div>
                            <div class="song-artist">${song.artist || 'Artista desconocido'}</div>
                            <div class="song-details">
                                <span class="song-tempo">${song.tempo ? song.tempo + ' BPM' : 'BPM N/A'}</span>
                                <span class="song-key">${song.key || 'Key N/A'}</span>
                                <span class="song-time-sig">${song.timeSignature || '4/4'}</span>
                            </div>
                        </div>
                        <div class="song-actions">
                            <div class="song-menu">
                                <button class="menu-btn" onclick="event.stopPropagation(); toggleSongMenu('${song.id}')" title="Opciones"></button>
                                <div class="menu-dropdown" id="menu-${song.id}" style="display: none;">
                                    <button class="menu-item" onclick="removeFromSetlist('${song.id}')" title="Eliminar del setlist"> Eliminar</button>
                                </div>
                            </div>
                        </div>
                    `;
                    songList.appendChild(songElement);
                });
            }
        }

        // Toggle song menu dropdown
        function toggleSongMenu(songId) {
            const menu = document.getElementById(`menu-${songId}`);
            if (menu) {
                // Close all other menus first
                document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                    if (dropdown.id !== `menu-${songId}`) {
                        dropdown.style.display = 'none';
                    }
                });

                // Toggle current menu
                menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Close all menus when clicking outside
        document.addEventListener('click', function (event) {
            if (!event.target.closest('.song-menu')) {
                document.querySelectorAll('.menu-dropdown').forEach(menu => {
                    menu.style.display = 'none';
                });
            }
        });

        // Load a specific song
        async function loadSong(songId, isUserClick = true) {
            try {
                console.log(' loadSong called with ID:', songId, 'isUserClick:', isUserClick);

                // Check if AudioContext is suspended and needs user gesture
                if (audioContext && audioContext.state === 'suspended') {
                    console.log(' AudioContext suspended - showing prompt for user gesture');
                    showAudioContextPrompt();
                    return;
                }

                // Check if song is already loaded and cached
                if (currentLoadedSongId === songId && songCache.has(songId)) {
                    console.log(' Song already loaded and cached, switching instantly:', songId);
                    switchToSong(songId);
                    return;
                }

                // Try to load from memory cache (INSTANT - no blocking needed)
                if (songCache.has(songId)) {
                    console.log(' Loading song from memory cache (instant):', songId);
                    if (loadFromCache(songId)) {
                        // Update LED with song name after loading
                        const cachedSong = songCache.get(songId);
                        updateCurrentSongLedDisplay(cachedSong.songData.name);
                        console.log(' Song loaded from memory cache successfully:', songId);
                        return;
                    } else {
                        console.log(' Failed to load from memory cache, falling back to normal loading:', songId);
                    }
                }

                // Try to load from offline cache (INSTANT - no blocking needed)
                if (isSongCachedOffline(songId)) {
                    console.log(' Loading song from offline cache (instant):', songId);
                    const cacheLoaded = await loadSongFromOfflineCache(songId);
                    if (cacheLoaded) {
                        songLoadingStates.set(songId, 'loaded');
                        updateSongLoadingIndicator(songId, 'loaded');
                        console.log(' Song loaded from offline cache successfully:', songId);
                        return;
                    } else {
                        console.log(' Failed to load from offline cache, falling back to normal loading:', songId);
                    }
                }

                // Check if song is already loading
                const currentState = songLoadingStates.get(songId);
                if (currentState === 'loading') {
                    console.log(' Song is already loading, please wait:', songId);
                    updateSongLoadingIndicator(songId, 'loading');
                    return;
                }

                // For now, disable sequential loading and load directly
                // TODO: Implement proper sequential loading later
                if (isUserClick) {
                    console.log(' User clicked song, loading directly:', songId);
                    await loadSongDirectly(songId);
                    return;
                }

                // If user clicked while auto-loading is happening, add to queue
                if (isAutoLoading && !isUserClick) {
                    console.log(' Auto-loading in progress, adding to queue:', songId);
                    addToLoadingQueue(songId);
                    return;
                }

                // Prevent multiple simultaneous loads
                if (isLoadingSong) {
                    console.log(' Another song is being loaded, adding to queue:', songId);
                    addToLoadingQueue(songId);
                    return;
                }

                isLoadingSong = true;
                songLoadingStates.set(songId, 'loading');
                updateSongLoadingIndicator(songId, 'loading');

                // Pause progressive loading temporarily while user plays this song
                pauseProgressiveLoading();

                // Stop ALL audio completely before loading new song
                console.log(' Stopping ALL audio before loading new song...');
                stopAllAudioSources();

                // Clear everything INCLUDING audio buffers
                tracks = [];
                audioBuffers.clear(); // THIS IS THE KEY - Clear audio buffers

                // Reset state
                currentTime = 0;
                pausedTime = 0;

                // Update UI
                const playBtn = document.getElementById('playBtn');
                if (playBtn) {
                    playBtn.textContent = '';
                    playBtn.classList.remove('active');
                }

                // Stop time update
                stopTimeUpdate();

                console.log(' ALL audio stopped and cleared');

                // Show small loading indicator (no modal)
                showSongLoadingIndicator(songId);

                // Ensure audio context is initialized
                if (!audioContext) {
                    console.log(' Initializing audio context before loading song...');
                    initAudioContext();
                }

                console.log(' Fetching song data from Firestore...');
                const songRef = window.firebase.doc(window.firebase.db, 'songs', songId);
                const songSnap = await window.firebase.getDoc(songRef);

                if (songSnap.exists()) {
                    const songData = songSnap.data();
                    console.log(' Song data retrieved:', songData);
                    console.log(' About to call loadSongTracks...');
                    await loadSongTracks(songData, false); // No modal for user clicks
                    console.log(` Cancin "${songData.name}" cargada con ${songData.tracks.length} tracks`);

                    // Song loaded successfully, ready for playback
                    console.log(' Song loaded and ready for playback');

                    // Display the loaded song in the interface
                    displaySongs([songData]);

                    // Update marquee with loaded song name
                    updateCurrentSongLedDisplay(songData.name);

                    // Save user state (current setlist and song) to Firestore
                    if (currentSetlist) {
                        await saveUserState(currentSetlist, songData);
                    }

                    // Cache the loaded song
                    cacheLoadedSong(songId, songData);

                    // Download for offline use (like Prime/Loop Community)
                    console.log(' Starting offline download for:', songData.name);
                    downloadSongForOffline(songId, songData).then(success => {
                        if (success) {
                            console.log(' Offline download completed:', songData.name);
                            updateSongLoadingIndicator(songId, 'loaded');
                        } else {
                            console.log(' Offline download failed:', songData.name);
                        }
                    });
                } else {
                    console.error(' Song not found in Firestore');
                    alert('Cancin no encontrada');
                }
            } catch (error) {
                console.error(' Error in loadSong:', error);
                console.error(' Error message:', error.message);
                console.error(' Error stack:', error.stack);
                songLoadingStates.set(songId, 'error');
                updateSongLoadingIndicator(songId, 'error');
                alert('Error al cargar la cancin: ' + error.message);
            } finally {
                isLoadingSong = false;

                // Update loading state
                if (songLoadingStates.get(songId) === 'loading') {
                    songLoadingStates.set(songId, 'loaded');
                    updateSongLoadingIndicator(songId, 'loaded');
                }

                console.log(' Hiding loading indicator for song:', songId);
                // Hide small loading indicator
                hideSongLoadingIndicator(songId);

                // Resume progressive loading after a short delay
                setTimeout(() => {
                    resumeProgressiveLoading();
                }, 2000); // 2 second delay to let the song start playing
            }
        }

        // Switch to a song that's already loaded
        function switchToSong(songId) {
            console.log(' Switching to song:', songId);
            currentLoadedSongId = songId;
            currentSelectedSongId = songId;
            updateSongSelection();

            // Update LED display
            const cachedSong = songCache.get(songId);
            if (cachedSong) {
                updateCurrentSongLedDisplay(cachedSong.songData.name);
            }
        }

        // Add song to loading queue
        function addToLoadingQueue(songId) {
            if (!loadingQueue.includes(songId)) {
                loadingQueue.push(songId);
                songLoadingStates.set(songId, 'pending');
                updateSongLoadingIndicator(songId, 'pending');
                console.log(' Added to loading queue:', songId, 'Queue:', loadingQueue);
            }
        }

        // Update visual loading indicator for a song
        function updateSongLoadingIndicator(songId, state) {
            const songElement = document.querySelector(`[data-song-id="${songId}"]`);
            if (!songElement) return;

            // Remove existing loading classes
            songElement.classList.remove('loading', 'loaded', 'error', 'pending');

            // Add new state class
            switch (state) {
                case 'loading':
                    songElement.classList.add('loading');
                    // Show loading spinner
                    const loadingSpinner = songElement.querySelector('.loading-spinner');
                    if (loadingSpinner) loadingSpinner.style.display = 'block';
                    break;
                case 'loaded':
                    songElement.classList.add('loaded');
                    // Hide loading spinner
                    const spinner = songElement.querySelector('.loading-spinner');
                    if (spinner) spinner.style.display = 'none';
                    break;
                case 'error':
                    songElement.classList.add('error');
                    break;
                case 'pending':
                    songElement.classList.add('pending');
                    break;
            }
        }

        // Initialize offline cache system
        function initOfflineCache() {
            console.log(' Initializing offline cache system...');

            // Load cache index from localStorage
            const savedIndex = localStorage.getItem(CACHE_STORAGE_KEY);
            if (savedIndex) {
                try {
                    cacheIndex = JSON.parse(savedIndex);
                    console.log(' Loaded cache index:', cacheIndex.length, 'songs');

                    // Populate offline cache map
                    cacheIndex.forEach(item => {
                        offlineCache.set(item.songId, item);
                    });
                } catch (error) {
                    console.error(' Error loading cache index:', error);
                    cacheIndex = [];
                }
            }

            // Check cache integrity
            checkCacheIntegrity();
        }

        // Check if song is available offline
        function isSongCachedOffline(songId) {
            return offlineCache.has(songId);
        }

        // Download song for offline use
        async function downloadSongForOffline(songId, songData) {
            try {
                console.log(' Downloading song for offline use:', songId);

                // Create cache entry
                const cacheEntry = {
                    songId: songId,
                    songName: songData.name,
                    artist: songData.artist,
                    downloadedAt: new Date().toISOString(),
                    version: songData.version || '1.0',
                    tracks: songData.tracks.map(track => ({
                        name: track.name,
                        localPath: null, // Will be set after download
                        originalUrl: track.downloadUrl || track.originalUrl,
                        fileSize: track.fileSize
                    })),
                    totalSize: songData.tracks.reduce((sum, track) => sum + (track.fileSize || 0), 0)
                };

                // Download each track
                for (let i = 0; i < songData.tracks.length; i++) {
                    const track = songData.tracks[i];
                    const trackUrl = track.downloadUrl || track.originalUrl;

                    if (trackUrl) {
                        console.log(` Downloading track ${i + 1}/${songData.tracks.length}: ${track.name}`);

                        // Download track file
                        const response = await fetch(trackUrl);
                        if (!response.ok) throw new Error(`Failed to download ${track.name}`);

                        const audioData = await response.arrayBuffer();

                        // Store in IndexedDB or localStorage (depending on size)
                        const trackKey = `${CACHE_PREFIX}${songId}_${i}`;

                        if (audioData.byteLength < 50 * 1024 * 1024) { // < 50MB
                            // Store in localStorage as base64
                            const base64Data = btoa(String.fromCharCode(...new Uint8Array(audioData)));
                            localStorage.setItem(trackKey, base64Data);
                            cacheEntry.tracks[i].localPath = 'localStorage';
                            cacheEntry.tracks[i].localKey = trackKey;
                        } else {
                            // For larger files, we'd need IndexedDB (more complex implementation)
                            console.warn(' Track too large for localStorage, using memory cache');
                            cacheEntry.tracks[i].localPath = 'memory';
                        }

                        console.log(` Track downloaded: ${track.name} (${(audioData.byteLength / 1024 / 1024).toFixed(2)}MB)`);
                    }
                }

                // Save to cache
                offlineCache.set(songId, cacheEntry);
                cacheIndex.push(cacheEntry);

                // Persist cache index
                localStorage.setItem(CACHE_STORAGE_KEY, JSON.stringify(cacheIndex));

                console.log(' Song downloaded for offline use:', songData.name);
                return true;

            } catch (error) {
                console.error(' Error downloading song for offline:', error);
                return false;
            }
        }

        // Load song from offline cache
        function loadSongFromOfflineCache(songId) {
            const cacheEntry = offlineCache.get(songId);
            if (!cacheEntry) return false;

            console.log(' Loading song from offline cache:', songId);

            // Load tracks from local storage
            const tracks = cacheEntry.tracks.map((track, index) => {
                const trackObj = {
                    id: index,
                    name: track.name,
                    audioUrl: null, // Will be set from local data
                    localData: null
                };

                if (track.localPath === 'localStorage' && track.localKey) {
                    // Load from localStorage
                    const base64Data = localStorage.getItem(track.localKey);
                    if (base64Data) {
                        // Convert base64 back to ArrayBuffer
                        const binaryString = atob(base64Data);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        trackObj.localData = bytes.buffer;
                        trackObj.audioUrl = 'offline'; // Mark as offline
                    }
                }

                return trackObj;
            });

            // Set tracks and update UI
            window.tracks = tracks;
            updateTracksGrid();

            // Update song info
            updateCurrentSongLedDisplay(cacheEntry.songName);

            console.log(' Song loaded from offline cache');
            return true;
        }

        // Check cache integrity
        function checkCacheIntegrity() {
            console.log(' Checking cache integrity...');

            const validEntries = [];
            let totalSize = 0;

            cacheIndex.forEach(entry => {
                let isValid = true;

                // Check if all tracks are still available
                entry.tracks.forEach(track => {
                    if (track.localPath === 'localStorage' && track.localKey) {
                        if (!localStorage.getItem(track.localKey)) {
                            isValid = false;
                            console.warn(' Missing track in cache:', track.name);
                        }
                    }
                });

                if (isValid) {
                    validEntries.push(entry);
                    totalSize += entry.totalSize || 0;
                } else {
                    console.log(' Removing invalid cache entry:', entry.songName);
                }
            });

            // Update cache with valid entries only
            cacheIndex = validEntries;
            offlineCache.clear();
            validEntries.forEach(entry => {
                offlineCache.set(entry.songId, entry);
            });

            // Save updated cache index
            localStorage.setItem(CACHE_STORAGE_KEY, JSON.stringify(cacheIndex));

            console.log(` Cache integrity check complete: ${validEntries.length} valid entries (${(totalSize / 1024 / 1024).toFixed(2)}MB total)`);
        }

        // Get cache statistics
        function getCacheStats() {
            const totalSongs = cacheIndex.length;
            const totalSize = cacheIndex.reduce((sum, entry) => sum + (entry.totalSize || 0), 0);
            const oldestEntry = cacheIndex.length > 0 ?
                new Date(Math.min(...cacheIndex.map(entry => new Date(entry.downloadedAt).getTime()))) : null;

            return {
                totalSongs,
                totalSizeMB: (totalSize / 1024 / 1024).toFixed(2),
                oldestDownload: oldestEntry?.toLocaleDateString(),
                cacheEntries: cacheIndex
            };
        }

        // Load song from setlist data (for auto-loading)
        async function loadSongFromSetlist(songData) {
            try {
                console.log(' Loading song from setlist:', songData.name);
                console.log(' Song data:', songData);

                // Stop current playback if playing (only if not auto-loading on startup)
                if (isPlaying && !document.hidden) {
                    console.log(' Stopping current playback before loading new song from setlist...');
                    isPlaying = false;
                    stopAllTracks();
                    stopTimeUpdate();

                    // Update UI
                    const playBtn = document.getElementById('playBtn');
                    if (playBtn) {
                        playBtn.textContent = '';
                        playBtn.classList.remove('active');
                    }

                    // Update progress bar
                    const progressBar = document.getElementById('progressBar');
                    if (progressBar) {
                        progressBar.classList.remove('playing');
                    }
                }

                // Use the same loading logic as loadSong but with setlist data
                if (!audioContext) {
                    console.log(' Initializing audio context before loading song...');
                    initAudioContext();
                }

                await loadSongTracks(songData);
                console.log(' Song loaded successfully from setlist');
            } catch (error) {
                console.error(' Error loading song from setlist:', error);
                console.error(' Error details:', error.message);
                console.error(' Error stack:', error.stack);
            }
        }

        // Update setlist display to show current setlist
        function updateSetlistDisplay() {
            if (currentSetlist) {
                console.log(' Updating setlist display for:', currentSetlist.name);

                // Update the setlist tab to show current setlist name
                const setlistTab = document.querySelector('.tab-btn[onclick="switchTab(\'setlist\')"]');
                if (setlistTab) {
                    setlistTab.textContent = ` ${currentSetlist.name}`;
                }

                // Also update the setlist header if it exists
                const setlistHeader = document.querySelector('.setlist-header');
                if (setlistHeader) {
                    const titleElement = setlistHeader.querySelector('h3');
                    if (titleElement) {
                        titleElement.textContent = currentSetlist.name;
                    }
                }
            }
        }

        // Initialize library event listeners
        function initLibrary() {
            // Category buttons
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.addEventListener('click', function () {
                    document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentCategory = this.dataset.category;
                    loadLibraryItems();
                });
            });

            // Search functionality
            const searchInput = document.getElementById('librarySearch');
            if (searchInput) {
                searchInput.addEventListener('input', function () {
                    const searchTerm = this.value.toLowerCase();
                    const items = document.querySelectorAll('.library-item');

                    items.forEach(item => {
                        const name = item.querySelector('.library-item-name').textContent.toLowerCase();
                        const details = item.querySelector('.library-item-details').textContent.toLowerCase();

                        if (name.includes(searchTerm) || details.includes(searchTerm)) {
                            item.style.display = 'flex';
                        } else {
                            item.style.display = 'none';
                        }
                    });
                });
            }
        }

        // Handle auth form submission
        async function handleAuthSubmit(event) {
            event.preventDefault();
            hideAuthError(); // Clear any previous errors

            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const displayName = document.getElementById('displayName').value;
            const isRegisterMode = document.getElementById('displayNameGroup').style.display !== 'none';

            try {
                let result;
                if (isRegisterMode) {
                    result = await registerUser(email, password, displayName);
                } else {
                    result = await signInUser(email, password);
                }

                if (result.success) {
                    hideAuthModal();
                    alert(isRegisterMode ? 'Registro exitoso!' : 'Inicio de sesin exitoso!');
                } else {
                    showAuthError(result.error);
                }
            } catch (error) {
                showAuthError('Error: ' + error.message);
            }
        }

        // Toggle between login and register mode
        function toggleAuthMode() {
            const title = document.getElementById('authTitle');
            const submitBtn = document.getElementById('authSubmit');
            const switchBtn = document.getElementById('authSwitch');
            const displayNameGroup = document.getElementById('displayNameGroup');

            const isRegisterMode = displayNameGroup.style.display !== 'none';

            if (isRegisterMode) {
                // Switch to login mode
                title.textContent = 'Iniciar Sesin';
                submitBtn.textContent = 'Iniciar Sesin';
                switchBtn.textContent = 'No tienes cuenta? Crear una';
                displayNameGroup.style.display = 'none';
            } else {
                // Switch to register mode
                title.textContent = 'Crear Cuenta';
                submitBtn.textContent = 'Crear Cuenta';
                switchBtn.textContent = 'Ya tienes cuenta? Iniciar sesin';
                displayNameGroup.style.display = 'flex';
            }

            hideAuthError();
        }

        // Transport Controls
        function togglePlay() {
            console.log(' Toggle play called - current state:', isPlaying);

            // Check if buffers are still loading
            if (window.songBuffersLoading) {
                console.log(' Buffers still loading - cannot play yet');
                return;
            }

            // Verify all tracks have buffers loaded
            const tracksWithoutBuffers = tracks.filter(track => {
                const trackId = track.id || `track_${tracks.indexOf(track) + 1}`;
                return !audioBuffers.has(trackId) && !audioBuffers.has(track.name);
            });

            if (tracksWithoutBuffers.length > 0) {
                console.log(` ${tracksWithoutBuffers.length} tracks still missing buffers - cannot play yet`);
                console.log('Missing buffers for tracks:', tracksWithoutBuffers.map(t => t.name));
                return;
            }

            isPlaying = !isPlaying;
            const playBtn = document.getElementById('playBtn');
            playBtn.textContent = isPlaying ? '' : '';
            playBtn.classList.toggle('active', isPlaying);

            if (isPlaying) {
                console.log(' Starting playback...');
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                audioStartTime = audioContext.currentTime;
                playAllTracks();
                startTimeUpdate();
                startVUMeters(); // Start VU meters

                // Update progress bar to show it's not seekable during playback
                const progressBar = document.getElementById('progressBar');
                progressBar.classList.add('playing');
            } else {
                console.log(' Pausing playback...');
                pausedTime = currentTime;
                stopAllTracks();
                stopTimeUpdate();
                stopVUMeters(); // Stop VU meters

                // Update progress bar to show it's seekable when paused
                const progressBar = document.getElementById('progressBar');
                progressBar.classList.remove('playing');
            }

            // Drag and drop functionality removed
        }

        function stopPlayback() {
            // Stop all tracks
            stopAllTracks();

            // Reset playback state
            isPlaying = false;
            currentTime = 0;
            pausedTime = 0;

            // Update UI
            const playBtn = document.getElementById('playBtn');
            if (playBtn) {
                playBtn.textContent = '';
                playBtn.classList.remove('active');
            }

            // Update progress bar to show it's seekable when stopped
            const progressBar = document.getElementById('progressBar');
            if (progressBar) {
                progressBar.classList.remove('playing');
            }

            // Stop time update
            stopTimeUpdate();

            // Update time display and progress bar
            updateTimeDisplay();
            updateProgressBar();

            // Drag and drop functionality removed

            console.log(' Playback stopped and reset');
        }

        function toggleLoop() {
            isLooping = !isLooping;
            const loopBtn = document.querySelector('.transport-btn[onclick="toggleLoop()"]');
            loopBtn.classList.toggle('active', isLooping);

            console.log(` Loop ${isLooping ? 'enabled' : 'disabled'}`);
        }

        function updateMasterVolume(value) {
            masterVolume = value / 100; // Convert percentage to 0.0-1.0 range

            // Update all master volume displays
            const masterVolumeElements = document.querySelectorAll('#masterVolumeValue');
            masterVolumeElements.forEach(element => {
                element.textContent = value + '%';
            });

            // Update all track volumes based on current states
            updateTrackVolumes();

            console.log(` Master volume updated to ${value}% (${masterVolume})`);
            console.log(` Available gain nodes:`, Array.from(gainNodes.keys()));
            console.log(` Current tracks:`, tracks.map(t => `${t.id}: vol=${t.volume}, muted=${t.muted}`));
        }

        function hotReload() {
            console.log(' Hot reload initiated...');

            // Stop all audio to prevent issues
            if (isPlaying) {
                stopPlayback();
            }

            // Save current state to localStorage if needed
            if (currentUser) {
                localStorage.setItem('lastUser', JSON.stringify({
                    uid: currentUser.uid,
                    email: currentUser.email,
                    displayName: currentUser.displayName
                }));
            }

            // Show loading message
            const button = event.target;
            const originalText = button.innerHTML;
            button.innerHTML = '';
            button.disabled = true;

            // Reload after a short delay
            setTimeout(() => {
                window.location.reload();
            }, 500);
        }

        function increaseBPM() {
            if (currentBPM < 200) { // Mximo 200 BPM
                currentBPM += 1;
                tempoMultiplier = currentBPM / originalBPM;
                updateBPMDisplay();
                applyTempoChange();
                console.log(` BPM increased to ${currentBPM} (${Math.round(tempoMultiplier * 100)}%)`);
            }
        }

        function decreaseBPM() {
            if (currentBPM > 60) { // Mnimo 60 BPM
                currentBPM -= 1;
                tempoMultiplier = currentBPM / originalBPM;
                updateBPMDisplay();
                applyTempoChange();
                console.log(` BPM decreased to ${currentBPM} (${Math.round(tempoMultiplier * 100)}%)`);
            }
        }

        function resetBPM() {
            currentBPM = originalBPM;
            tempoMultiplier = 1.0;
            updateBPMDisplay();
            applyTempoChange();
            console.log(` BPM reset to original: ${originalBPM}`);
        }

        function updateBPMDisplay() {
            const bpmDisplay = document.getElementById('bpmDisplay');
            if (bpmDisplay) {
                bpmDisplay.textContent = currentBPM + ' BPM';
                console.log(` BPM display updated to: ${currentBPM} BPM`);
            } else {
                console.error(' BPM display element not found');
            }
        }

        function applyTempoChange() {
            // Aplicar cambio de tempo a todos los tracks activos
            if (audioContext && tracks.length > 0) {
                tracks.forEach(track => {
                    if (track.audioUrl && audioSources.has(track.id)) {
                        const source = audioSources.get(track.id);
                        if (source && source.playbackRate !== undefined) {
                            // Solo aplicar tempo, mantener pitch original
                            source.playbackRate.value = tempoMultiplier;
                            console.log(` Applied tempo change to track ${track.id}: ${tempoMultiplier}x (pitch unchanged)`);
                        }
                    }
                });

                // Re-aplicar pitch changes para mantener la separacin
                applyPitchChange();
            }
        }

        function setOriginalBPM(bpm) {
            // Ensure BPM is a valid number
            const validBPM = parseInt(bpm);
            if (isNaN(validBPM) || validBPM <= 0) {
                console.error(' Invalid BPM value:', bpm);
                return;
            }

            originalBPM = validBPM;
            currentBPM = validBPM;
            tempoMultiplier = 1.0;
            updateBPMDisplay();
            console.log(` Original BPM set to ${validBPM} (was ${originalBPM})`);
            console.log(` Current BPM display updated to: ${currentBPM}`);
        }

        // Update BPM from song data with comprehensive validation
        function updateBPMFromSongData(songData) {
            console.log(' Updating BPM from song data...');
            console.log(' Song data tempo field:', songData.tempo);
            console.log(' Song data tempo type:', typeof songData.tempo);

            // Try multiple ways to get the tempo
            let tempo = null;

            // Method 1: Direct tempo field
            if (songData.tempo !== null && songData.tempo !== undefined && songData.tempo > 0) {
                tempo = parseInt(songData.tempo);
                console.log(' Found tempo in songData.tempo:', tempo);
            }

            // Method 2: Check if tempo is in metadata
            if (!tempo && songData.metadata && songData.metadata.tempo) {
                tempo = parseInt(songData.metadata.tempo);
                console.log(' Found tempo in songData.metadata.tempo:', tempo);
            }

            // Method 3: Check if tempo is in song info
            if (!tempo && songData.songInfo && songData.songInfo.tempo) {
                tempo = parseInt(songData.songInfo.tempo);
                console.log(' Found tempo in songData.songInfo.tempo:', tempo);
            }

            if (tempo && !isNaN(tempo) && tempo > 0) {
                console.log(' Setting BPM from song metadata:', tempo);
                setOriginalBPM(tempo);
            } else {
                console.log(' No valid tempo found in song metadata');
                console.log(' Available song data fields:', Object.keys(songData));
                console.log(' Keeping current BPM:', currentBPM);
            }
        }

        function setOriginalKey(key) {
            originalKey = key || 'C';
            currentKey = originalKey;
            keyOffset = 0;
            updateKeyDisplay();
            console.log(` Original Key set to ${originalKey}`);
        }

        function updateKeyDisplay() {
            document.getElementById('keyDisplay').textContent = currentKey;
        }

        function increaseKey() {
            console.log(' increaseKey() called, current keyOffset:', keyOffset);
            if (keyOffset < 12) { // Mximo +12 semitonos (1 octava)
                keyOffset += 1;
                currentKey = getKeyFromOffset(originalKey, keyOffset);
                updateKeyDisplay();
                applyPitchChange();
                console.log(` Key increased to ${currentKey} (+${keyOffset} semitones)`);
            } else {
                console.log(' Key already at maximum (+12 semitones)');
            }
        }

        function decreaseKey() {
            console.log(' decreaseKey() called, current keyOffset:', keyOffset);
            if (keyOffset > -12) { // Mnimo -12 semitonos (1 octava)
                keyOffset -= 1;
                currentKey = getKeyFromOffset(originalKey, keyOffset);
                updateKeyDisplay();
                applyPitchChange();
                console.log(` Key decreased to ${currentKey} (${keyOffset} semitones)`);
            } else {
                console.log(' Key already at minimum (-12 semitones)');
            }
        }

        function resetKey() {
            keyOffset = 0;
            currentKey = originalKey;
            updateKeyDisplay();
            applyPitchChange();
            console.log(` Key reset to original: ${originalKey}`);
        }

        function getKeyFromOffset(baseKey, offset) {
            const keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const baseIndex = keys.indexOf(baseKey);
            if (baseIndex === -1) return baseKey;

            let newIndex = (baseIndex + offset) % 12;
            if (newIndex < 0) newIndex += 12;

            return keys[newIndex];
        }

        // Advanced Pitch Shifting using Web Audio API (preserves tempo)
        function createPitchShifterNode(context, bufferSize = 4096) {
            const pitchShifter = context.createScriptProcessor(bufferSize, 1, 1);
            let inputBuffer = [];
            let outputBuffer = [];
            let readPosition = 0;
            let writePosition = 0;
            let pitchRatio = 1.0;

            pitchShifter.onaudioprocess = function (e) {
                const input = e.inputBuffer.getChannelData(0);
                const output = e.outputBuffer.getChannelData(0);

                // Add input to buffer
                for (let i = 0; i < input.length; i++) {
                    inputBuffer[writePosition] = input[i];
                    writePosition = (writePosition + 1) % bufferSize;
                }

                // Generate output with pitch shifting
                for (let i = 0; i < output.length; i++) {
                    if (pitchRatio === 1.0) {
                        // No pitch change, direct copy
                        output[i] = inputBuffer[(readPosition + i) % bufferSize] || 0;
                    } else {
                        // Pitch shifting using granular synthesis
                        const sourceIndex = (readPosition + i * pitchRatio) % bufferSize;
                        const index1 = Math.floor(sourceIndex);
                        const index2 = (index1 + 1) % bufferSize;
                        const fraction = sourceIndex - index1;

                        const sample1 = inputBuffer[index1] || 0;
                        const sample2 = inputBuffer[index2] || 0;

                        // Linear interpolation
                        output[i] = sample1 + (sample2 - sample1) * fraction;
                    }
                }

                readPosition = (readPosition + output.length) % bufferSize;
            };

            pitchShifter.setPitchRatio = function (ratio) {
                pitchRatio = ratio;
            };

            return pitchShifter;
        }

        function applyPitchChange() {
            console.log(' applyPitchChange() called with keyOffset:', keyOffset);

            if (!audioContext || tracks.length === 0) {
                console.log(' Cannot apply pitch change: audioContext or tracks not available');
                return;
            }

            let appliedCount = 0;
            const pitchRatio = keyOffset === 0 ? 1.0 : Math.pow(2, keyOffset / 12);

            tracks.forEach(track => {
                if (track.audioUrl && audioSources.has(track.id)) {
                    const source = audioSources.get(track.id);
                    if (source) {
                        // Reset playback rate to tempo only (no pitch)
                        source.playbackRate.value = tempoMultiplier;

                        // Apply pitch shifting without affecting tempo
                        if (!source.pitchShifterNode) {
                            // Create pitch shifter node if it doesn't exist
                            source.pitchShifterNode = createPitchShifterNode(audioContext);

                            // Disconnect current connections
                            source.disconnect();

                            // Reconnect through pitch shifter
                            source.connect(source.pitchShifterNode);
                            source.pitchShifterNode.connect(source.gainNode || audioContext.destination);
                        }

                        // Set pitch ratio
                        source.pitchShifterNode.setPitchRatio(pitchRatio);

                        console.log(` Applied pitch shift to track ${track.id}: ${keyOffset} semitones (ratio: ${pitchRatio.toFixed(3)}, tempo: ${tempoMultiplier}x)`);
                        appliedCount++;
                    }
                }
            });

            if (appliedCount === 0) {
                console.log(' No active audio sources found to apply pitch change');
                console.log(' Make sure audio is playing to hear pitch changes');
            } else {
                console.log(` Applied pitch change to ${appliedCount} tracks`);
            }
        }



        function rewind() {
            seekToTime(0);
        }

        // VU Meter functions
        function startVUMeters() {
            if (vuMeterInterval) {
                clearInterval(vuMeterInterval);
            }

            vuMeterInterval = setInterval(updateVUMeters, 50); // Update every 50ms
            console.log(' VU meters started');
        }

        function stopVUMeters() {
            if (vuMeterInterval) {
                clearInterval(vuMeterInterval);
                vuMeterInterval = null;
            }

            // Reset all LED dots to off
            tracks.forEach(track => {
                const ledContainer = document.getElementById(`led-meter-${track.id}`);
                if (ledContainer) {
                    const ledDots = ledContainer.querySelectorAll('.led-dot');
                    ledDots.forEach(dot => {
                        dot.classList.remove('active', 'warning', 'danger');
                    });
                }
            });

            console.log(' LED meters stopped');
        }

        function updateVUMeters() {
            if (!audioContext || analysers.size === 0) return;

            analysers.forEach((analyser, trackId) => {
                // Check if this is a click track
                const track = tracks.find(t => t.id === trackId);
                const trackName = typeof track.name === 'string' ? track.name : (track.name?.name || `Track ${track.id}`);
                const isClickTrack = trackName.toLowerCase().includes('click');

                if (isClickTrack && isPlaying) {
                    // For click tracks, use single LED dot animation
                    updateClickLED(trackId);
                } else {
                    // For regular tracks and guides, use audio analysis
                    const dataArray = new Uint8Array(analyser.frequencyBinCount);
                    analyser.getByteFrequencyData(dataArray);

                    // Calculate RMS (Root Mean Square) for better VU meter representation
                    let sum = 0;
                    for (let i = 0; i < dataArray.length; i++) {
                        sum += dataArray[i] * dataArray[i];
                    }
                    const rms = Math.sqrt(sum / dataArray.length);

                    // Convert to percentage (0-100%)
                    const percentage = Math.min((rms / 128) * 100, 100);

                    // Update LED dots display
                    updateLEDDots(trackId, percentage);
                }
            });
        }

        function updateLEDDots(trackId, percentage) {
            const ledContainer = document.getElementById(`led-meter-${trackId}`);
            if (!ledContainer) return;

            const ledDots = ledContainer.querySelectorAll('.led-dot');
            const activeDots = Math.floor((percentage / 100) * ledDots.length);

            ledDots.forEach((dot, index) => {
                // Remove all classes
                dot.classList.remove('active', 'warning', 'danger');

                // Calculate the reverse index (from bottom to top)
                const reverseIndex = ledDots.length - 1 - index;

                if (reverseIndex < activeDots) {
                    // Determine color based on level (from bottom to top)
                    if (reverseIndex < ledDots.length * 0.6) {
                        // Green for low levels (0-60%)
                        dot.classList.add('active');
                    } else if (reverseIndex < ledDots.length * 0.8) {
                        // Yellow for medium levels (60-80%)
                        dot.classList.add('warning');
                    } else {
                        // Red for high levels (80-100%)
                        dot.classList.add('danger');
                    }
                }
            });
        }

        function updateClickLED(trackId) {
            if (!isPlaying || !currentBPM) return;

            // Calculate beat timing based on current BPM
            const beatsPerSecond = currentBPM / 60;
            const beatInterval = 1000 / beatsPerSecond; // milliseconds per beat

            // Get current time and calculate beat position
            const currentTime = Date.now();
            const beatPosition = (currentTime % beatInterval) / beatInterval;

            // LED indicator removed - no longer needed
        }

        // Song cache functions
        function cacheLoadedSong(songId, songData) {
            console.log(' Caching loaded song:', songId, songData.name);

            // Create a deep copy of the current state
            const cachedSong = {
                songData: JSON.parse(JSON.stringify(songData)),
                tracks: JSON.parse(JSON.stringify(tracks)),
                audioBuffers: new Map(audioBuffers),
                loadedAt: Date.now()
            };

            // Store in cache
            songCache.set(songId, cachedSong);
            currentLoadedSongId = songId;

            console.log(' Song cached successfully:', songId);
            console.log(' Cache size:', songCache.size, 'songs');
        }

        function loadFromCache(songId) {
            if (!songCache.has(songId)) {
                console.log(' Song not found in cache:', songId);
                return false;
            }

            console.log(' Loading song from cache:', songId);

            // Stop ALL current audio sources completely
            stopAllAudioSources();

            const cachedSong = songCache.get(songId);

            // Restore the cached state
            tracks.length = 0; // Clear current tracks
            tracks.push(...cachedSong.tracks);

            // Ensure all tracks are in stopped state
            tracks.forEach(track => {
                track.playing = false;
            });

            // Clear and restore audio buffers
            audioBuffers.clear();
            cachedSong.audioBuffers.forEach((buffer, trackId) => {
                audioBuffers.set(trackId, buffer);
            });

            currentLoadedSongId = songId;

            // Update the UI
            updateTracksGrid();
            displaySongs([cachedSong.songData]);

            // Update current song in LED display
            updateCurrentSongLedDisplay(cachedSong.songData.name);

            console.log(' Song loaded from cache:', songId);
            return true;
        }

        function stopAllAudioSources() {
            console.log(' Stopping ALL audio sources for song isolation');

            // Stop all current audio sources
            audioSources.forEach((source, trackId) => {
                try {
                    if (source && source.stop) {
                        source.stop();
                        console.log(' Stopped audio source for track:', trackId);
                    }
                } catch (error) {
                    console.warn(' Error stopping source for track:', trackId, error);
                }
            });

            // Clear all audio source references
            audioSources.clear();
            gainNodes.clear();
            analysers.clear();

            // Reset playback state
            isPlaying = false;
            const playBtn = document.getElementById('playBtn');
            if (playBtn) {
                playBtn.textContent = '';
                playBtn.classList.remove('active');
            }

            // Stop time update interval
            stopTimeUpdate();

            // Stop VU meters
            stopVUMeters();

            console.log(' All audio sources stopped and cleared');
        }

        function clearSongCache() {
            console.log(' Clearing song cache');
            songCache.clear();
            currentLoadedSongId = null;
        }

        // Digital Console LED Screen Functions
        let currentLedMode = 'main';
        let selectedTrackId = null;
        let selectedColor = '#00FF41';

        function switchLedMode(mode) {
            console.log(' Switching LED mode to:', mode);

            // Hide all modes
            document.querySelectorAll('.led-mode').forEach(modeEl => {
                modeEl.style.display = 'none';
            });

            // Remove active class from all tabs
            document.querySelectorAll('.led-tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected mode
            document.getElementById(mode + 'Mode').style.display = 'block';

            // Add active class to selected tab
            document.querySelector(`[data-mode="${mode}"]`).classList.add('active');

            currentLedMode = mode;

            // Initialize mode-specific content
            if (mode === 'main') {
                // Main mode is always ready, no initialization needed
            } else if (mode === 'eq') {
                initializeEQ();
            } else if (mode === 'edit') {
                initializeEdit();
            } else if (mode === 'analyzer') {
                initializeAnalyzer();
            } else if (mode === 'settings') {
                initializeSettings();
            }
        }

        function initializeEQ() {
            console.log(' Initializing F6 EQ mode');
            drawEQGraph();
            setupEQControls();
        }

        function drawEQGraph() {
            const canvas = document.getElementById('eqCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Set background
            ctx.fillStyle = '#0f0f0f';
            ctx.fillRect(0, 0, width, height);

            // Draw grid
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;

            // Vertical lines (frequency)
            const freqLabels = ['16', '32', '63', '125', '250', '500', '1K', '2K', '4K', '8K', '16K'];
            for (let i = 0; i < freqLabels.length; i++) {
                const x = (i / (freqLabels.length - 1)) * width;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();

                // Draw frequency labels
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(freqLabels[i], x, height - 5);
            }

            // Horizontal lines (gain)
            const gainLabels = ['-18', '-15', '-12', '-9', '-6', '-3', '0', '3', '6', '9', '12', '15', '18'];
            for (let i = 0; i < gainLabels.length; i++) {
                const y = (i / (gainLabels.length - 1)) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();

                // Draw gain labels
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(gainLabels[i], 5, y + 3);
            }

            // Draw EQ curve
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();

            // Band 1: Low-cut at 90Hz
            ctx.moveTo(0, height * 0.6);
            ctx.lineTo(width * 0.15, height * 0.6);
            ctx.lineTo(width * 0.2, height * 0.8);
            ctx.lineTo(width * 0.25, height);

            // Band 2: Bell at 250Hz
            ctx.lineTo(width * 0.25, height * 0.45);
            ctx.lineTo(width * 0.3, height * 0.4);
            ctx.lineTo(width * 0.35, height * 0.45);

            // Band 3: Bell boost at 1kHz
            ctx.lineTo(width * 0.4, height * 0.25);
            ctx.lineTo(width * 0.45, height * 0.2);
            ctx.lineTo(width * 0.5, height * 0.25);

            // Band 4: Bell at 2.5kHz
            ctx.lineTo(width * 0.55, height * 0.45);
            ctx.lineTo(width * 0.6, height * 0.4);
            ctx.lineTo(width * 0.65, height * 0.45);

            // Band 5: Bell at 4kHz
            ctx.lineTo(width * 0.7, height * 0.45);
            ctx.lineTo(width * 0.75, height * 0.4);
            ctx.lineTo(width * 0.8, height * 0.45);

            // Band 6: High-shelf at 5kHz+
            ctx.lineTo(width * 0.8, height * 0.3);
            ctx.lineTo(width * 0.85, height * 0.25);
            ctx.lineTo(width, height * 0.2);

            ctx.stroke();

            // Draw band areas
            // Band 1 area (red)
            ctx.fillStyle = 'rgba(255, 68, 68, 0.3)';
            ctx.beginPath();
            ctx.moveTo(0, height * 0.6);
            ctx.lineTo(width * 0.15, height * 0.6);
            ctx.lineTo(width * 0.2, height * 0.8);
            ctx.lineTo(width * 0.25, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            ctx.fill();

            // Band 3 area (blue)
            ctx.fillStyle = 'rgba(68, 68, 255, 0.3)';
            ctx.beginPath();
            ctx.moveTo(width * 0.4, height * 0.25);
            ctx.lineTo(width * 0.45, height * 0.2);
            ctx.lineTo(width * 0.5, height * 0.25);
            ctx.lineTo(width * 0.5, height);
            ctx.lineTo(width * 0.4, height);
            ctx.closePath();
            ctx.fill();

            // Band 6 area (purple)
            ctx.fillStyle = 'rgba(255, 68, 255, 0.3)';
            ctx.beginPath();
            ctx.moveTo(width * 0.8, height * 0.3);
            ctx.lineTo(width * 0.85, height * 0.25);
            ctx.lineTo(width, height * 0.2);
            ctx.lineTo(width, height);
            ctx.lineTo(width * 0.8, height);
            ctx.closePath();
            ctx.fill();
        }

        function setupEQControls() {
            // Band selection
            document.querySelectorAll('.band-btn').forEach(btn => {
                btn.addEventListener('click', function () {
                    document.querySelectorAll('.band-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.filter-icon').forEach(f => f.classList.remove('active'));

                    this.classList.add('active');
                    const band = this.dataset.band;
                    document.querySelector(`.filter-icon[data-band="${band}"]`).classList.add('active');
                });
            });

            // Knob interactions
            document.querySelectorAll('.knob').forEach(knob => {
                knob.addEventListener('click', function () {
                    const param = this.dataset.param;
                    console.log('Adjusting', param);
                });
            });
        }

        function initializeEdit() {
            console.log(' Initializing Edit mode');
            // Set up color picker
            document.querySelectorAll('.color-option').forEach(option => {
                option.onclick = () => {
                    document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    selectedColor = option.getAttribute('data-color');
                    console.log(' Selected color:', selectedColor);
                };
            });

            // Select first color by default
            document.querySelector('.color-option').classList.add('selected');
        }

        function initializeAnalyzer() {
            console.log(' Initializing Analyzer mode');
            // Analyzer will be implemented in next step
        }

        function initializeSettings() {
            console.log(' Initializing Settings mode');
            // Settings are already connected via HTML
        }

        function adjustEQBand(bandIndex) {
            console.log(' Adjusting EQ band:', bandIndex);
            // EQ adjustment logic will be implemented
        }

        function resetEQ() {
            console.log(' Resetting EQ');
            document.querySelectorAll('.eq-band').forEach(band => {
                band.style.height = '75px';
            });
        }

        function copyEQ() {
            console.log(' Copying EQ settings');
            // Copy EQ logic
        }

        function pasteEQ() {
            console.log(' Pasting EQ settings');
            // Paste EQ logic
        }

        function updateTrackName() {
            const newName = document.getElementById('trackNameInput').value;
            if (!newName || !selectedTrackId) {
                alert('Please select a track and enter a name');
                return;
            }

            console.log(' Updating track name:', selectedTrackId, 'to:', newName);

            // Find and update the track
            const track = tracks.find(t => t.id === selectedTrackId);
            if (track) {
                track.name = newName;
                updateTracksGrid();
                console.log(' Track name updated');
            }
        }

        function updateTrackColor() {
            if (!selectedTrackId) {
                alert('Please select a track first');
                return;
            }

            console.log(' Updating track color:', selectedTrackId, 'to:', selectedColor);

            // Find and update the track color
            const track = tracks.find(t => t.id === selectedTrackId);
            if (track) {
                track.color = selectedColor;
                updateTracksGrid();
                console.log(' Track color updated');
            }
        }


        function updateVUSensitivity(value) {
            document.getElementById('vuSensitivityValue').textContent = value;
            console.log(' VU sensitivity updated to:', value);
        }

        // Track selection for editing
        function selectTrackForEdit(trackId) {
            selectedTrackId = trackId;
            const track = tracks.find(t => t.id === trackId);
            if (track) {
                document.getElementById('trackNameInput').value = track.name;
                console.log(' Track selected for editing:', track.name);
            }
        }

        // Additional function buttons
        function saveEQ() {
            console.log(' Saving EQ settings');
            // Save EQ logic
        }

        function duplicateTrack() {
            if (!selectedTrackId) {
                alert('Please select a track first');
                return;
            }
            console.log(' Duplicating track:', selectedTrackId);
            // Duplicate track logic
        }

        function deleteTrack() {
            if (!selectedTrackId) {
                alert('Please select a track first');
                return;
            }
            if (confirm('Are you sure you want to delete this track?')) {
                console.log(' Deleting track:', selectedTrackId);
                // Delete track logic
            }
        }

        function startAnalyzer() {
            console.log(' Starting analyzer');
            // Start analyzer logic
        }

        function stopAnalyzer() {
            console.log(' Stopping analyzer');
            // Stop analyzer logic
        }

        function freezeAnalyzer() {
            console.log(' Freezing analyzer');
            // Freeze analyzer logic
        }

        function resetAnalyzer() {
            console.log(' Resetting analyzer');
            // Reset analyzer logic
        }

        function saveSettings() {
            console.log(' Saving settings');
            // Save settings logic
        }

        function loadSettings() {
            console.log(' Loading settings');
            // Load settings logic
        }

        function resetSettings() {
            console.log(' Resetting settings');
            // Reset settings logic
        }

        function exportSettings() {
            console.log(' Exporting settings');
            // Export settings logic
        }

        function fastForward() {
            seekToTime(totalTime);
        }

        function toggleLoop() {
            // Loop functionality
            console.log('Loop toggled');
        }

        function record() {
            // Record functionality
            console.log('Recording...');
        }

        function openSettings() {
            alert(' Configuracin\n\n Audio Settings\n MIDI Settings\n Display Settings\n Export Settings');
        }

        // Time Management
        function startTimeUpdate() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
            }

            timeUpdateInterval = setInterval(() => {
                if (isPlaying && totalTime > 0) {
                    // Calculate current time based on audio context time
                    // When resuming from seek, we need to account for the offset
                    const elapsed = audioContext.currentTime - audioStartTime;
                    currentTime = Math.min(elapsed + pausedTime, totalTime);

                    // Debug logging every 5 seconds
                    if (Math.floor(currentTime) % 5 === 0 && Math.floor(currentTime) !== Math.floor(currentTime - 0.1)) {
                        console.log(' Time Debug:', {
                            currentTime: currentTime.toFixed(2),
                            totalTime: totalTime.toFixed(2),
                            audioContextTime: audioContext.currentTime.toFixed(2),
                            audioStartTime: audioStartTime.toFixed(2),
                            pausedTime: pausedTime.toFixed(2),
                            elapsed: elapsed.toFixed(2)
                        });
                    }

                    if (currentTime >= totalTime) {
                        console.log(' Song finished - stopping playback');
                        console.log(' Current time:', currentTime.toFixed(2), 'Total time:', totalTime.toFixed(2));
                        currentTime = totalTime;

                        // Only stop if not looping
                        if (!isLooping) {
                            stopAllTracks();
                            isPlaying = false;
                            document.getElementById('playBtn').textContent = '';
                            document.getElementById('playBtn').classList.remove('active');

                            // Update progress bar to show it's seekable when stopped
                            const progressBar = document.getElementById('progressBar');
                            progressBar.classList.remove('playing');

                            stopTimeUpdate();
                        } else {
                            console.log(' Loop enabled - restarting from beginning');
                            currentTime = 0;
                            pausedTime = 0;
                            audioStartTime = audioContext.currentTime;
                            playAllTracks();
                        }
                    }

                    updateTimeDisplay();
                    updateProgressBar();
                }
            }, 100);
        }

        function stopTimeUpdate() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
                timeUpdateInterval = null;
            }
        }

        function updateTimeDisplay() {
            const currentTimeStr = formatTime(currentTime);
            const totalTimeStr = formatTime(totalTime);
            document.getElementById('currentTime').textContent = currentTimeStr;
            document.getElementById('totalTime').textContent = totalTimeStr;
        }

        function updateProgressBar() {
            if (totalTime > 0) {
                const progress = (currentTime / totalTime) * 100;
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('progressThumb').style.left = progress + '%';
            }
        }

        function seekToTime(seekTime) {
            if (totalTime > 0) {
                currentTime = Math.max(0, Math.min(seekTime, totalTime));
                pausedTime = currentTime;

                // Only update display - no restart during playback
                // Seeking during playback is now blocked in handleProgressBarClick
                updateTimeDisplay();
                updateProgressBar();

                console.log(' Seeked to:', currentTime.toFixed(2), 'seconds (paused only)');
            }
        }

        function handleProgressBarClick(event) {
            if (totalTime > 0) {
                // Only allow seeking when not playing
                if (isPlaying) {
                    console.log(' Cannot seek while playing - pause first');
                    return;
                }

                const progressBar = document.getElementById('progressBar');
                const rect = progressBar.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const percentage = clickX / rect.width;
                const seekTime = percentage * totalTime;

                console.log(' Seeking to:', seekTime, 'seconds (paused)');
                seekToTime(seekTime);
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Track Management
        function generateTracks() {
            // No tracks until a song is loaded
            tracks = [];
            updateTracksGrid();
        }

        function updateTracksGrid() {
            const tracksGrid = document.getElementById('tracksGrid');
            tracksGrid.innerHTML = '';

            if (tracks.length === 0) {
                // Show initial loading state or empty state
                const emptyState = document.createElement('div');
                emptyState.className = 'empty-mixer-state';
                emptyState.style.cssText = `
                    grid-column: 1 / -1;
                    text-align: center;
                    padding: 60px 20px;
                    color: #888;
                `;

                // Show MultiTrack Player Logo when no tracks are loaded
                emptyState.innerHTML = `
                    <img src="./assets/logo.png" alt="MultiTrack Player" style="width: 200px; height: 200px; margin-bottom: 20px; animation: logoPulse 3s ease-in-out infinite;">
                    <div style="font-size: 14px; color: #ccc; margin-top: 12px;">Loading...</div>
                `;
                tracksGrid.appendChild(emptyState);
            } else {
                // Sort tracks: click first, then cues/guides, then others
                const sortedTracks = [...tracks].sort((a, b) => {
                    const aName = typeof a.name === 'string' ? a.name : (a.name?.name || `Track ${a.id}`);
                    const bName = typeof b.name === 'string' ? b.name : (b.name?.name || `Track ${b.id}`);

                    const aPriority = getTrackPriority(aName);
                    const bPriority = getTrackPriority(bName);

                    // Sort by priority (lower number = higher priority)
                    if (aPriority !== bPriority) {
                        return aPriority - bPriority;
                    }

                    // If same priority, maintain original order
                    return 0;
                });

                sortedTracks.forEach(track => {
                    const trackChannel = document.createElement('div');
                    trackChannel.className = 'track-channel';
                    trackChannel.dataset.trackId = track.id;

                    // Ensure track has volume set (default to 0.8 if not set)
                    if (track.volume === undefined || track.volume === null) {
                        track.volume = 0.8;
                    }

                    const volumePercent = Math.round(track.volume * 100);
                    // Ajustar la posicin del fader para que aparezca ms abajo
                    const faderHeight = Math.max(20, track.volume * 100); // Mnimo 20% desde abajo

                    // Ensure track name is a string
                    const trackName = typeof track.name === 'string' ? track.name : (track.name?.name || `Track ${track.id}`);

                    // Check if this is a click/cue track
                    const isClickCue = isClickOrCueTrack(trackName);

                    // Add click-cue class to track channel if it's a click/cue track
                    if (isClickCue) {
                        trackChannel.classList.add('click-cue');
                    }

                    // Add playing class if track is currently playing
                    if (track.playing) {
                        trackChannel.classList.add('playing');
                    }

                    // Check if track has audio buffer loaded
                    const hasBuffer = audioBuffers.has(track.id);

                    trackChannel.innerHTML = `
                        <div class="track-name ${track.muted ? 'muted' : ''} ${track.solo ? 'solo' : ''} ${isClickCue ? 'click-cue' : ''}" title="${trackName}" style="border-color: ${track.color || '#3DA9FC'};">
                            <div class="track-name-text">${trackName}</div>
                        </div>
                        <div class="fader-container">
                            <div class="fader-track">
                                <div class="fader-thumb" style="bottom: ${faderHeight}%;" 
                                     onmousedown="startFaderDrag('${track.id}', event)"></div>
                                <div class="fader-level" style="height: ${faderHeight}%;"></div>
                            </div>
                            ${isClickCue ? `
                                ${trackName.toLowerCase().includes('click') ? `
                                <div class="click-led-container" id="click-led-${track.id}">
                                    <div class="click-led-dot"></div>
                                </div>
                                ` : `
                                <div class="led-meter-container" id="led-meter-${track.id}">
                                    <!-- LED dots will be generated dynamically -->
                                </div>
                                `}
                            ` : `
                            <div class="led-meter-container" id="led-meter-${track.id}">
                                <!-- LED dots will be generated dynamically -->
                            </div>
                            `}
                    </div>
                    <div class="track-controls">
                            <button class="track-control-btn mute-btn ${track.muted ? 'active' : ''}" 
                                    onclick="toggleMute('${track.id}')" title="Mute ${trackName}">M</button>
                            <button class="track-control-btn solo-btn ${track.solo ? 'active' : ''}" 
                                    onclick="toggleSolo('${track.id}')" title="Solo ${trackName}">S</button>
                    </div>
                `;

                    tracksGrid.appendChild(trackChannel);

                    // Create LED dots for non-click tracks (including guides/cues)
                    if (!trackName.toLowerCase().includes('click')) {
                        createLEDDots(track.id);
                    }
                });

                // Drag and drop functionality removed - tracks are now fixed
            }
        }

        function createLEDDots(trackId) {
            const ledContainer = document.getElementById(`led-meter-${trackId}`);
            if (!ledContainer) return;

            // Create 12 LED dots (same height as the slider)
            for (let i = 0; i < 12; i++) {
                const ledDot = document.createElement('div');
                ledDot.className = 'led-dot';
                ledDot.dataset.level = i;
                ledContainer.appendChild(ledDot);
            }
        }

        // Drag and Drop functionality
        // Drag and drop functionality removed - tracks are now fixed

        // Track reordering functionality removed - tracks are now fixed

        // Drag and drop state management removed - tracks are now fixed

        // Track Selection Functions
        let selectedTrackForEdit = null;

        function showTrackSelection() {
            const panel = document.getElementById('trackSelectionPanel');
            const grid = document.getElementById('trackSelectionGrid');

            if (tracks.length === 0) {
                alert('No hay tracks cargados para editar');
                return;
            }

            // Generate track selection buttons
            grid.innerHTML = '';
            tracks.forEach(track => {
                const trackName = typeof track.name === 'string' ? track.name : (track.name?.name || `Track ${track.id}`);
                const button = document.createElement('button');
                button.className = 'track-selection-btn';
                button.textContent = trackName;
                button.onclick = () => selectTrackForEdit(track.id);
                grid.appendChild(button);
            });

            panel.style.display = 'block';
        }

        function selectTrackForEdit(trackId) {
            selectedTrackForEdit = trackId;

            // Update button states
            document.querySelectorAll('.track-selection-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.classList.add('selected');

            // Update edit form with track data
            const track = tracks.find(t => t.id === trackId);
            if (track) {
                const trackName = typeof track.name === 'string' ? track.name : (track.name?.name || `Track ${track.id}`);
                document.getElementById('trackNameInput').value = trackName;

                // Set color picker to track color
                const colorPicker = document.getElementById('colorPicker');
                const colorOptions = colorPicker.querySelectorAll('.color-option');
                colorOptions.forEach(option => {
                    option.classList.remove('selected');
                    if (option.dataset.color === track.color) {
                        option.classList.add('selected');
                    }
                });
            }
        }

        function closeTrackSelection() {
            document.getElementById('trackSelectionPanel').style.display = 'none';
            selectedTrackForEdit = null;
        }

        function applyTrackChanges() {
            if (!selectedTrackForEdit) {
                alert('Por favor selecciona un track primero');
                return;
            }

            const track = tracks.find(t => t.id === selectedTrackForEdit);
            if (!track) {
                alert('Track no encontrado');
                return;
            }

            // Update track name if provided
            const newName = document.getElementById('trackNameInput').value.trim();
            if (newName) {
                track.name = newName;
                console.log(' Track name updated:', newName);
            }

            // Update track color if selected
            const selectedColor = document.querySelector('.color-option.selected');
            if (selectedColor) {
                track.color = selectedColor.dataset.color;
                console.log(' Track color updated:', track.color);
            }

            // Apply changes to the track
            updateTracksGrid();
            closeTrackSelection();
            console.log(' All track changes applied');
        }

        function startFaderDrag(trackId, event) {
            const track = tracks.find(t => t.id === trackId);
            if (!track) return;

            const faderTrack = event.target.parentElement;
            const rect = faderTrack.getBoundingClientRect();

            function updateFader(e) {
                const y = e.clientY - rect.top;
                const percentage = Math.max(0, Math.min(100, 100 - (y / rect.height) * 100));
                track.volume = percentage / 100;

                const thumb = faderTrack.querySelector('.fader-thumb');
                const level = faderTrack.querySelector('.fader-level');
                // Mostrar la posicin real del fader
                thumb.style.bottom = percentage + '%';
                level.style.height = percentage + '%';

                // Update audio volume
                setTrackVolume(trackId, track.volume);
            }

            function stopDrag() {
                document.removeEventListener('mousemove', updateFader);
                document.removeEventListener('mouseup', stopDrag);
            }

            document.addEventListener('mousemove', updateFader);
            document.addEventListener('mouseup', stopDrag);
        }

        function toggleMute(trackId) {
            const track = tracks.find(t => t.id === trackId);
            if (track) {
                track.muted = !track.muted;

                // If mute is activated, deactivate solo
                if (track.muted) {
                    track.solo = false;
                }

                // Update all tracks based on mute and solo states
                updateTrackVolumes();

                const mutedTracks = tracks.filter(t => t.muted);
                console.log(` Mute ${track.muted ? 'ON' : 'OFF'} for track ${trackId} (${track.name})`);
                console.log(` Total muted tracks: ${mutedTracks.length}`);

                updateTracksGrid();
            }
        }

        function toggleSolo(trackId) {
            const track = tracks.find(t => t.id === trackId);
            if (track) {
                track.solo = !track.solo;

                // If solo is activated, deactivate mute
                if (track.solo) {
                    track.muted = false;
                }

                // Update all tracks based on solo states
                updateTrackVolumes();

                const soloTracks = tracks.filter(t => t.solo);
                console.log(` Solo ${track.solo ? 'ON' : 'OFF'} for track ${trackId} (${track.name})`);
                console.log(` Total solo tracks: ${soloTracks.length}`);

                updateTracksGrid();
            }
        }

        // New function to update all track volumes based on solo and mute states
        function updateTrackVolumes() {
            const soloTracks = tracks.filter(t => t.solo);
            const hasSoloTracks = soloTracks.length > 0;

            console.log(` updateTrackVolumes called - masterVolume: ${masterVolume}, hasSoloTracks: ${hasSoloTracks}`);

            tracks.forEach(track => {
                const gainNode = gainNodes.get(track.id);
                if (gainNode) {
                    let shouldPlay = true;

                    // If there are solo tracks, only solo tracks should play
                    if (hasSoloTracks && !track.solo) {
                        shouldPlay = false;
                    }

                    // If track is muted, it shouldn't play
                    if (track.muted) {
                        shouldPlay = false;
                    }

                    if (shouldPlay) {
                        // Play track with original volume
                        const originalVolume = track.volume || 0.8;
                        const finalVolume = originalVolume * masterVolume;
                        gainNode.gain.value = finalVolume;
                        console.log(` Track ${track.id} (${track.name}): volume=${originalVolume}, final=${finalVolume}, shouldPlay=${shouldPlay}`);
                    } else {
                        // Mute track
                        gainNode.gain.value = 0;
                        console.log(` Track ${track.id} (${track.name}): MUTED, shouldPlay=${shouldPlay}`);
                    }
                } else {
                    console.log(` No gain node found for track ${track.id} (${track.name})`);
                }
            });
        }


        // Song Management
        function generateSongs() {
            // Empty setlist - ready for real content
            const songs = [];

            const songList = document.getElementById('songList');
            if (songList) {
                songList.innerHTML = '';
            }

            if (songs.length === 0) {
                // Show empty state message
                const emptyState = document.createElement('div');
                emptyState.className = 'empty-setlist-state';
                emptyState.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: #888;">
                        <div style="font-size: 48px; margin-bottom: 16px;"></div>
                        <div style="font-size: 16px; font-weight: bold; margin-bottom: 8px; color: #ccc;">Setlist Vaco</div>
                        <div style="font-size: 14px;">Agrega canciones desde la biblioteca para crear tu setlist</div>
                    </div>
                `;
                if (songList) {
                    songList.appendChild(emptyState);
                }
            } else {
                songs.forEach(song => {
                    const songItem = document.createElement('div');
                    songItem.className = 'song-item';
                    songItem.innerHTML = `
                        <div class="song-number">${song.number}</div>
                        <div class="song-cover"></div>
                        <div class="song-info">
                            <div class="song-title">${song.title}</div>
                            <div class="song-artist">${song.artist}</div>
                        </div>
                        <div class="song-key">${song.key}</div>
                        <div class="song-bpm">${song.bpm}</div>
                        <div style="font-size: 12px;"></div>
                    `;
                    if (songList) {
                        songList.appendChild(songItem);
                    }
                });
            }
        }

        // Pad Management
        function generatePads() {
            const padNotes = ['Db', 'Eb', 'Gb', 'Ab', 'Bb', 'B', 'C', 'D', 'E', 'F', 'G', 'A'];
            const padsGrid = document.getElementById('padsGrid');

            if (padsGrid) {
                padsGrid.innerHTML = '';

                padNotes.forEach(note => {
                    const padBtn = document.createElement('button');
                    padBtn.className = 'pad-btn';
                    padBtn.textContent = note;
                    padBtn.onclick = () => togglePad(note);
                    padsGrid.appendChild(padBtn);
                });
            }
        }

        // Toggle pad with real celestial string samples
        async function togglePad(note) {
            const pad = event.target;
            const isActive = pad.classList.contains('active');

            if (isActive) {
                // Turn OFF - Stop the pad
                pad.classList.remove('active');
                stopAmbientPad(note);
                console.log(` Pad ${note} deactivated`);
            } else {
                // Turn ON - Start the pad

                // First, stop any other active pad (monophonic mode)
                const allPads = document.querySelectorAll('.pad-btn');
                allPads.forEach(p => {
                    if (p !== pad && p.classList.contains('active')) {
                        p.classList.remove('active');
                    }
                });

                // Stop any currently playing pad
                if (window.currentPadOscillator) {
                    try {
                        window.currentPadOscillator.stop();
                    } catch (e) { }
                    window.currentPadOscillator = null;
                }

                // Activate this pad
                pad.classList.add('active');
                await playAmbientPadSample(note);
                console.log(` Pad ${note} activated`);
            }
        }

        // Play ambient pad with real celestial string samples
        async function playAmbientPadSample(note) {
            try {
                // Initialize Tone.js if not already done
                if (!window.padSampler) {
                    console.log(' Initializing Tone.js Sampler for pads...');

                    // Create a PolySynth with a lush pad sound
                    window.padSampler = new Tone.PolySynth(Tone.Synth, {
                        oscillator: {
                            type: 'sine'
                        },
                        envelope: {
                            attack: 2.0,      // Slow attack for ambient feel
                            decay: 0.5,
                            sustain: 0.8,     // High sustain for pad
                            release: 4.0      // Long release for ambient tail
                        },
                        volume: -10          // Lower volume for ambient background
                    }).toDestination();

                    // Add reverb for celestial ambience
                    const reverb = new Tone.Reverb({
                        decay: 8,            // Long decay for spacious sound
                        wet: 0.7             // 70% wet signal
                    }).toDestination();

                    // Add chorus for richness
                    const chorus = new Tone.Chorus({
                        frequency: 1.5,
                        delayTime: 3.5,
                        depth: 0.7,
                        wet: 0.5
                    }).toDestination();

                    // Connect effects chain
                    window.padSampler.connect(chorus);
                    chorus.connect(reverb);

                    console.log(' Tone.js Sampler initialized with celestial effects');
                }

                // Start Tone.js audio context if needed
                if (Tone.context.state !== 'running') {
                    await Tone.start();
                    console.log(' Tone.js audio context started');
                }

                // Convert note to full note (e.g., "C" -> "C4")
                const fullNote = note.length > 2 ? note : `${note}4`;

                // Play the note with infinite sustain
                window.padSampler.triggerAttack(fullNote);

                // Store the current note
                window.currentPadNote = fullNote;

                console.log(` Playing celestial pad: ${fullNote}`);

            } catch (error) {
                console.error(' Error playing ambient pad:', error);
            }
        }

        // Initialize Web Audio API
        function initAudioContext() {
            console.log(' initAudioContext called');

            try {
                // Create AudioContext but don't start it yet
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log(' AudioContext created, state:', audioContext.state);
                }

                if (audioContext.state === 'suspended') {
                    console.log(' AudioContext is suspended - user gesture required');
                    showAudioContextPrompt();
                } else {
                    console.log(' AudioContext is ready');
                    hideAudioContextPrompt();
                }
            } catch (error) {
                console.error(' Error creating AudioContext:', error);
                showAudioContextPrompt();
            }
        }

        // Resume audio context after user gesture
        async function resumeAudioContext() {
            console.log(' resumeAudioContext called');
            console.log(' audioContext exists:', !!audioContext);
            console.log(' audioContext state:', audioContext?.state);

            try {
                if (audioContext && audioContext.state === 'suspended') {
                    console.log(' Resuming suspended audio context...');
                    await audioContext.resume();
                    console.log(' Audio context resumed successfully');
                    console.log(' New audioContext state:', audioContext.state);
                } else if (!audioContext) {
                    console.log(' Creating new audio context after user gesture...');
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log(' New audio context created');
                    console.log(' New audioContext state:', audioContext.state);
                } else {
                    console.log(' Audio context already running');
                }

                // Initialize audio systems after context is ready
                if (audioContext.state === 'running') {
                    console.log(' Initializing audio systems...');
                    initEQSystem();
                    initToneJS();
                    console.log(' Audio systems initialized');

                    // Listen for state changes
                    audioContext.addEventListener('statechange', () => {
                        console.log(' AudioContext state changed to:', audioContext.state);
                    });

                    // Auto-load first setlist and song after audio is ready
                    setTimeout(() => {
                        autoLoadFirstSetlistAndSong();
                    }, 1000); // Wait 1 second for everything to be ready
                }

                hideAudioContextPrompt();
                return true;

            } catch (error) {
                console.error(' Error with audio context:', error);
                alert('Error al iniciar audio: ' + error.message);
                return false;
            }
        }

        // Show prompt to start audio
        function showAudioContextPrompt() {
            console.log(' showAudioContextPrompt called');
            const prompt = document.getElementById('audioContextPrompt');
            console.log(' prompt element found:', !!prompt);
            if (prompt) {
                prompt.style.display = 'flex';
                console.log(' Audio context prompt shown');
            } else {
                console.error(' audioContextPrompt element not found');
            }
        }

        // Hide audio context prompt
        function hideAudioContextPrompt() {
            console.log(' hideAudioContextPrompt called');
            const prompt = document.getElementById('audioContextPrompt');
            if (prompt) {
                prompt.style.display = 'none';
                console.log(' Audio context prompt hidden');
            }
        }

        // Initialize EQ System (Waves F6 style)
        function initEQSystem() {
            if (!audioContext) return;

            console.log(' Initializing EQ System (F6 style)');

            // Create master EQ nodes
            masterEQNodes = [];
            eqBands.forEach((band, index) => {
                const filter = audioContext.createBiquadFilter();
                filter.type = band.type;
                filter.frequency.value = band.freq;
                filter.gain.value = band.gain;
                filter.Q.value = band.q;

                masterEQNodes.push({
                    filter: filter,
                    band: band,
                    index: index
                });
            });

            // Chain the EQ nodes
            for (let i = 0; i < masterEQNodes.length - 1; i++) {
                masterEQNodes[i].filter.connect(masterEQNodes[i + 1].filter);
            }

            console.log(' EQ System initialized with', masterEQNodes.length, 'bands');
        }

        // Update EQ band parameters
        function updateEQBand(bandIndex, freq, gain, q) {
            if (bandIndex < 0 || bandIndex >= eqBands.length) return;

            const band = eqBands[bandIndex];
            band.freq = Math.max(band.minFreq, Math.min(band.maxFreq, freq));
            band.gain = Math.max(-20, Math.min(20, gain));
            band.q = Math.max(0.1, Math.min(10, q));

            // Update master EQ nodes
            if (masterEQNodes[bandIndex]) {
                const node = masterEQNodes[bandIndex];
                node.filter.frequency.value = band.freq;
                node.filter.gain.value = band.gain;
                node.filter.Q.value = band.q;
            }

            console.log(` Updated EQ Band ${bandIndex + 1}: ${band.freq}Hz, ${band.gain}dB, Q=${band.q}`);
        }

        // Toggle EQ on/off
        function toggleEQ() {
            eqEnabled = !eqEnabled;
            console.log(' EQ', eqEnabled ? 'ENABLED' : 'DISABLED');
        }

        // Reset EQ to flat
        function resetEQ() {
            eqBands.forEach((band, index) => {
                updateEQBand(index, band.freq, 0, band.q);
            });
            console.log(' EQ Reset to flat');
        }

        async function initToneJS() {
            if (typeof Tone !== 'undefined' && !toneInitialized) {
                try {
                    console.log(' Initializing Tone.js...');
                    // Only start Tone.js if we have an active AudioContext
                    if (audioContext && audioContext.state === 'running') {
                        await Tone.start();
                        toneInitialized = true;
                        console.log(' Tone.js initialized successfully');
                    } else {
                        console.log(' Tone.js initialization skipped - AudioContext not ready');
                        toneInitialized = false;
                    }
                } catch (error) {
                    console.warn(' Could not initialize Tone.js:', error);
                    toneInitialized = false;
                }
            } else if (typeof Tone === 'undefined') {
                console.warn(' Tone.js library not loaded');
            }
        }

        // Load audio file from URL with browser cache
        async function loadAudioFile(url, trackId) {
            try {
                console.log(' Loading audio file:', url);
                console.log(' Track ID:', trackId);
                console.log(' Audio context state:', audioContext ? audioContext.state : 'Not initialized');

                // Ensure audio context is initialized
                if (!audioContext) {
                    console.log(' Audio context not initialized, initializing now...');
                    initAudioContext();
                }

                if (!audioContext) {
                    throw new Error('Failed to initialize audio context');
                }

                // Resume audio context if suspended (required for user interaction)
                if (audioContext.state === 'suspended') {
                    console.log(' Audio context suspended, resuming...');
                    await audioContext.resume();
                }

                // Check if audio buffer is already cached
                const cachedBuffer = audioBuffers.get(trackId);

                if (cachedBuffer) {
                    console.log(' Using cached audio buffer for track:', trackId);
                    console.log(' Cache hit! Buffer duration:', cachedBuffer.duration, 'seconds');
                    return cachedBuffer;
                }

                console.log(' Cache miss for track:', trackId, '- loading from URL');

                console.log(' Fetching audio file from URL...');
                const response = await fetch(url, {
                    cache: 'force-cache' // Use browser cache
                });
                console.log(' Fetch response status:', response.status);
                console.log(' Fetch response headers:', response.headers);
                console.log(' Response URL:', response.url);
                console.log(' Response type:', response.type);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                console.log(' Converting response to ArrayBuffer...');
                const arrayBuffer = await response.arrayBuffer();
                console.log(' ArrayBuffer size:', arrayBuffer.byteLength, 'bytes');
                console.log(' ArrayBuffer size in MB:', (arrayBuffer.byteLength / 1024 / 1024).toFixed(2), 'MB');

                if (arrayBuffer.byteLength === 0) {
                    throw new Error('Empty audio file received');
                }

                // Check if file is too small (likely corrupted)
                if (arrayBuffer.byteLength < 1000) {
                    throw new Error(`File too small (${arrayBuffer.byteLength} bytes) - likely corrupted or incomplete upload`);
                }

                // Log first few bytes to check file format
                const uint8Array = new Uint8Array(arrayBuffer.slice(0, 16));
                console.log(' First 16 bytes (hex):', Array.from(uint8Array).map(b => b.toString(16).padStart(2, '0')).join(' '));
                console.log(' First 16 bytes (ascii):', Array.from(uint8Array).map(b => String.fromCharCode(b)).join(''));

                console.log(' Decoding audio data...');
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                console.log(' AudioBuffer duration:', audioBuffer.duration, 'seconds');
                console.log(' AudioBuffer sample rate:', audioBuffer.sampleRate);
                console.log(' AudioBuffer channels:', audioBuffer.numberOfChannels);

                console.log(' Storing audio buffer for track:', trackId);
                audioBuffers.set(trackId, audioBuffer);
                console.log(' Audio buffer stored successfully. Map size:', audioBuffers.size);
                console.log(' Verifying buffer was stored:', audioBuffers.has(trackId));
                console.log(' Audio loaded for track:', trackId);

                return audioBuffer;
            } catch (error) {
                console.error(' Failed to load audio:', error);
                console.error(' Error message:', error.message);
                console.error(' Error stack:', error.stack);
                console.error(' URL was:', url);
                console.error(' Track ID:', trackId);
                return null;
            }
        }

        // Play audio track
        function playTrack(trackId) {
            // Use current time for individual track playback
            playTrackSync(trackId, audioContext.currentTime);
        }

        function playTrackSync(trackId, startTime, offsetTime = 0) {
            try {
                console.log(' Attempting to play track:', trackId, 'at time:', startTime.toFixed(3), 'with offset:', offsetTime.toFixed(3));

                if (!audioContext) {
                    console.error(' Audio context not initialized');
                    return;
                }

                // Resume audio context if suspended (required by browsers)
                if (audioContext.state === 'suspended') {
                    console.log(' Resuming audio context...');
                    audioContext.resume();
                }

                const audioBuffer = audioBuffers.get(trackId);
                if (!audioBuffer) {
                    console.error(' Audio buffer not found for track:', trackId);
                    console.error(' Available buffers:', Array.from(audioBuffers.keys()));
                    return;
                }

                console.log(' Audio buffer found, duration:', audioBuffer.duration.toFixed(3), 'seconds');

                // Stop existing source if playing
                stopTrack(trackId);

                // Create new source with precise timing
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;

                // Ensure the source is ready before scheduling
                if (!source.buffer) {
                    console.error(' Source buffer not properly set for track:', trackId);
                    return;
                }

                // Create gain node for volume control
                const gainNode = audioContext.createGain();

                // Create analyser node for VU meter
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                analyser.smoothingTimeConstant = 0.8;

                // Get track volume (default to 0.8 if not set) and apply master volume
                const track = tracks.find(t => t.id === trackId);
                const trackVolume = track && track.volume !== undefined ? track.volume : 0.8;
                const finalVolume = trackVolume * masterVolume;
                gainNode.gain.value = finalVolume;
                console.log(' Setting track volume to:', trackVolume, 'x master:', masterVolume, '= final:', finalVolume);

                // Create pitch shifter using Tone.js if available
                let pitchShiftNode = null;
                if (typeof Tone !== 'undefined' && toneInitialized) {
                    try {
                        // Create a Tone.js pitch shifter
                        pitchShiftNode = new Tone.PitchShift({
                            pitch: keyOffset,
                            windowSize: 0.1,
                            overlap: 0.5
                        });

                        // Connect the audio chain: source -> pitchShift -> gain -> analyser -> destination
                        source.connect(pitchShiftNode.input);
                        pitchShiftNode.connect(gainNode);
                        gainNode.connect(analyser);

                        console.log(' Created Tone.js pitch shifter for track:', trackId, 'with pitch:', keyOffset);
                    } catch (error) {
                        console.warn(' Could not create Tone.js pitch shifter:', error);
                        // Fallback to direct connection
                        source.connect(gainNode);
                        gainNode.connect(analyser);
                    }
                } else {
                    // Fallback: direct connection without pitch shifting
                    source.connect(gainNode);
                    gainNode.connect(analyser);
                }

                // Connect to destination
                analyser.connect(audioContext.destination);

                // Store references
                audioSources.set(trackId, source);
                gainNodes.set(trackId, gainNode);
                analysers.set(trackId, analyser);
                if (pitchShiftNode) {
                    // Store pitch shifter reference for later updates
                    source.pitchShift = pitchShiftNode;
                }

                // Add event listener to detect when source ends
                source.onended = () => {
                    console.log(' Track ended:', trackId);
                    // Remove from active sources
                    audioSources.delete(trackId);
                    gainNodes.delete(trackId);

                    // Update track playing state
                    const trackObj = tracks.find(t => t.id === trackId);
                    if (trackObj) {
                        trackObj.playing = false;
                        updateTracksGrid(); // Update UI to show stopped state
                    }
                };

                // Start playback at the specified time with precise synchronization
                const currentTime = audioContext.currentTime;
                const timeUntilStart = startTime - currentTime;

                // Validate timing parameters
                if (timeUntilStart < 0) {
                    console.warn(' Start time is in the past, adjusting to immediate start');
                    startTime = currentTime + 0.01; // 10ms in the future
                }

                if (offsetTime > 0) {
                    // Validate offset doesn't exceed buffer duration
                    if (offsetTime >= audioBuffer.duration) {
                        console.warn(' Offset exceeds buffer duration, setting to 0');
                        offsetTime = 0;
                    }
                    source.start(startTime, offsetTime);
                    console.log(' Playing track:', trackId, 'at time:', startTime.toFixed(3), 'from offset:', offsetTime.toFixed(3), 'time until start:', timeUntilStart.toFixed(3));
                } else {
                    source.start(startTime);
                    console.log(' Playing track:', trackId, 'at time:', startTime.toFixed(3), 'from beginning, time until start:', timeUntilStart.toFixed(3));
                }

                console.log(' Audio context state:', audioContext.state, 'current time:', currentTime.toFixed(3));

                // Update track playing state
                if (track) {
                    track.playing = true;
                    updateTracksGrid(); // Update UI to show playing state
                }

            } catch (error) {
                console.error(' Failed to play track:', error);
            }
        }

        // Stop audio track
        function stopTrack(trackId) {
            const source = audioSources.get(trackId);
            if (source) {
                try {
                    source.stop();
                } catch (error) {
                    // Source might already be stopped
                }
                audioSources.delete(trackId);
                console.log(' Stopped track:', trackId);
            }

            // Update track playing state
            const track = tracks.find(t => t.id === trackId);
            if (track) {
                track.playing = false;
                updateTracksGrid(); // Update UI to show stopped state
            }
        }

        // Set track volume
        function setTrackVolume(trackId, volume) {
            const track = tracks.find(t => t.id === trackId);
            if (track) {
                // Update the track's volume property
                track.volume = volume;

                // Update all track volumes based on current states
                updateTrackVolumes();

                console.log(' Volume set for track:', trackId, 'to', volume, 'final volume:', volume * masterVolume);
            }
        }

        // Play all tracks with perfect synchronization
        function playAllTracks() {
            // Check if AudioContext is suspended and needs user gesture
            if (audioContext && audioContext.state === 'suspended') {
                console.log(' AudioContext suspended - showing prompt for user gesture');
                showAudioContextPrompt();
                return;
            }

            console.log(' Playing all tracks - called at time:', audioContext.currentTime.toFixed(3));
            console.log(' Current playback state:', isPlaying);
            console.log(' Available tracks:', tracks.length);
            console.log(' Current loaded song ID:', currentLoadedSongId);
            console.log(' Track details:', tracks.map(t => `${t.id}: ${t.name} (muted: ${t.muted}, hasUrl: ${!!t.audioUrl})`));
            console.log(' Active sources:', audioSources.size);
            console.log(' Paused time (seek position):', pausedTime.toFixed(3));

            // Ensure we only play tracks from the currently loaded song
            if (!currentLoadedSongId) {
                console.log(' No song currently loaded - cannot play tracks');
                return;
            }

            // Check if tracks are already playing to avoid restarting
            const alreadyPlaying = Array.from(audioSources.keys()).length > 0;
            if (alreadyPlaying && isPlaying) {
                console.log(' Tracks already playing - skipping restart');
                return;
            }

            // Get all tracks that need to be played
            const tracksToPlay = tracks.filter(track => track.audioUrl && !track.muted);

            if (tracksToPlay.length === 0) {
                console.log(' No tracks to play');
                return;
            }

            // Verify all buffers are loaded before starting
            const unloadedTracks = tracksToPlay.filter(track => !audioBuffers.has(track.id));
            if (unloadedTracks.length > 0) {
                console.log(' Some tracks not loaded yet:', unloadedTracks.map(t => t.id));
                // Load missing buffers first
                loadMissingBuffers(unloadedTracks).then(() => {
                    console.log(' All buffers loaded, starting synchronized playback');
                    startSynchronizedPlayback(tracksToPlay);
                });
                return;
            }

            // Set totalTime from first audio buffer
            if (tracksToPlay.length > 0 && audioBuffers.has(tracksToPlay[0].id)) {
                const firstBuffer = audioBuffers.get(tracksToPlay[0].id);
                totalTime = firstBuffer.duration;
                console.log(' Total time set to:', totalTime.toFixed(2), 'seconds from first buffer');

                // Update time display immediately
                updateTimeDisplay();
            }

            // All buffers are ready, start synchronized playback
            startSynchronizedPlayback(tracksToPlay);
        }

        // Load missing audio buffers
        async function loadMissingBuffers(tracksToLoad) {
            console.log(' Loading missing buffers for tracks:', tracksToLoad.map(t => t.id));

            const loadPromises = tracksToLoad.map(async (track) => {
                try {
                    const buffer = await loadAudioBuffer(track.audioUrl, track.id);
                    if (buffer) {
                        console.log(' Buffer loaded for track:', track.id, 'duration:', buffer.duration.toFixed(3), 'seconds');
                        return { trackId: track.id, success: true, buffer };
                    } else {
                        console.error(' Failed to load buffer for track:', track.id);
                        return { trackId: track.id, success: false, error: 'Buffer loading failed' };
                    }
                } catch (error) {
                    console.error(' Error loading buffer for track:', track.id, error);
                    return { trackId: track.id, success: false, error: error.message };
                }
            });

            const results = await Promise.all(loadPromises);
            const failedTracks = results.filter(r => !r.success);

            if (failedTracks.length > 0) {
                console.error(' Failed to load some buffers:', failedTracks);
                return false;
            }

            console.log(' All buffers loaded successfully');
            return true;
        }

        // Verify all buffers are ready and valid
        function verifyAllBuffersReady(tracksToPlay) {
            console.log(' Verifying all buffers are ready...');

            for (const track of tracksToPlay) {
                const buffer = audioBuffers.get(track.id);
                if (!buffer) {
                    console.error(' Buffer not found for track:', track.id);
                    return false;
                }

                if (buffer.duration <= 0) {
                    console.error(' Invalid buffer duration for track:', track.id, buffer.duration);
                    return false;
                }

                if (buffer.length === 0) {
                    console.error(' Empty buffer for track:', track.id);
                    return false;
                }

                console.log(' Buffer verified for track:', track.id, 'duration:', buffer.duration.toFixed(3), 'samples:', buffer.length);
            }

            console.log(' All buffers verified and ready');
            return true;
        }

        // Preload all buffers for perfect synchronization
        async function preloadAllBuffersForSync() {
            console.log(' Preloading all buffers for perfect synchronization...');

            const tracksWithAudio = tracks.filter(track => track.audioUrl && !track.muted);

            if (tracksWithAudio.length === 0) {
                console.log(' No tracks with audio to preload');
                return;
            }

            console.log(' Preloading buffers for', tracksWithAudio.length, 'tracks');

            // Verify all buffers are loaded and ready
            const unloadedTracks = tracksWithAudio.filter(track => !audioBuffers.has(track.id));

            if (unloadedTracks.length > 0) {
                console.log(' Loading missing buffers:', unloadedTracks.map(t => t.id));
                const success = await loadMissingBuffers(unloadedTracks);
                if (!success) {
                    console.error(' Failed to load some buffers during preload');
                    return;
                }
            }

            // Final verification
            const allReady = verifyAllBuffersReady(tracksWithAudio);
            if (allReady) {
                console.log(' All buffers preloaded and ready for synchronized playback');
            } else {
                console.error(' Some buffers failed verification during preload');
            }
        }

        // Start all tracks with perfect synchronization
        function startSynchronizedPlayback(tracksToPlay) {
            // First verify all buffers are ready
            if (!verifyAllBuffersReady(tracksToPlay)) {
                console.error(' Cannot start playback - some buffers are not ready');
                return;
            }

            // Calculate a precise common start time for perfect sync
            // Use a longer delay to ensure all tracks are ready and start exactly together
            const syncDelay = 0.1; // 100ms delay for perfect synchronization (reduced for better responsiveness)
            const commonStartTime = audioContext.currentTime + syncDelay;

            // Ensure the start time is not in the past
            const currentTime = audioContext.currentTime;
            if (commonStartTime <= currentTime) {
                console.warn(' Start time is in the past, adjusting to immediate future');
                const adjustedStartTime = currentTime + 0.01; // 10ms in the future
                console.log(' Adjusted start time from', commonStartTime.toFixed(3), 'to', adjustedStartTime.toFixed(3));
                return startSynchronizedPlayback(tracksToPlay); // Retry with adjusted time
            }

            console.log(' Starting synchronized playback at time:', commonStartTime.toFixed(3));
            console.log(' Sync delay:', syncDelay, 'seconds');
            console.log(' Tracks to play:', tracksToPlay.length);
            console.log(' Current audio context time:', audioContext.currentTime.toFixed(3));

            // Start all tracks at exactly the same time
            tracksToPlay.forEach((track, index) => {
                console.log(` Scheduling track ${index + 1}/${tracksToPlay.length}:`, track.id, track.name);
                // Use pausedTime as offset if we're resuming from a seek position
                playTrackSync(track.id, commonStartTime, pausedTime);
            });

            console.log(' All tracks scheduled for synchronized playback');
            console.log(' Expected start time:', commonStartTime.toFixed(3), 'seconds from now');

            // Start time update interval for progress bar
            startTimeUpdate();
            console.log(' Time update started for progress bar');

            // Start VU meters for visual feedback
            startVUMeters();
            console.log(' VU meters started');

            // Schedule a verification check after all tracks should have started
            setTimeout(() => {
                verifySynchronization(tracksToPlay, commonStartTime);
            }, (syncDelay + 0.1) * 1000); // Check 100ms after expected start time
        }

        // Verify that all tracks are synchronized properly
        function verifySynchronization(tracksToPlay, expectedStartTime) {
            console.log(' Verifying synchronization...');
            console.log(' Expected start time:', expectedStartTime.toFixed(3));
            console.log(' Current audio context time:', audioContext.currentTime.toFixed(3));

            const currentTime = audioContext.currentTime;
            const timeSinceStart = currentTime - expectedStartTime;

            console.log(' Time since expected start:', timeSinceStart.toFixed(3), 'seconds');

            // Check if all tracks are actually playing
            const playingTracks = tracksToPlay.filter(track => {
                const source = audioSources.get(track.id);
                return source && source.playbackState !== 'finished';
            });

            console.log(' Tracks that should be playing:', tracksToPlay.length);
            console.log(' Tracks actually playing:', playingTracks.length);

            if (playingTracks.length === tracksToPlay.length) {
                console.log(' All tracks are synchronized and playing correctly');
            } else {
                console.warn(' Synchronization issue detected:', tracksToPlay.length - playingTracks.length, 'tracks not playing');

                // Log which tracks are not playing
                const notPlayingTracks = tracksToPlay.filter(track => {
                    const source = audioSources.get(track.id);
                    return !source || source.playbackState === 'finished';
                });

                console.warn(' Tracks not playing:', notPlayingTracks.map(t => t.id));
            }
        }

        // Stop all tracks
        function stopAllTracks() {
            console.log(' Stopping all tracks');
            stopAllAudioSources();

            // Stop time update interval
            stopTimeUpdate();

            // Update all tracks to not playing state
            tracks.forEach(track => {
                track.playing = false;
            });

            // Update UI to remove playing effects
            updateTracksGrid();
        }

        // Toggle play/pause
        function togglePlay() {
            if (!audioContext) {
                console.error(' Audio context not initialized');
                showAudioContextPrompt();
                return;
            }

            if (audioContext.state === 'suspended') {
                console.log(' AudioContext suspended - showing prompt for user gesture');
                showAudioContextPrompt();
                return;
            }

            const playBtn = document.getElementById('playBtn');

            if (isPlaying) {
                // PAUSE (not stop)
                console.log(' Pausing playback');
                isPlaying = false;

                // Save current time for resume
                pausedTime = currentTime;

                // Stop all audio sources but keep the current time
                stopAllAudioSources();

                // Stop time update
                stopTimeUpdate();

                // Update button
                playBtn.textContent = '';
                playBtn.classList.remove('active');

                // Update tracks UI
                tracks.forEach(track => {
                    track.playing = false;
                });
                updateTracksGrid();

                console.log(' Paused at:', currentTime.toFixed(2), 'seconds');
            } else {
                // PLAY/RESUME
                console.log(' Starting/Resuming playback from:', pausedTime.toFixed(2), 'seconds');
                isPlaying = true;

                // Update button
                playBtn.textContent = '';
                playBtn.classList.add('active');

                // Set audio start time for resume
                audioStartTime = audioContext.currentTime;

                // Play all tracks
                playAllTracks();

                console.log(' Playback started/resumed');
            }
        }

        // Stop playback completely
        function stopPlayback() {
            console.log(' Stopping playback completely');
            isPlaying = false;

            // Stop all tracks
            stopAllTracks();

            // Reset time to beginning
            currentTime = 0;
            pausedTime = 0;
            audioStartTime = 0;

            // Update UI
            const playBtn = document.getElementById('playBtn');
            if (playBtn) {
                playBtn.textContent = '';
                playBtn.classList.remove('active');
            }

            // Update time display
            updateTimeDisplay();
            updateProgressBar();

            console.log(' Playback stopped and reset to beginning');
        }


        // Test audio with a simple tone
        function testAudio() {
            try {
                console.log(' Testing audio with simple tone...');

                if (!audioContext) {
                    console.error(' Audio context not initialized');
                    return;
                }

                // Resume audio context if suspended
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                // Create oscillator for test tone
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // Set frequency and volume
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4 note
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); // Moderate volume

                // Play for 1 second
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 1);

                console.log(' Test tone played for 1 second');

            } catch (error) {
                console.error(' Test audio failed:', error);
            }
        }

        // Test volume levels
        function testVolumeLevels() {
            try {
                console.log(' Testing volume levels...');

                if (!audioContext) {
                    console.error(' Audio context not initialized');
                    return;
                }

                // Resume audio context if suspended
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                // Test different volume levels
                const volumes = [0.1, 0.3, 0.5, 0.8, 1.0];
                let currentIndex = 0;

                function playNextVolume() {
                    if (currentIndex >= volumes.length) {
                        console.log(' Volume test completed');
                        return;
                    }

                    const volume = volumes[currentIndex];
                    console.log(` Testing volume: ${volume}`);

                    // Create oscillator
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    // Set frequency and volume
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);

                    // Play for 0.5 seconds
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.5);

                    currentIndex++;
                    setTimeout(playNextVolume, 600); // Wait 600ms between tests
                }

                playNextVolume();

            } catch (error) {
                console.error(' Volume test failed:', error);
            }
        }

        function debugAudioBuffers() {
            console.log(' === AUDIO BUFFERS DEBUG ===');
            console.log(' Audio context state:', audioContext ? audioContext.state : 'Not initialized');
            console.log(' Total tracks:', tracks.length);
            console.log(' Audio buffers map size:', audioBuffers.size);
            console.log(' Audio sources map size:', audioSources.size);
            console.log(' Gain nodes map size:', gainNodes.size);

            console.log(' Available buffer IDs:', Array.from(audioBuffers.keys()));
            console.log(' Available source IDs:', Array.from(audioSources.keys()));
            console.log(' Available gain node IDs:', Array.from(gainNodes.keys()));

            console.log(' Track details:');
            tracks.forEach(track => {
                const hasBuffer = audioBuffers.has(track.id);
                const hasSource = audioSources.has(track.id);
                const hasGainNode = gainNodes.has(track.id);

                console.log(` Track ${track.id} (${track.name}):`);
                console.log(`  - Buffer: ${hasBuffer ? '' : ''}`);
                console.log(`  - Source: ${hasSource ? '' : ''}`);
                console.log(`  - Gain Node: ${hasGainNode ? '' : ''}`);
                console.log(`  - Playing: ${track.playing ? '' : ''}`);
                console.log(`  - Volume: ${track.volume}`);
                console.log(`  - Audio URL: ${track.audioUrl ? '' : ''}`);
                if (track.audioUrl) {
                    console.log(`  - URL: ${track.audioUrl}`);
                }
            });

            console.log(' === END DEBUG ===');
        }

        // Test B2 URLs accessibility
        async function testB2Urls() {
            console.log(' === TESTING B2 URLs ===');

            if (!tracks || tracks.length === 0) {
                console.log(' No tracks loaded');
                return;
            }

            for (let track of tracks) {
                if (track.audioUrl) {
                    console.log(` Testing URL for track ${track.id} (${track.name}):`);
                    console.log(` URL: ${track.audioUrl}`);

                    try {
                        const response = await fetch(track.audioUrl, { method: 'HEAD' });
                        console.log(` Response status: ${response.status}`);
                        console.log(` Response headers:`, response.headers);

                        if (response.ok) {
                            console.log(` URL accessible for track ${track.id}`);
                        } else {
                            console.log(` URL not accessible for track ${track.id}: ${response.status}`);
                        }
                    } catch (error) {
                        console.log(` Error testing URL for track ${track.id}:`, error.message);
                    }
                } else {
                    console.log(` No URL for track ${track.id} (${track.name})`);
                }
            }

            console.log(' === END B2 URL TEST ===');
        }

        // Reload audio buffers for current tracks
        async function reloadAudioBuffers() {
            console.log(' === RELOADING AUDIO BUFFERS ===');

            if (!tracks || tracks.length === 0) {
                console.log(' No tracks loaded');
                return;
            }

            // Clear existing buffers
            audioBuffers.clear();
            audioSources.clear();
            gainNodes.clear();
            console.log(' Cleared existing audio buffers');

            // Reload each track
            for (let track of tracks) {
                if (track.audioUrl) {
                    console.log(` Reloading buffer for track ${track.id} (${track.name})`);
                    console.log(` URL: ${track.audioUrl}`);

                    try {
                        const audioBuffer = await loadAudioFile(track.audioUrl, track.id);
                        if (audioBuffer) {
                            console.log(` Buffer reloaded for track ${track.id}`);
                        } else {
                            console.error(` Failed to reload buffer for track ${track.id}`);
                        }
                    } catch (error) {
                        console.error(` Error reloading buffer for track ${track.id}:`, error);
                    }
                } else {
                    console.warn(` No URL for track ${track.id} (${track.name})`);
                }
            }

            console.log(' === FINISHED RELOADING BUFFERS ===');
            console.log(' Total buffers loaded:', audioBuffers.size);
            console.log(' Available buffer IDs:', Array.from(audioBuffers.keys()));
        }

        // Check file sizes in B2
        async function checkFileSizes() {
            console.log(' === CHECKING FILE SIZES ===');

            if (!tracks || tracks.length === 0) {
                console.log(' No tracks loaded');
                return;
            }

            for (let track of tracks) {
                if (track.audioUrl) {
                    console.log(` Checking file size for track ${track.id} (${track.name}):`);
                    console.log(` URL: ${track.audioUrl}`);

                    try {
                        const response = await fetch(track.audioUrl, { method: 'HEAD' });
                        console.log(` Response status: ${response.status}`);

                        if (response.ok) {
                            const contentLength = response.headers.get('content-length');
                            const contentType = response.headers.get('content-type');

                            console.log(` Content-Length: ${contentLength} bytes`);
                            console.log(` Content-Type: ${contentType}`);

                            if (contentLength) {
                                const sizeKB = Math.round(parseInt(contentLength) / 1024);
                                const sizeMB = Math.round(parseInt(contentLength) / 1024 / 1024 * 100) / 100;

                                console.log(` Size: ${sizeKB} KB (${sizeMB} MB)`);

                                if (parseInt(contentLength) < 1000) {
                                    console.log(` File too small - likely corrupted!`);
                                } else if (parseInt(contentLength) < 10000) {
                                    console.log(` File very small - might be corrupted`);
                                } else {
                                    console.log(` File size looks normal`);
                                }
                            } else {
                                console.log(` No Content-Length header`);
                            }
                        } else {
                            console.log(` File not accessible: ${response.status}`);
                        }
                    } catch (error) {
                        console.log(` Error checking file size:`, error.message);
                    }
                } else {
                    console.log(` No URL for track ${track.id} (${track.name})`);
                }
            }

            console.log(' === END FILE SIZE CHECK ===');
        }

        // Test single audio file decoding
        async function testSingleAudioFile() {
            console.log(' === TESTING SINGLE AUDIO FILE ===');

            if (!tracks || tracks.length === 0) {
                console.log(' No tracks loaded');
                return;
            }

            // Test the first track with an audio URL
            const testTrack = tracks.find(track => track.audioUrl);
            if (!testTrack) {
                console.log(' No track with audio URL found');
                return;
            }

            console.log(` Testing track ${testTrack.id} (${testTrack.name})`);
            console.log(` URL: ${testTrack.audioUrl}`);

            try {
                console.log(' Step 1: Fetching file...');
                const response = await fetch(testTrack.audioUrl);
                console.log(' Fetch status:', response.status);
                console.log(' Content-Type:', response.headers.get('content-type'));
                console.log(' Content-Length:', response.headers.get('content-length'));

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                console.log(' Step 2: Converting to ArrayBuffer...');
                const arrayBuffer = await response.arrayBuffer();
                console.log(' ArrayBuffer size:', arrayBuffer.byteLength, 'bytes');
                console.log(' ArrayBuffer size in MB:', (arrayBuffer.byteLength / 1024 / 1024).toFixed(2), 'MB');

                // Check file format
                const uint8Array = new Uint8Array(arrayBuffer.slice(0, 16));
                console.log(' First 16 bytes (hex):', Array.from(uint8Array).map(b => b.toString(16).padStart(2, '0')).join(' '));
                console.log(' First 16 bytes (ascii):', Array.from(uint8Array).map(b => String.fromCharCode(b)).join(''));

                // Check if it's a WAV file
                const header = String.fromCharCode(...uint8Array.slice(0, 4));
                console.log(' File header:', header);

                if (header === 'RIFF') {
                    console.log(' File appears to be a WAV file (RIFF header)');
                } else {
                    console.log(' File does not appear to be a WAV file');
                }

                console.log(' Step 3: Decoding audio data...');
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                console.log(' Audio decoded successfully!');
                console.log(' Duration:', audioBuffer.duration, 'seconds');
                console.log(' Sample rate:', audioBuffer.sampleRate, 'Hz');
                console.log(' Channels:', audioBuffer.numberOfChannels);
                console.log(' Length:', audioBuffer.length, 'samples');

            } catch (error) {
                console.error(' Error testing audio file:', error);
                console.error(' Error message:', error.message);
                console.error(' Error name:', error.name);

                if (error.name === 'EncodingError') {
                    console.error(' This is an encoding error - the file format might not be supported');
                }
            }

            console.log(' === END SINGLE AUDIO FILE TEST ===');
        }

        function debugTimeSync() {
            console.log(' === TIME SYNCHRONIZATION DEBUG ===');
            console.log(' Current time:', currentTime.toFixed(2), 'seconds');
            console.log(' Total time:', totalTime.toFixed(2), 'seconds');
            console.log(' Audio context time:', audioContext ? audioContext.currentTime.toFixed(2) : 'Not available');
            console.log(' Audio start time:', audioStartTime.toFixed(2));
            console.log(' Paused time:', pausedTime.toFixed(2));
            console.log(' Is playing:', isPlaying);

            console.log(' Track durations:');
            tracks.forEach(track => {
                const buffer = audioBuffers.get(track.id);
                if (buffer) {
                    console.log(` Track ${track.id} (${track.name}): ${buffer.duration.toFixed(2)}s (${formatTime(buffer.duration)})`);
                }
            });

            console.log(' === END TIME DEBUG ===');
        }

        function debugPlaybackState() {
            console.log(' === PLAYBACK STATE DEBUG ===');
            console.log(' Is playing:', isPlaying);
            console.log(' Current time:', currentTime.toFixed(2));
            console.log(' Total time:', totalTime.toFixed(2));
            console.log(' Audio context time:', audioContext ? audioContext.currentTime.toFixed(2) : 'Not available');
            console.log(' Audio start time:', audioStartTime.toFixed(2));
            console.log(' Paused time:', pausedTime.toFixed(2));
            console.log(' Is looping:', isLooping);
            console.log(' Active audio sources:', audioSources.size);
            console.log(' Active gain nodes:', gainNodes.size);
            console.log(' Time update interval:', timeUpdateInterval ? 'Running' : 'Stopped');

            console.log(' Track states:');
            tracks.forEach(track => {
                const hasSource = audioSources.has(track.id);
                const hasGainNode = gainNodes.has(track.id);
                console.log(` Track ${track.id} (${track.name}): playing=${track.playing}, hasSource=${hasSource}, hasGainNode=${hasGainNode}, muted=${track.muted}`);
            });

            console.log(' === END PLAYBACK DEBUG ===');
        }

        // Check if a track is a click or cue track
        function isClickOrCueTrack(trackName) {
            if (!trackName) return false;

            // Normalize the name by removing accents and converting to lowercase
            const normalizedName = trackName.toLowerCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '') // Remove accents
                .trim();

            const clickCueKeywords = ['click', 'clicks', 'cue', 'cues', 'guide', 'guia', 'guides'];

            return clickCueKeywords.some(keyword => normalizedName.includes(keyword));
        }

        // Get track priority for ordering (lower number = higher priority)
        function getTrackPriority(trackName) {
            if (!trackName) return 3;

            // Normalize the name by removing accents and converting to lowercase
            const normalizedName = trackName.toLowerCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '') // Remove accents
                .trim();

            // Priority 1: Click tracks
            if (normalizedName.includes('click') || normalizedName.includes('clicks')) {
                return 1;
            }

            // Priority 2: Cue/Guide tracks
            if (normalizedName.includes('cue') || normalizedName.includes('cues') ||
                normalizedName.includes('guide') || normalizedName.includes('guia') ||
                normalizedName.includes('guides')) {
                return 2;
            }

            // Priority 3: All other tracks
            return 3;
        }

        function testSeek() {
            console.log(' === SEEK TEST ===');
            console.log(' Current time:', currentTime.toFixed(2));
            console.log(' Total time:', totalTime.toFixed(2));
            console.log(' Paused time:', pausedTime.toFixed(2));
            console.log(' Is playing:', isPlaying);

            if (totalTime > 0) {
                // Test seek to 50% of the song
                const testSeekTime = totalTime * 0.5;
                console.log(' Testing seek to:', testSeekTime.toFixed(2), 'seconds (50% of song)');
                seekToTime(testSeekTime);
            } else {
                console.log(' No song loaded - cannot test seek');
            }

            console.log(' === END SEEK TEST ===');
        }

        function testClickCueDetection() {
            console.log(' === CLICK/CUE DETECTION TEST ===');

            const testNames = [
                'Click',
                'Clicks',
                'Cue',
                'Cues',
                'Guide',
                'Gua',
                'Guia',
                'Guides',
                'Guas',
                'Guias',
                'Click Track',
                'Cue Track',
                'Guide Track',
                'Gua Track',
                'Guia Track',
                'Bass',
                'Drums',
                'Guitar',
                'Vocals'
            ];

            console.log(' Testing track name detection:');
            testNames.forEach(name => {
                const isClickCue = isClickOrCueTrack(name);
                console.log(` "${name}" -> ${isClickCue ? ' Click/Cue' : ' Regular'}`);
            });

            console.log(' Current tracks:');
            tracks.forEach(track => {
                const trackName = typeof track.name === 'string' ? track.name : (track.name?.name || `Track ${track.id}`);
                const isClickCue = isClickOrCueTrack(trackName);
                console.log(` Track ${track.id}: "${trackName}" -> ${isClickCue ? ' Click/Cue' : ' Regular'}`);
            });

            console.log(' === END CLICK/CUE TEST ===');
        }

        // Toggle debug buttons visibility (for developers)
        function toggleDebugButtons() {
            const debugButtons = document.querySelectorAll('.test-b2-btn[style*="display: none"], .settings-btn[style*="display: none"]');
            const isHidden = debugButtons[0] && debugButtons[0].style.display === 'none';

            debugButtons.forEach(btn => {
                btn.style.display = isHidden ? 'inline-block' : 'none';
            });

            console.log(` Debug buttons ${isHidden ? 'shown' : 'hidden'}`);
        }

        // Load user state from Firestore (last setlist and song)
        async function loadUserState() {
            try {
                if (!currentUser) {
                    console.log(' No user logged in, cannot load user state');
                    return null;
                }

                console.log(' Loading user state from Firestore for user:', currentUser.uid);
                const userStateRef = window.firebase.doc(window.firebase.db, 'userStates', currentUser.uid);
                const userStateSnap = await window.firebase.getDoc(userStateRef);

                if (userStateSnap.exists()) {
                    const userState = userStateSnap.data();
                    console.log(' User state loaded:', userState);
                    return userState;
                } else {
                    console.log(' No user state found in Firestore');
                    return null;
                }
            } catch (error) {
                console.error(' Error loading user state:', error);
                return null;
            }
        }

        // Save user state to Firestore (last setlist and song)
        async function saveUserState(setlist, song) {
            try {
                if (!currentUser) {
                    console.log(' No user logged in, cannot save user state');
                    return;
                }

                const userState = {
                    userId: currentUser.uid,
                    lastSetlist: setlist ? {
                        id: setlist.id,
                        name: setlist.name,
                        songs: setlist.songs
                    } : null,
                    lastSong: song ? {
                        id: song.id,
                        name: song.name,
                        artist: song.artist,
                        tempo: song.tempo,
                        key: song.key,
                        timeSignature: song.timeSignature
                    } : null,
                    lastUpdated: new Date()
                };

                console.log(' Saving user state to Firestore:', userState);
                const userStateRef = window.firebase.doc(window.firebase.db, 'userStates', currentUser.uid);
                await window.firebase.setDoc(userStateRef, userState);
                console.log(' User state saved successfully');
            } catch (error) {
                console.error(' Error saving user state:', error);
            }
        }

        // Load last used setlist from localStorage (fallback)
        function loadLastUsedSetlist() {
            try {
                const lastSetlistData = localStorage.getItem('lastUsedSetlist');
                if (lastSetlistData) {
                    lastUsedSetlist = JSON.parse(lastSetlistData);
                    console.log(' Last used setlist loaded from localStorage:', lastUsedSetlist.name);
                    return lastUsedSetlist;
                }
            } catch (error) {
                console.error(' Error loading last used setlist from localStorage:', error);
            }
            return null;
        }

        // Save current setlist as last used (fallback to localStorage)
        function saveLastUsedSetlist(setlist) {
            try {
                lastUsedSetlist = setlist;
                localStorage.setItem('lastUsedSetlist', JSON.stringify(setlist));
                console.log(' Last used setlist saved to localStorage:', setlist.name);

                // Also save to Firestore if user is logged in
                if (currentUser) {
                    saveUserState(setlist, null);
                }
            } catch (error) {
                console.error(' Error saving last used setlist:', error);
            }
        }

        // Save setlist to Firebase
        async function saveSetlistToFirebase(setlist) {
            try {
                if (!currentUser) {
                    throw new Error('User not logged in');
                }

                if (!setlist || !setlist.id) {
                    throw new Error('Invalid setlist data');
                }

                console.log(' Saving setlist to Firebase:', setlist.name);

                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlist.id);

                await window.firebase.updateDoc(setlistRef, {
                    songs: setlist.songs,
                    updatedAt: new Date()
                });

                console.log(' Setlist saved to Firebase successfully');

            } catch (error) {
                console.error(' Error saving setlist to Firebase:', error);
                throw error;
            }
        }

        // Show initial loading screen
        function showInitialLoadingScreen() {
            console.log(' Judith 1.0 - Mostrando pantalla de carga inicial...');

            // Create initial loading overlay
            const loadingOverlay = document.createElement('div');
            loadingOverlay.id = 'initialLoadingOverlay';
            loadingOverlay.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
                display: flex !important;
                flex-direction: column !important;
                justify-content: center !important;
                align-items: center !important;
                z-index: 999999 !important;
                color: white !important;
                font-family: Arial, sans-serif !important;
                text-align: center !important;
                margin: 0 !important;
                padding: 0 !important;
                border: none !important;
            `;

            const title = document.createElement('img');
            title.src = './assets/logo.png';
            title.alt = 'MultiTrack Player';
            title.style.cssText = `
                width: 120px;
                height: 120px;
                margin-bottom: 20px;
                animation: pulse 2s infinite;
                filter: drop-shadow(0 0 30px #007AFF);
            `;

            const subtitle = document.createElement('div');
            subtitle.style.cssText = `
                font-size: 28px;
                color: #ccc;
                margin-bottom: 40px;
                font-weight: 300;
            `;
            subtitle.textContent = 'Sistema de Audio Multitrack';

            const loadingText = document.createElement('div');
            loadingText.style.cssText = `
                font-size: 18px;
                color: #888;
                margin-top: 20px;
            `;
            loadingText.textContent = 'Inicializando sistema...';

            // Add CSS animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes pulse {
                    0% { transform: scale(1); opacity: 1; }
                    50% { transform: scale(1.05); opacity: 0.8; }
                    100% { transform: scale(1); opacity: 1; }
                }
            `;
            document.head.appendChild(style);

            loadingOverlay.appendChild(title);
            loadingOverlay.appendChild(subtitle);
            loadingOverlay.appendChild(loadingText);

            document.body.appendChild(loadingOverlay);

            // Remove overlay after 3 seconds
            setTimeout(() => {
                if (loadingOverlay && loadingOverlay.parentNode) {
                    loadingOverlay.parentNode.removeChild(loadingOverlay);
                }
                console.log(' Judith 1.0 - Pantalla de carga inicial completada');
            }, 3000);
        }

        // Show countdown message after login
        function showCountdownMessage() {
            console.log(' Judith 1.0 - Iniciando sistema...');

            // Check if overlay already exists
            const existingOverlay = document.getElementById('countdownOverlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }

            // Create countdown overlay
            const countdownOverlay = document.createElement('div');
            countdownOverlay.id = 'countdownOverlay';
            countdownOverlay.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                background: rgba(0, 0, 0, 0.95) !important;
                display: flex !important;
                flex-direction: column !important;
                justify-content: center !important;
                align-items: center !important;
                z-index: 999999 !important;
                color: white !important;
                font-family: Arial, sans-serif !important;
                text-align: center !important;
                margin: 0 !important;
                padding: 0 !important;
                border: none !important;
            `;

            const title = document.createElement('img');
            title.src = './assets/logo.png';
            title.alt = 'MultiTrack Player';
            title.style.cssText = `
                width: 80px;
                height: 80px;
                margin-bottom: 20px;
                filter: drop-shadow(0 0 20px #007AFF);
            `;

            const subtitle = document.createElement('div');
            subtitle.style.cssText = `
                font-size: 24px;
                color: #ccc;
                margin-bottom: 40px;
            `;
            subtitle.textContent = 'Sistema de Audio Multitrack';

            const countdown = document.createElement('div');
            countdown.style.cssText = `
                font-size: 72px;
                font-weight: bold;
                color: #4CAF50;
                text-shadow: 0 0 30px #4CAF50;
                margin-bottom: 20px;
            `;

            const status = document.createElement('div');
            status.style.cssText = `
                font-size: 18px;
                color: #888;
            `;
            status.textContent = 'Cargando sistema...';

            countdownOverlay.appendChild(title);
            countdownOverlay.appendChild(subtitle);
            countdownOverlay.appendChild(countdown);
            countdownOverlay.appendChild(status);

            document.body.appendChild(countdownOverlay);

            // Countdown sequence
            let count = 3;
            const countdownInterval = setInterval(() => {
                if (count > 0) {
                    countdown.textContent = count;
                    countdown.style.color = count === 3 ? '#FF5722' : count === 2 ? '#FF9800' : '#4CAF50';
                    countdown.style.textShadow = `0 0 30px ${countdown.style.color}`;
                    status.textContent = `Lista en ${count}...`;
                    count--;
                } else {
                    countdown.textContent = 'LISTA!';
                    countdown.style.color = '#4CAF50';
                    countdown.style.textShadow = '0 0 30px #4CAF50';
                    status.textContent = 'Sistema cargado y listo';

                    // Remove overlay after a short delay
                    setTimeout(() => {
                        if (countdownOverlay && countdownOverlay.parentNode) {
                            countdownOverlay.parentNode.removeChild(countdownOverlay);
                        }
                        console.log(' Judith 1.0 - Sistema listo!');
                    }, 1000);

                    clearInterval(countdownInterval);
                }
            }, 1000);
        }

        // Load first available setlist
        async function loadFirstAvailableSetlist() {
            try {
                console.log(' LOAD-FIRST - Loading first available setlist...');
                console.log(' LOAD-FIRST - Current user:', currentUser ? currentUser.uid : 'No user');
                console.log(' LOAD-FIRST - Firebase object:', window.firebase);
                console.log(' LOAD-FIRST - Firebase db:', window.firebase?.db);

                if (!currentUser) {
                    console.log(' LOAD-FIRST - No user logged in');
                    return;
                }

                if (!window.firebase || !window.firebase.db) {
                    console.log(' LOAD-FIRST - Firebase not initialized');
                    return;
                }

                console.log(' LOAD-FIRST - Querying setlists from Firestore...');
                const setlistsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'setlists'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );

                console.log(' LOAD-FIRST - Query created, getting docs...');
                const querySnapshot = await window.firebase.getDocs(setlistsQuery);
                const setlists = [];

                console.log(' LOAD-FIRST - Query result:', querySnapshot.size, 'setlists found');

                querySnapshot.forEach((doc) => {
                    const setlistData = { id: doc.id, ...doc.data() };
                    console.log(' LOAD-FIRST - Found setlist:', setlistData.name, 'with', setlistData.songs?.length || 0, 'songs');
                    setlists.push(setlistData);
                });

                // Sort setlists by creation date (oldest first)
                setlists.sort((a, b) => {
                    const dateA = a.createdAt?.toDate ? a.createdAt.toDate() : new Date(a.createdAt);
                    const dateB = b.createdAt?.toDate ? b.createdAt.toDate() : new Date(b.createdAt);
                    return dateA - dateB; // Oldest first
                });

                if (setlists.length > 0) {
                    const firstSetlist = setlists[0]; // This will now be the oldest setlist
                    console.log(' LOAD-FIRST - Loading first setlist in sidebar:', firstSetlist.name);
                    console.log(' LOAD-FIRST - First setlist data:', firstSetlist);

                    // Set as current setlist
                    currentSetlist = firstSetlist;
                    console.log(' LOAD-FIRST - Set currentSetlist:', currentSetlist);

                    // Update LED display
                    console.log(' LOAD-FIRST - Updating LED display...');
                    updateSetlistLedDisplay(firstSetlist.name);

                    // Load setlist in sidebar (lateral izquierdo)
                    console.log(' LOAD-FIRST - Loading setlist in sidebar...');
                    loadCurrentSetlistForSidebar();

                    // Load setlist songs in main area
                    console.log(' LOAD-FIRST - Loading setlist songs in main area...');
                    displaySetlistSongs(firstSetlist);

                    console.log(' LOAD-FIRST - First setlist loaded successfully!');
                } else {
                    console.log(' LOAD-FIRST - No setlists found for user');
                }

            } catch (error) {
                console.error(' LOAD-FIRST ERROR - Error loading first available setlist:', error);
                console.error(' LOAD-FIRST ERROR - Error details:', error.message);
                console.error(' LOAD-FIRST ERROR - Error stack:', error.stack);
            }
        }

        // Auto-load last used setlist and song from Firestore
        async function autoLoadLastSetlist() {
            try {
                console.log(' AUTO-LOAD STARTED - Starting auto-load of first available setlist...');
                console.log(' AUTO-LOAD - Current user:', currentUser ? currentUser.uid : 'No user');
                console.log(' AUTO-LOAD - User object:', currentUser);

                if (!currentUser) {
                    console.log(' AUTO-LOAD - No user logged in, exiting');
                    return;
                }

                // Always load the first available setlist
                console.log(' AUTO-LOAD - Calling loadFirstAvailableSetlist...');
                await loadFirstAvailableSetlist();
                console.log(' AUTO-LOAD - First setlist auto-loaded successfully!');

            } catch (error) {
                console.error(' AUTO-LOAD ERROR - Error auto-loading first setlist:', error);
                console.error(' AUTO-LOAD ERROR - Error details:', error.message);
                console.error(' AUTO-LOAD ERROR - Error stack:', error.stack);
            }
        }

        // Load setlist from data
        async function loadSetlistFromData(setlistData) {
            try {
                console.log(' Loading setlist from data:', setlistData.name);
                currentSetlist = setlistData;

                // Update LED display
                updateSetlistLedDisplay(setlistData.name);

                // Display songs from this specific setlist
                console.log(' Displaying setlist songs...');
                await displaySetlistSongs(setlistData);

                console.log(' Setlist loaded successfully!');
            } catch (error) {
                console.error(' Error loading setlist from data:', error);
            }
        }

        // Load first song from setlist
        async function loadFirstSongFromSetlist(setlistData) {
            try {
                if (!setlistData.songs || setlistData.songs.length === 0) {
                    console.log(' No songs in setlist');
                    return;
                }

                // Sort songs by order number if they have one
                const sortedSongs = [...setlistData.songs].sort((a, b) => {
                    const aOrder = a.order || 0;
                    const bOrder = b.order || 0;
                    return aOrder - bOrder;
                });

                console.log(' Sorted songs by order:', sortedSongs.map(s => `${s.name} (order: ${s.order || 0})`));

                // Load the first song (lowest order number)
                if (sortedSongs.length > 0) {
                    const firstSong = sortedSongs[0];
                    console.log(' Auto-loading first song:', firstSong.name, 'Order:', firstSong.order || 0);
                    console.log(' First song data:', firstSong);

                    // Show loading indicator for the first song
                    showSetlistLoading(firstSong.id);

                    await loadSongFromSetlist(firstSong);

                    // Hide loading indicator
                    hideSetlistLoading(firstSong.id);

                    console.log(' First song loaded successfully!');
                }
            } catch (error) {
                console.error(' Error loading first song from setlist:', error);
            }
        }

        // Test authentication state
        function testAuthState() {
            console.log(' Testing authentication state...');
            console.log(' Current user:', currentUser);
            console.log(' Firebase auth:', window.firebase?.auth);
            console.log(' Auth button:', document.getElementById('authButton'));

            if (window.firebase?.auth) {
                window.firebase.auth.currentUser.then(user => {
                    console.log(' Firebase current user:', user);
                    if (user) {
                        alert(` Usuario autenticado:\n\nEmail: ${user.email}\nUID: ${user.uid}\nDisplay Name: ${user.displayName || 'N/A'}`);
                    } else {
                        alert(' No hay usuario autenticado en Firebase');
                    }
                }).catch(error => {
                    console.error(' Error getting current user:', error);
                    alert(' Error al verificar usuario: ' + error.message);
                });
            } else {
                alert(' Firebase no est disponible');
            }
        }

        // Clear setlist songs
        function clearSetlistSongs() {
            const songList = document.getElementById('songList');
            if (songList) {
                songList.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: #888;">
                        <div style="font-size: 48px; margin-bottom: 16px;"></div>
                        <div style="font-size: 16px; font-weight: bold; margin-bottom: 8px; color: #ccc;">Setlist Vaco</div>
                        <div style="font-size: 14px;">Selecciona un setlist para ver sus canciones</div>
                    </div>
                `;
            }
        }

        // Tab switching functionality
        function switchTab(tabName) {
            // Remove active class from all tabs and content
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            // Add active class to selected tab and content
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
            document.getElementById(`${tabName}Tab`).classList.add('active');

            // Load content based on tab
            if (tabName === 'library') {
                loadLibrarySongs();
            } else if (tabName === 'setlist') {
                // Clear the song list when switching to setlist tab
                clearSetlistSongs();
            }
        }

        // Load library songs (songs uploaded by user)
        async function loadLibrarySongs() {
            try {
                console.log(' Loading library songs...');
                console.log(' Current user:', currentUser ? currentUser.uid : 'No user');

                if (!currentUser) {
                    console.log(' No user logged in');
                    return;
                }

                console.log(' Querying Firestore for songs...');
                const songsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'songs'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );

                const querySnapshot = await window.firebase.getDocs(songsQuery);
                const songs = [];

                console.log(' Query snapshot size:', querySnapshot.size);

                querySnapshot.forEach((doc) => {
                    const songData = { id: doc.id, ...doc.data() };
                    console.log(' Found song:', songData.name, 'with', songData.tracks?.length || 0, 'tracks');
                    songs.push(songData);
                });

                console.log(' Library songs loaded:', songs.length);
                displayLibrarySongs(songs);

            } catch (error) {
                console.error(' Error loading library songs:', error);
            }
        }

        // Display library songs
        function displayLibrarySongs(songs) {
            console.log(' Displaying library songs:', songs.length);
            const libraryItems = document.getElementById('libraryItems');

            if (!libraryItems) {
                console.error(' Library items element not found');
                return;
            }

            if (songs.length === 0) {
                console.log(' No songs found, showing empty state');
                libraryItems.innerHTML = `
                    <div class="empty-state">
                        <p>No tienes canciones en tu biblioteca</p>
                        <p>Sube un archivo ZIP para comenzar</p>
                    </div>
                `;
                return;
            }

            libraryItems.innerHTML = songs.map(song => `
                <div class="library-song-item" data-song-id="${song.id}" onclick="selectLibrarySong('${song.id}')">
                    <div class="song-info">
                        <h4>${song.name} <div class="loading-spinner"></div>${isSongCachedOffline(song.id) ? '<div class="offline-indicator"></div>' : ''}</h4>
                        <p>${song.tracks ? song.tracks.length : 0} tracks</p>
                        <p class="song-date">${new Date(song.createdAt?.toDate()).toLocaleDateString()}</p>
                    </div>
                    <div class="song-actions">
                        <button class="action-btn" onclick="event.stopPropagation(); downloadSong('${song.id}')" title="Descargar"></button>
                        <button class="action-btn" onclick="event.stopPropagation(); addToSetlist('${song.id}')" title="Agregar a Setlist"></button>
                        <button class="action-btn" onclick="event.stopPropagation(); deleteSongFromLibrary('${song.id}', '${song.name}')" title="Eliminar cancin" style="background: #ff4444;"></button>
                    </div>
                </div>
            `).join('');
        }

        // Load setlists
        async function loadSetlists() {
            try {
                console.log(' Loading setlists...');

                if (!currentUser) {
                    console.log(' No user logged in');
                    return;
                }

                const setlistsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'setlists'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );

                const querySnapshot = await window.firebase.getDocs(setlistsQuery);
                const setlists = [];

                querySnapshot.forEach((doc) => {
                    setlists.push({ id: doc.id, ...doc.data() });
                });

                // Sort setlists by creation date (oldest first)
                setlists.sort((a, b) => {
                    const dateA = a.createdAt?.toDate ? a.createdAt.toDate() : new Date(a.createdAt);
                    const dateB = b.createdAt?.toDate ? b.createdAt.toDate() : new Date(b.createdAt);
                    return dateA - dateB; // Oldest first
                });

                console.log(' Setlists loaded:', setlists.length, 'sorted by creation date (oldest first)');
                displaySetlists(setlists);

            } catch (error) {
                console.error(' Error loading setlists:', error);
            }
        }

        // Toggle setlist sidebar
        function toggleSetlistSidebar() {
            const sidebar = document.getElementById('setlistSidebar');
            if (sidebar.classList.contains('open')) {
                sidebar.classList.remove('open');
            } else {
                sidebar.classList.add('open');
                loadSetlistSidebar();
            }
        }

        function toggleSetlistMenu(setlistId) {
            // Close all other menus first
            document.querySelectorAll('.setlist-menu-dropdown').forEach(menu => {
                if (menu.id !== `setlist-menu-${setlistId}`) {
                    menu.style.display = 'none';
                }
            });

            // Toggle current menu
            const menu = document.getElementById(`setlist-menu-${setlistId}`);
            if (menu) {
                menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Load setlists in sidebar
        async function loadSetlistSidebar() {
            try {
                console.log(' Loading setlists for sidebar...');

                if (!currentUser) {
                    console.log(' No user logged in');
                    return;
                }

                const setlistsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'setlists'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );

                const querySnapshot = await window.firebase.getDocs(setlistsQuery);
                const setlists = [];

                querySnapshot.forEach((doc) => {
                    setlists.push({ id: doc.id, ...doc.data() });
                });

                // Sort setlists by creation date (oldest first)
                setlists.sort((a, b) => {
                    const dateA = a.createdAt?.toDate ? a.createdAt.toDate() : new Date(a.createdAt);
                    const dateB = b.createdAt?.toDate ? b.createdAt.toDate() : new Date(b.createdAt);
                    return dateA - dateB; // Oldest first
                });

                console.log(' Setlists loaded for sidebar:', setlists.length, 'sorted by creation date (oldest first)');

                const setlistSidebarList = document.getElementById('setlistSidebarList');

                if (setlists.length === 0) {
                    setlistSidebarList.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: #888;">
                            <p>No tienes setlists creados</p>
                        </div>
                    `;
                    return;
                }

                setlistSidebarList.innerHTML = setlists.map((setlist, index) => `
                    <div class="setlist-sidebar-item">
                        <div class="setlist-item-content" onclick="loadSetlistFromSidebar('${setlist.id}')">
                            <h4><span class="setlist-number">${index + 1}.</span> ${setlist.name}</h4>
                            <p>${setlist.songs ? setlist.songs.length : 0} canciones</p>
                        </div>
                        <div class="setlist-item-menu">
                            <button class="setlist-menu-btn" onclick="event.stopPropagation(); toggleSetlistMenu('${setlist.id}')" title="Opciones"></button>
                            <div class="setlist-menu-dropdown" id="setlist-menu-${setlist.id}" style="display: none;">
                                <button class="setlist-menu-item" onclick="deleteSetlist('${setlist.id}')" title="Eliminar setlist"> Eliminar</button>
                            </div>
                        </div>
                    </div>
                `).join('');

            } catch (error) {
                console.error(' Error loading setlists for sidebar:', error);
            }
        }

        // Load setlist from sidebar
        async function loadSetlistFromSidebar(setlistId) {
            try {
                console.log(' Loading setlist from sidebar:', setlistId);

                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistSnap = await window.firebase.getDoc(setlistRef);

                if (setlistSnap.exists()) {
                    const setlistData = setlistSnap.data();
                    setlistData.id = setlistId;

                    // Set as current setlist
                    currentSetlist = setlistData;

                    // Update LED display
                    updateSetlistLedDisplay(setlistData.name);

                    // Display songs in the main area
                    displaySetlistSongs(setlistData);

                    // Close sidebar
                    toggleSetlistSidebar();

                    // Success message removed

                    console.log(' Setlist loaded from sidebar:', setlistData.name);
                } else {
                    alert(' Setlist no encontrado');
                }

            } catch (error) {
                console.error(' Error loading setlist from sidebar:', error);
                alert(' Error al cargar el setlist');
            }
        }

        // Update setlist LED display
        function updateSetlistLedDisplay(setlistName) {
            window.currentSetlistName = setlistName || 'Sin Setlist';
            updateMarqueeDisplay();
        }

        // Update current song LED display
        function updateCurrentSongLedDisplay(songName) {
            window.currentSongName = songName || 'Sin Cancin';
            updateMarqueeDisplay();
        }

        // Update marquee display with setlist and song names
        function updateMarqueeDisplay() {
            const marqueeContent = document.getElementById('marqueeContent');
            if (marqueeContent) {
                const setlistName = window.currentSetlistName || 'Sin Setlist';
                const songName = window.currentSongName || 'Sin Cancin';
                marqueeContent.textContent = `${setlistName} - ${songName}`;
            }
        }

        // Select and load song with immediate visual feedback
        function selectAndLoadSong(songId) {
            console.log(' selectAndLoadSong called with ID:', songId);

            // Update selected song immediately
            currentSelectedSongId = songId;

            // Update selection immediately (no delay)
            updateSongSelection();

            // Then load the song
            loadSong(songId);
        }

        // Update song selection visual state and marquee
        function updateSongSelection() {
            console.log(' Updating song selection for ID:', currentSelectedSongId);

            // Remove selected class from all songs
            const allSongs = document.querySelectorAll('.song-item');
            console.log(' Found', allSongs.length, 'songs to update');
            allSongs.forEach(song => {
                song.classList.remove('selected');
                console.log(' Removed selected class from song');
            });

            // Add selected class to current song
            if (currentSelectedSongId) {
                const selectedSong = document.querySelector(`.song-item[onclick*="selectAndLoadSong('${currentSelectedSongId}')"]`);
                console.log(' Looking for song with ID:', currentSelectedSongId);
                console.log(' Found selected song:', selectedSong);

                if (selectedSong) {
                    selectedSong.classList.add('selected');
                    console.log(' Added selected class to song');

                    // Update marquee with selected song name
                    const songTitle = selectedSong.querySelector('.song-title');
                    if (songTitle) {
                        const songName = songTitle.textContent.replace('', '').trim();
                        console.log(' Updating marquee with song name:', songName);
                        updateCurrentSongLedDisplay(songName);
                    }
                } else {
                    console.log(' Selected song not found in DOM');
                }
            }
        }

        // Display setlist songs in main area
        async function displaySetlistSongs(setlistData) {
            try {
                console.log(' Displaying setlist songs:', setlistData.name);

                // Clear mixer and tracks before loading new setlist (but preserve song cache)
                console.log(' Clearing mixer and tracks before loading new setlist (preserving song cache)');
                clearTracks();
                stopAllTracks();

                // DISABLED: Validation that was incorrectly removing valid songs
                // The validation was checking 'audioFiles' collection but songs might be in other collections
                // For now, we'll trust that setlist songs are valid and let the individual song loading handle errors
                console.log(' Loading setlist songs without validation (to avoid false positives)');

                const cancionesList = document.getElementById('cancionesList');

                if (!setlistData.songs || setlistData.songs.length === 0) {
                    cancionesList.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #888;">
                            <p style="font-size: 18px; margin-bottom: 20px;">Este setlist no tiene canciones</p>
                            <button onclick="toggleLibrary()" style="padding: 12px 24px; background: linear-gradient(135deg, #007AFF, #0056CC); color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; box-shadow: 0 4px 15px rgba(0, 122, 255, 0.3);">
                                 Agregar Canciones
                            </button>
                        </div>
                    `;

                    // Clear mixer and tracks when setlist is empty
                    console.log(' Clearing mixer and tracks - setlist is empty');
                    clearTracks();
                    stopAllTracks();

                    // Update LED display to show empty setlist
                    updateSetlistLedDisplay(setlistData.name);

                    return;
                }

                // Show loading indicator in songs area
                cancionesList.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #3DA9FC;">
                        <div style="font-size: 18px; margin-bottom: 10px;"></div>
                        <p>Cargando canciones...</p>
                    </div>
                `;

                // Update setlist LED display
                updateSetlistLedDisplay(setlistData.name);

                // Update song data with complete information from Firestore
                console.log(' Updating song data from Firestore...');
                const updatedSongs = await updateSetlistSongData(setlistData.songs);
                console.log(' Updated songs data:', updatedSongs);

                // FILTER: Only show songs that are completely cached offline (like Prime)
                console.log(' Filtering songs - only showing fully cached songs...');
                const cachedSongs = updatedSongs.filter(song => isSongCachedOffline(song.id));
                const notCachedCount = updatedSongs.length - cachedSongs.length;

                if (notCachedCount > 0) {
                    console.log(` ${notCachedCount} songs not cached yet - they will appear when fully downloaded`);
                    console.log(` Currently showing ${cachedSongs.length} fully cached songs`);
                }

                console.log(' Songs ready for instant playback:', cachedSongs.map(s => s.name));

                cancionesList.innerHTML = `
                    ${cachedSongs.map((song, index) => `
                        <div class="song-item" onclick="selectAndLoadSong('${song.id}')">
                            <div class="song-number-container">
                                <div class="song-number">${index + 1}</div>
                                <div class="song-loading-indicator" id="loading-${song.id}" style="display: none;">
                                    <div class="mini-progress-bar" id="progress-${song.id}"></div>
                                </div>
                            </div>
                            <div class="song-info">
                                <div class="song-title">${isSongCachedOffline(song.id) ? ' ' : ''}${song.name} ${song.onlinePlayback ? '' : ''}</div>
                                <div class="song-artist">${song.artist || 'Artista desconocido'}</div>
                            </div>
                            <div class="song-meta">
                                <span class="song-tempo">${song.tempo ? song.tempo + ' BPM' : 'BPM N/A'}</span>
                                <span class="song-key">${song.key || 'Key N/A'}</span>
                                <span class="song-time-sig">${song.timeSignature || '4/4'}</span>
                            </div>
                            <div class="song-actions">
                                <div class="song-menu">
                                    <button class="menu-btn" onclick="event.stopPropagation(); toggleSongMenu('${song.id}')" title="Opciones"></button>
                                    <div class="menu-dropdown" id="menu-${song.id}" style="display: none;">
                                        <button class="menu-item" onclick="removeFromSetlist('${song.id}')" title="Eliminar del setlist"> Eliminar</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                `;

                console.log(' Setlist songs displayed successfully');

                // Start SILENT background downloading for non-cached songs (like Prime)
                if (notCachedCount > 0) {
                    console.log(' Starting SILENT background download for non-cached songs...');
                    startSilentBackgroundDownload(updatedSongs.filter(song => !isSongCachedOffline(song.id)));
                }

                // Auto-load first song to mixer (optimized for cache)
                if (cachedSongs.length > 0) {
                    const firstSong = cachedSongs[0];

                    // Auto-select first song
                    currentSelectedSongId = firstSong.id;
                    // Delay to ensure DOM is updated
                    setTimeout(() => {
                        updateSongSelection();
                    }, 100);
                    console.log(' Auto-loading first song to mixer:', firstSong.name);

                    // Try to load the first song (let loadSong handle validation)
                    try {
                        // Check if song is already cached for instant loading
                        if (songCache.has(firstSong.id)) {
                            console.log(' Song is cached, loading instantly');
                            loadSong(firstSong.id);
                        } else {
                            console.log(' Song not cached, loading with delay');
                            setTimeout(() => {
                                loadSong(firstSong.id);
                            }, 500); // Reduced delay for better UX
                        }
                    } catch (error) {
                        console.error(' Error loading first song:', error);
                        console.warn(' Skipping auto-load due to error');
                    }
                }

            } catch (error) {
                console.error(' Error displaying setlist songs:', error);
            }
        }

        // Start SMART background download (check disk first, then download if needed)
        async function startSilentBackgroundDownload(songs) {
            try {
                console.log(' Starting SMART background download for', songs.length, 'songs');
                console.log(' Will check disk first, then download from B2 if needed');

                for (const song of songs) {
                    try {
                        console.log(` Checking if ${song.name} (${song.id}) is already on disk...`);

                        // FIRST: Check if song is already on disk
                        const isOnDisk = await checkIfSongIsOnDisk(song.id);

                        if (isOnDisk) {
                            console.log(` ${song.name} already on disk - no download needed`);
                            // Update cache index to mark as available
                            await markSongAsAvailable(song.id, song.name);
                            // Refresh the setlist to show the song
                            setTimeout(() => {
                                if (currentSetlist && currentSetlist.id) {
                                    displaySetlistSongs(currentSetlist);
                                }
                            }, 100);
                            continue;
                        }

                        console.log(` ${song.name} not on disk - downloading from B2...`);

                        // SECOND: Download from B2 if not on disk
                        const songRef = window.firebase.doc(window.firebase.db, 'songs', song.id);
                        const songSnap = await window.firebase.getDoc(songRef);

                        if (songSnap.exists()) {
                            const songData = songSnap.data();
                            console.log(` Downloading ${songData.tracks?.length || 0} tracks for ${songData.name}`);

                            // Download to local disk (like Prime) - silent
                            const success = await downloadToLocalDisk(song.id, songData);

                            if (success) {
                                console.log(` ${songData.name} downloaded to disk - will appear in setlist now`);
                                // Refresh the setlist to show the newly downloaded song
                                setTimeout(() => {
                                    if (currentSetlist && currentSetlist.id) {
                                        displaySetlistSongs(currentSetlist);
                                    }
                                }, 1000);
                            } else {
                                console.log(` Failed to download ${songData.name} to disk`);
                            }
                        } else {
                            console.log(` Song not found in Firestore: ${song.id}`);
                        }

                        // Small delay between downloads to avoid overwhelming the server
                        await new Promise(resolve => setTimeout(resolve, 2000));

                    } catch (error) {
                        console.error(` Error in smart download for ${song.name}:`, error);
                    }
                }

                console.log(' Smart background download completed');

            } catch (error) {
                console.error(' Error in smart background download:', error);
            }
        }

        // Check if song is already on disk
        async function checkIfSongIsOnDisk(songId) {
            try {
                console.log(` Checking if song ${songId} is on disk...`);

                // Check cache index first
                const cacheEntry = offlineCache.get(songId);
                if (cacheEntry && cacheEntry.storageType === 'disk' && cacheEntry.diskPath) {
                    console.log(` Found cache entry for disk storage: ${cacheEntry.diskPath}`);

                    // Verify the directory actually exists on disk
                    try {
                        const cacheDir = await navigator.storage.getDirectory();
                        const songDir = await cacheDir.getDirectoryHandle(cacheEntry.diskPath);
                        console.log(` Song directory exists on disk: ${cacheEntry.diskPath}`);
                        return true;
                    } catch (error) {
                        console.log(` Song directory not found on disk: ${error.message}`);
                        // Remove invalid cache entry
                        offlineCache.delete(songId);
                        cacheIndex = cacheIndex.filter(entry => entry.songId !== songId);
                        localStorage.setItem(CACHE_STORAGE_KEY, JSON.stringify(cacheIndex));
                        return false;
                    }
                }

                console.log(` No disk storage found for song ${songId}`);
                return false;

            } catch (error) {
                console.error(` Error checking disk storage for song ${songId}:`, error);
                return false;
            }
        }

        // Mark song as available (update cache index)
        async function markSongAsAvailable(songId, songName) {
            try {
                console.log(` Marking song ${songName} as available...`);

                // Get song data from Firestore
                const songRef = window.firebase.doc(window.firebase.db, 'songs', songId);
                const songSnap = await window.firebase.getDoc(songRef);

                if (songSnap.exists()) {
                    const songData = songSnap.data();

                    // Update cache index
                    const cacheEntry = {
                        songId: songId,
                        songName: songName,
                        downloadedAt: new Date().toISOString(),
                        fileSize: songData.tracks?.reduce((total, track) => total + (track.fileSize || 0), 0) || 0,
                        trackCount: songData.tracks?.length || 0,
                        persistent: true,
                        songData: songData,
                        storageType: 'disk',
                        diskPath: `${songId}_${songName.replace(/[^a-zA-Z0-9]/g, '_')}`
                    };

                    // Remove existing entry if any
                    cacheIndex = cacheIndex.filter(entry => entry.songId !== songId);
                    cacheIndex.push(cacheEntry);

                    offlineCache.set(songId, cacheEntry);
                    localStorage.setItem(CACHE_STORAGE_KEY, JSON.stringify(cacheIndex));

                    console.log(` Song ${songName} marked as available on disk`);
                }

            } catch (error) {
                console.error(` Error marking song as available:`, error);
            }
        }

        // Start progressive loading of songs
        async function startProgressiveLoading(songs) {
            try {
                console.log(' Starting progressive loading for', songs.length, 'songs');

                // Initialize progressive loading
                progressiveLoadingQueue = [...songs];
                isProgressiveLoading = true;
                currentLoadingSongIndex = 0;

                // Load first song immediately
                if (songs.length > 0) {
                    await loadSongProgressively(songs[0], 0);
                }

            } catch (error) {
                console.error(' Error starting progressive loading:', error);
            }
        }

        // Load a single song progressively
        async function loadSongProgressively(song, index) {
            try {
                console.log(` Loading song ${index + 1}/${progressiveLoadingQueue.length}: ${song.name}`);

                // Update current loading index
                currentLoadingSongIndex = index;

                // Show loading indicator for this song
                showSongLoadingIndicator(song.id);

                // Load the song tracks (cache only, don't play)
                await loadSongTracksForCache(song);

                // Hide loading indicator
                hideSongLoadingIndicator(song.id);

                console.log(` Song ${index + 1} cached successfully: ${song.name}`);

                // Load next song after a short delay (continue in background)
                if (index + 1 < progressiveLoadingQueue.length && isProgressiveLoading) {
                    setTimeout(() => {
                        // Check if progressive loading is still active before continuing
                        if (isProgressiveLoading) {
                            loadSongProgressively(progressiveLoadingQueue[index + 1], index + 1);
                        }
                    }, 1000); // 1 second delay between songs
                } else {
                    console.log(' Progressive loading completed!');
                    isProgressiveLoading = false;
                }

            } catch (error) {
                console.error(` Error loading song ${index + 1}:`, error);
                hideSongLoadingIndicator(song.id);

                // Continue with next song even if this one failed
                if (index + 1 < progressiveLoadingQueue.length && isProgressiveLoading) {
                    setTimeout(() => {
                        // Check if progressive loading is still active before continuing
                        if (isProgressiveLoading) {
                            loadSongProgressively(progressiveLoadingQueue[index + 1], index + 1);
                        }
                    }, 1000);
                }
            }
        }

        // Load song tracks for cache only (without playing)
        async function loadSongTracksForCache(songData) {
            try {
                console.log(' Loading song tracks for cache:', songData.name);

                // Tracks already cleared above - no need to clear again
                console.log(' Using existing cleared tracks array');
                gainNodes.clear();

                // Handle different track data structures
                let trackData = [];
                if (songData.tracks && Array.isArray(songData.tracks)) {
                    if (typeof songData.tracks[0] === 'object' && songData.tracks[0] !== null) {
                        trackData = songData.tracks;
                    } else {
                        trackData = songData.tracks.map(name => ({ name: name }));
                    }
                } else {
                    trackData = [
                        { name: 'Drums' },
                        { name: 'Bass' },
                        { name: 'Guitar' },
                        { name: 'Keys' },
                        { name: 'Vocals' },
                        { name: 'Backing Vocals' }
                    ];
                }

                const tempTracksForCache = trackData.map((track, index) => {
                    let trackName = '';
                    if (typeof track === 'string') {
                        trackName = track;
                    } else if (track && typeof track === 'object') {
                        trackName = track.name || track.title || `Track ${index + 1}`;
                    } else {
                        trackName = `Track ${index + 1}`;
                    }

                    return {
                        id: `${songData.id}-${index + 1}`, // Unique ID for each track
                        name: trackName,
                        volume: 0.8,
                        muted: false,
                        solo: false,
                        playing: false,
                        audioUrl: track.downloadUrl || track.audioUrl || null,
                        originalUrl: track.originalUrl || null
                    };
                });

                // Load audio files for each track (cache only)
                for (let i = 0; i < tempTracksForCache.length; i++) {
                    const track = tempTracksForCache[i];
                    let audioUrl = track.audioUrl;

                    if (track.originalUrl) {
                        audioUrl = track.originalUrl;
                    } else if (track.downloadUrl) {
                        audioUrl = track.downloadUrl;
                    }

                    if (audioUrl) {
                        try {
                            const audioBuffer = await loadAudioFile(audioUrl, track.id);
                            if (audioBuffer) {
                                console.log(` Cached track ${i + 1}/${tempTracksForCache.length}: ${track.name}`);
                            }
                        } catch (error) {
                            console.error(` Error caching track ${track.name}:`, error);
                        }
                    }
                }

                // Restore original tracks
                tracks = tempTracksForCache;

                console.log(` Song "${songData.name}" cached successfully`);

            } catch (error) {
                console.error(' Error loading song tracks for cache:', error);
            }
        }

        // Show loading indicator for specific song
        function showSongLoadingIndicator(songId) {
            const loadingIndicator = document.getElementById(`loading-${songId}`);
            const progressBar = document.getElementById(`progress-${songId}`);
            if (loadingIndicator) {
                loadingIndicator.style.display = 'block';
            }
            if (progressBar) {
                progressBar.style.width = '0%';
            }
        }

        // Hide loading indicator for specific song
        function hideSongLoadingIndicator(songId) {
            const loadingIndicator = document.getElementById(`loading-${songId}`);
            const progressBar = document.getElementById(`progress-${songId}`);
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
            if (progressBar) {
                progressBar.style.width = '0%';
            }
        }

        // Update progress for specific song
        function updateSongLoadingProgress(songId, progress) {
            const progressBar = document.getElementById(`progress-${songId}`);
            if (progressBar) {
                progressBar.style.width = `${progress}%`;
            }
        }

        // Stop progressive loading
        function stopProgressiveLoading() {
            isProgressiveLoading = false;
            progressiveLoadingQueue = [];
            currentLoadingSongIndex = 0;
            console.log(' Progressive loading stopped');
        }

        // Pause progressive loading temporarily (when user is playing)
        function pauseProgressiveLoading() {
            if (isProgressiveLoading) {
                console.log(' Pausing progressive loading temporarily');
                // Don't stop completely, just pause the current process
                // The setTimeout will check isProgressiveLoading and continue if true
            }
        }

        // Resume progressive loading
        function resumeProgressiveLoading() {
            if (progressiveLoadingQueue.length > 0 && !isProgressiveLoading) {
                console.log(' Resuming progressive loading');
                isProgressiveLoading = true;
                // Continue from where we left off
                if (currentLoadingSongIndex < progressiveLoadingQueue.length) {
                    loadSongProgressively(progressiveLoadingQueue[currentLoadingSongIndex], currentLoadingSongIndex);
                }
            }
        }

        // Display all songs from library
        async function displayAllSongs() {
            try {
                console.log(' Loading all songs from library...');

                if (!currentUser) {
                    console.log(' No user logged in');
                    return;
                }

                const songsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'songs'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );

                const querySnapshot = await window.firebase.getDocs(songsQuery);
                const songs = [];

                querySnapshot.forEach((doc) => {
                    songs.push({ id: doc.id, ...doc.data() });
                });

                console.log(' Songs loaded:', songs.length);

                const cancionesList = document.getElementById('cancionesList');

                if (songs.length === 0) {
                    cancionesList.innerHTML = `
                        <div class="empty-state">
                            <p>No tienes canciones en tu biblioteca</p>
                        </div>
                    `;
                    return;
                }

                cancionesList.innerHTML = songs.map(song => `
                    <div class="song-item" onclick="selectAndLoadSong('${song.id}')">
                        <div class="song-number"></div>
                        <div class="song-cover"></div>
                        <div class="song-info">
                            <div class="song-title">${song.name} ${song.onlinePlayback ? '' : ''}</div>
                            <div class="song-artist">${song.artist || 'Artista desconocido'}</div>
                            <div class="song-details">
                                <span class="song-tempo">${song.tempo ? song.tempo + ' BPM' : 'BPM N/A'}</span>
                                <span class="song-key">${song.key || 'Key N/A'}</span>
                                <span class="song-time-sig">${song.timeSignature || '4/4'}</span>
                            </div>
                        </div>
                        <div class="song-actions">
                            <div class="song-menu">
                                <button class="menu-btn" onclick="event.stopPropagation(); addToSetlist('${song.id}')" title="Agregar al setlist"></button>
                            </div>
                        </div>
                    </div>
                `).join('');

            } catch (error) {
                console.error(' Error loading all songs:', error);
            }
        }

        // Display setlists
        function displaySetlists(setlists) {
            const setlistList = document.getElementById('setlistList');

            if (setlists.length === 0) {
                setlistList.innerHTML = `
                    <div class="empty-state">
                        <p>No tienes setlists creados</p>
                        <button class="create-setlist-btn" onclick="createNewSetlist()">Crear Setlist</button>
                    </div>
                `;
                return;
            }

            setlistList.innerHTML = setlists.map(setlist => `
                <div class="setlist-item" onclick="loadSetlist('${setlist.id}')">
                    <div class="setlist-info">
                        <h4>${setlist.name}</h4>
                        <p>${setlist.songs ? setlist.songs.length : 0} canciones</p>
                        <p class="setlist-date">${new Date(setlist.date?.toDate()).toLocaleDateString()}</p>
                    </div>
                    <div class="setlist-actions">
                        <button class="action-btn" onclick="event.stopPropagation(); editSetlist('${setlist.id}')" title="Editar"></button>
                        <button class="action-btn" onclick="event.stopPropagation(); deleteSetlist('${setlist.id}')" title="Eliminar"></button>
                    </div>
                </div>
            `).join('');
        }

        // Show create setlist modal
        function showCreateSetlistModal() {
            const modal = document.getElementById('createSetlistModal');
            const nameInput = document.getElementById('setlistNameInput');
            const dateInput = document.getElementById('setlistDateInput');
            const errorDiv = document.getElementById('setlistError');

            // Set default date to today
            const today = new Date().toISOString().split('T')[0];
            dateInput.value = today;

            // Clear inputs
            nameInput.value = '';
            errorDiv.style.display = 'none';
            errorDiv.textContent = '';

            // Show modal
            modal.style.display = 'flex';

            // Focus on name input after a short delay for smooth animation
            setTimeout(() => {
                nameInput.focus();
            }, 100);

            // Close on Escape key
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    hideCreateSetlistModal();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);

            // Close on click outside modal
            modal.onclick = (e) => {
                if (e.target === modal) {
                    hideCreateSetlistModal();
                }
            };
        }

        // Hide create setlist modal
        function hideCreateSetlistModal() {
            const modal = document.getElementById('createSetlistModal');
            modal.style.display = 'none';
        }

        // Handle create setlist form submit
        function handleCreateSetlistSubmit(event) {
            event.preventDefault();

            const nameInput = document.getElementById('setlistNameInput');
            const dateInput = document.getElementById('setlistDateInput');
            const errorDiv = document.getElementById('setlistError');

            const name = nameInput.value.trim();
            const date = dateInput.value;

            // Validate
            if (!name) {
                errorDiv.textContent = 'Por favor ingresa un nombre para el setlist';
                errorDiv.style.display = 'block';
                nameInput.focus();
                return;
            }

            if (!date) {
                errorDiv.textContent = 'Por favor selecciona una fecha';
                errorDiv.style.display = 'block';
                dateInput.focus();
                return;
            }

            // Hide error
            errorDiv.style.display = 'none';

            // Create setlist
            createSetlist(name, date);

            // Hide modal
            hideCreateSetlistModal();
        }

        // Create new setlist (kept for backward compatibility)
        function createNewSetlist() {
            showCreateSetlistModal();
        }

        // Create setlist in Firestore
        async function createSetlist(name, date) {
            try {
                console.log(' Creating setlist:', name);

                const setlistData = {
                    userId: currentUser.uid,
                    name: name,
                    date: new Date(date),
                    songs: [],
                    createdAt: new Date()
                };

                const docRef = await window.firebase.addDoc(
                    window.firebase.collection(window.firebase.db, 'setlists'),
                    setlistData
                );

                console.log(' Setlist created:', docRef.id);

                // Show success notification
                showSuccessNotification(`Setlist "${name}" creado exitosamente`);

                loadSetlists(); // Refresh the list
                loadSetlistSidebar(); // Refresh the sidebar

            } catch (error) {
                console.error(' Error creating setlist:', error);
                alert(` Error al crear setlist: ${error.message}`);
            }
        }

        // Delete setlist
        async function deleteSetlist(setlistId) {
            try {
                // Get setlist data first
                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistSnap = await window.firebase.getDoc(setlistRef);

                if (!setlistSnap.exists()) {
                    alert(' Setlist no encontrado');
                    return;
                }

                const setlistData = setlistSnap.data();
                const setlistName = setlistData.name;

                // Confirm deletion
                const confirmDelete = confirm(`Ests seguro de que quieres eliminar el setlist "${setlistName}"?\n\nEsta accin no se puede deshacer.`);
                if (!confirmDelete) return;

                // Delete the setlist
                await window.firebase.deleteDoc(setlistRef);

                console.log(' Setlist deleted:', setlistId);
                alert(` Setlist "${setlistName}" eliminado exitosamente`);

                // Refresh the list
                loadSetlists();
                loadSetlistSidebar(); // Refresh the sidebar

            } catch (error) {
                console.error(' Error deleting setlist:', error);
                alert(` Error al eliminar setlist: ${error.message}`);
            }
        }

        // Load a specific setlist
        async function loadSetlist(setlistId) {
            try {
                console.log(' Loading setlist:', setlistId);

                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistSnap = await window.firebase.getDoc(setlistRef);

                if (setlistSnap.exists()) {
                    const setlistData = setlistSnap.data();
                    setlistData.id = setlistId; // Add ID to the data
                    console.log(' Setlist data:', setlistData);

                    // Save as current setlist and last used
                    currentSetlist = setlistData;
                    saveLastUsedSetlist(setlistData);

                    // Show setlist header with edit button
                    showSetlistHeader(setlistData, setlistId);

                    // Display songs in the setlist
                    if (setlistData.songs && setlistData.songs.length > 0) {
                        displaySongs(setlistData.songs);
                    } else {
                        displayEmptySetlist();
                    }

                    // Update setlist display
                    updateSetlistDisplay();
                } else {
                    alert('Setlist no encontrado');
                }
            } catch (error) {
                console.error(' Error loading setlist:', error);
                alert('Error al cargar el setlist: ' + error.message);
            }
        }

        // Show setlist header with edit button
        function showSetlistHeader(setlistData, setlistId) {
            const setlistHeader = document.querySelector('.setlist-header');
            if (setlistHeader) {
                setlistHeader.innerHTML = `
                    <div class="setlist-title"> ${setlistData.name}</div>
                    <div>
                        <button class="setlist-btn" onclick="editSetlist('${setlistId}')" title="Editar setlist"></button>
                        <button class="setlist-btn" onclick="addSongsToSetlist('${setlistId}')" title="Agregar canciones"></button>
                        <button class="setlist-btn" onclick="showDownloadInfo('${setlistId}')" title="Ver informacin de reproduccin"></button>
                        <button class="setlist-btn" onclick="testSetlistAudio('${setlistId}')" title="Probar audio del setlist"></button>
                        <button class="setlist-btn" onclick="testSpecificB2Url()" title="Probar CORS de B2"></button>
                        <button class="setlist-btn" onclick="backToSetlists()" title="Volver a setlists"></button>
                    </div>
                `;
            }
        }

        // Display empty setlist
        function displayEmptySetlist() {
            const songList = document.getElementById('songList');
            if (songList) {
                songList.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: #888;">
                        <div style="font-size: 48px; margin-bottom: 16px;"></div>
                        <div style="font-size: 16px; font-weight: bold; margin-bottom: 8px; color: #ccc;">Setlist Vaco</div>
                        <div style="font-size: 14px;">Haz clic en "" para agregar canciones desde tu biblioteca</div>
                    </div>
                `;
            }
        }

        // Back to setlists view
        function backToSetlists() {
            const setlistHeader = document.querySelector('.setlist-header');
            if (setlistHeader) {
                setlistHeader.innerHTML = `
                    <div class="setlist-title"> Mi Setlist</div>
                    <div>
                        <button class="setlist-btn" onclick="createNewSetlist()" title="Crear nuevo setlist"></button>
                        <button class="setlist-btn" onclick="debugSetlists()" title="Debug setlists"></button>
                    </div>
                `;
            }

            // Clear song list and show setlists
            clearSetlistSongs();
        }

        // Add songs to setlist
        async function addSongsToSetlist(setlistId) {
            try {
                console.log(' Adding songs to setlist:', setlistId);
                console.log(' Current user:', currentUser?.uid);

                // First verify the setlist exists
                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistSnap = await window.firebase.getDoc(setlistRef);

                if (!setlistSnap.exists()) {
                    console.error(' Setlist not found:', setlistId);
                    alert('Error: Setlist no encontrado. ID: ' + setlistId);
                    return;
                }

                console.log(' Setlist exists:', setlistSnap.data().name);

                // Get user's songs from library
                const songsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'songs'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );

                const querySnapshot = await window.firebase.getDocs(songsQuery);
                const songs = [];

                querySnapshot.forEach((doc) => {
                    songs.push({ id: doc.id, ...doc.data() });
                });

                console.log(' Found songs in library:', songs.length);

                if (songs.length === 0) {
                    alert('No tienes canciones en tu biblioteca. Sube un archivo ZIP primero.');
                    return;
                }

                // Show song selection modal
                showSongSelectionModal(songs, setlistId);

            } catch (error) {
                console.error(' Error adding songs to setlist:', error);
                alert('Error al agregar canciones: ' + error.message);
            }
        }

        // Show song selection modal
        function showSongSelectionModal(songs, setlistId) {
            // Create modal HTML
            const modalHTML = `
                <div id="songSelectionModal" style="display: flex; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.8); align-items: center; justify-content: center; z-index: 10000;">
                    <div style="background-color: #1a1a1a; border-radius: 10px; padding: 30px; width: 600px; max-width: 90vw; max-height: 80vh; border: 1px solid #333; overflow-y: auto;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h2 style="color: #fff; font-size: 24px; font-weight: bold; margin: 0;">Agregar Canciones al Setlist</h2>
                            <button onclick="hideSongSelectionModal()" style="background: none; border: none; color: #ccc; font-size: 24px; cursor: pointer; padding: 5px;"></button>
                        </div>
                        
                        <div id="songSelectionList" style="display: flex; flex-direction: column; gap: 10px; max-height: 400px; overflow-y: auto;">
                            ${songs.map(song => `
                                <div class="library-song-item" style="cursor: pointer;" onclick="selectSongForSetlist('${song.id}', '${setlistId}')">
                                    <div class="song-info">
                                        <h4>${song.name}</h4>
                                        <p>${song.tracks ? song.tracks.length : 0} tracks</p>
                                        <p class="song-date">${new Date(song.createdAt?.toDate()).toLocaleDateString()}</p>
                                    </div>
                                    <div class="song-actions">
                                        <button class="action-btn" title="Agregar"></button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                            <button onclick="hideSongSelectionModal()" style="padding: 12px 24px; background-color: #666; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;">Cancelar</button>
                        </div>
                    </div>
                </div>
            `;

            // Add modal to page
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        // Hide song selection modal
        function hideSongSelectionModal() {
            const modal = document.getElementById('songSelectionModal');
            if (modal) {
                modal.remove();
            }
        }

        // Show cache management modal
        async function showCacheManagementModal() {
            try {
                console.log(' Opening cache management modal...');

                // Get cache information
                const savedIndex = localStorage.getItem(CACHE_STORAGE_KEY);
                const cacheIndex = savedIndex ? JSON.parse(savedIndex) : [];
                const diskSongs = cacheIndex.filter(entry => entry.storageType === 'disk');

                // Calculate total size
                const totalSize = cacheIndex.reduce((total, entry) => total + (entry.fileSize || 0), 0);
                const totalSizeMB = (totalSize / 1024 / 1024).toFixed(2);

                // Create modal HTML
                const modalHTML = `
                    <div id="cacheManagementModal" style="display: flex; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.8); align-items: center; justify-content: center; z-index: 10000;">
                        <div style="background-color: #1a1a1a; border-radius: 10px; padding: 30px; width: 700px; max-width: 90vw; max-height: 80vh; border: 1px solid #333; overflow-y: auto;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                                <h2 style="color: #fff; font-size: 24px; font-weight: bold; margin: 0;"> Gestin de Cache del Disco</h2>
                                <button onclick="hideCacheManagementModal()" style="background: none; border: none; color: #ccc; font-size: 24px; cursor: pointer; padding: 5px;"></button>
                            </div>
                            
                            <div style="margin-bottom: 20px; padding: 15px; background-color: #2a2a2a; border-radius: 8px;">
                                <h3 style="color: #fff; margin: 0 0 10px 0; font-size: 18px;"> Resumen del Cache</h3>
                                <div style="color: #ccc; font-size: 14px; line-height: 1.6;">
                                    <div> Canciones en disco: <strong style="color: #4CAF50;">${diskSongs.length}</strong></div>
                                    <div> Tamao total: <strong style="color: #4CAF50;">${totalSizeMB} MB</strong></div>
                                    <div> ltima actualizacin: <strong style="color: #4CAF50;">${new Date().toLocaleString()}</strong></div>
                                </div>
                            </div>
                            
                            <div style="margin-bottom: 20px;">
                                <h3 style="color: #fff; margin: 0 0 15px 0; font-size: 18px;"> Canciones Almacenadas</h3>
                                <div id="cacheSongList" style="max-height: 300px; overflow-y: auto; border: 1px solid #333; border-radius: 6px; background-color: #2a2a2a;">
                                    ${diskSongs.length > 0 ? diskSongs.map(entry => `
                                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px 15px; border-bottom: 1px solid #333;">
                                            <div style="flex: 1;">
                                                <div style="color: #fff; font-weight: bold; margin-bottom: 4px;">${entry.songName}</div>
                                                <div style="color: #ccc; font-size: 12px;">
                                                     ${entry.trackCount} tracks   ${((entry.fileSize || 0) / 1024 / 1024).toFixed(2)}MB
                                                </div>
                                                <div style="color: #888; font-size: 11px;">
                                                     ${new Date(entry.downloadedAt).toLocaleString()}
                                                </div>
                                            </div>
                                            <button onclick="removeSongFromDisk('${entry.songId}')" style="background-color: #d32f2f; color: white; border: none; border-radius: 4px; padding: 6px 12px; font-size: 12px; cursor: pointer;" title="Eliminar del disco"></button>
                                        </div>
                                    `).join('') : `
                                        <div style="padding: 30px; text-align: center; color: #888;">
                                            <div style="font-size: 48px; margin-bottom: 10px;"></div>
                                            <div>No hay canciones almacenadas en disco</div>
                                        </div>
                                    `}
                                </div>
                            </div>
                            
                            <div style="display: flex; gap: 10px; justify-content: flex-end; flex-wrap: wrap;">
                                <button onclick="redownloadAllSongs()" style="padding: 12px 20px; background-color: #2196F3; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;" title="Re-descargar todas las canciones correctamente">
                                     Re-descargar Todo
                                </button>
                                <button onclick="clearAllCache()" style="padding: 12px 20px; background-color: #f57c00; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;" title="Borrar solo el cache (mantener localStorage)">
                                     Limpiar Cache
                                </button>
                                <button onclick="emergencyClearAllStorage()" style="padding: 12px 20px; background-color: #d32f2f; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;" title="Borrar TODO (nuclear option)">
                                     Borrar Todo
                                </button>
                                <button onclick="hideCacheManagementModal()" style="padding: 12px 20px; background-color: #666; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;">
                                    Cerrar
                                </button>
                            </div>
                        </div>
                    </div>
                `;

                // Add modal to page
                document.body.insertAdjacentHTML('beforeend', modalHTML);

            } catch (error) {
                console.error(' Error showing cache management modal:', error);
                alert('Error al abrir la gestin de cache: ' + error.message);
            }
        }

        // Hide cache management modal
        function hideCacheManagementModal() {
            const modal = document.getElementById('cacheManagementModal');
            if (modal) {
                modal.remove();
            }
        }

        // Remove specific song from disk
        async function removeSongFromDisk(songId) {
            try {
                if (!confirm('Ests seguro de que quieres eliminar esta cancin del disco duro?')) {
                    return;
                }

                console.log(` Removing song ${songId} from disk...`);

                // Find cache entry
                const cacheEntry = offlineCache.get(songId);
                if (!cacheEntry || cacheEntry.storageType !== 'disk') {
                    console.log(' Song not found in disk cache:', songId);
                    return;
                }

                // Try to remove from File System API
                try {
                    const cacheDir = await navigator.storage.getDirectory();
                    const songDir = await cacheDir.getDirectoryHandle(cacheEntry.diskPath);

                    // Remove all files in the directory
                    for await (const [name, handle] of songDir.entries()) {
                        if (handle.kind === 'file') {
                            await songDir.removeEntry(name);
                            console.log(` Removed file: ${name}`);
                        }
                    }

                    // Remove the directory
                    await cacheDir.removeEntry(cacheEntry.diskPath);
                    console.log(` Removed directory: ${cacheEntry.diskPath}`);

                } catch (error) {
                    console.log(' Could not remove from File System API:', error.message);
                }

                // Remove from cache index
                cacheIndex = cacheIndex.filter(entry => entry.songId !== songId);
                offlineCache.delete(songId);
                localStorage.setItem(CACHE_STORAGE_KEY, JSON.stringify(cacheIndex));

                console.log(` Song ${songId} removed from disk cache`);

                // Refresh the modal
                hideCacheManagementModal();
                showCacheManagementModal();

                // Show success message
                alert(` Cancin eliminada del disco duro`);

            } catch (error) {
                console.error(' Error removing song from disk:', error);
                alert('Error al eliminar la cancin: ' + error.message);
            }
        }

        // Re-download all songs correctly
        async function redownloadAllSongs() {
            try {
                if (!confirm('Ests seguro de que quieres re-descargar todas las canciones? Esto puede tomar varios minutos.')) {
                    return;
                }

                console.log(' Starting re-download of all songs...');

                // Get all songs from current setlist
                if (!currentSetlist || !currentSetlist.songs) {
                    alert(' No hay setlist activo para re-descargar');
                    return;
                }

                // Clear existing cache first
                console.log(' Clearing existing cache...');
                await clearAllCache();

                // Show loading modal
                showLoading('Re-descargando canciones...');

                let successCount = 0;
                let errorCount = 0;

                for (const songRef of currentSetlist.songs) {
                    try {
                        console.log(` Re-downloading: ${songRef.name} (${songRef.id})`);

                        // Get full song data from Firestore
                        const songDocRef = window.firebase.doc(window.firebase.db, 'songs', songRef.id);
                        const songSnap = await window.firebase.getDoc(songDocRef);

                        if (songSnap.exists()) {
                            const songData = songSnap.data();

                            // Use File System API method (real disk storage)
                            const success = await downloadToLocalDisk(songRef.id, songData);

                            if (success) {
                                console.log(` Successfully re-downloaded: ${songData.name}`);
                                successCount++;
                            } else {
                                console.log(` Failed to re-download: ${songData.name}`);
                                errorCount++;
                            }
                        } else {
                            console.log(` Song not found in Firestore: ${songRef.id}`);
                            errorCount++;
                        }

                        // Small delay between downloads
                        await new Promise(resolve => setTimeout(resolve, 1000));

                    } catch (error) {
                        console.error(` Error re-downloading ${songRef.name}:`, error);
                        errorCount++;
                    }
                }

                hideLoading();

                // Show results
                const message = ` Re-descarga completada:\n Exitosas: ${successCount}\n Fallidas: ${errorCount}`;
                alert(message);

                // Refresh the cache management modal
                hideCacheManagementModal();
                showCacheManagementModal();

                // Refresh the setlist display
                if (currentSetlist && currentSetlist.id) {
                    displaySetlistSongs(currentSetlist);
                }

                console.log(' Re-download process completed');

            } catch (error) {
                console.error(' Error in re-download process:', error);
                hideLoading();
                alert('Error durante la re-descarga: ' + error.message);
            }
        }

        // Select song for setlist
        async function selectSongForSetlist(songId, setlistId) {
            try {
                console.log(' Adding song to setlist:', songId, setlistId);
                console.log(' Song ID:', songId);
                console.log(' Setlist ID:', setlistId);

                // Get song data
                const songRef = window.firebase.doc(window.firebase.db, 'songs', songId);
                const songSnap = await window.firebase.getDoc(songRef);

                if (!songSnap.exists()) {
                    console.error(' Song not found:', songId);
                    alert('Cancin no encontrada');
                    return;
                }

                const songData = songSnap.data();
                console.log(' Song found:', songData.name);

                // Get current setlist
                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistSnap = await window.firebase.getDoc(setlistRef);

                if (!setlistSnap.exists()) {
                    console.error(' Setlist not found:', setlistId);
                    alert('Setlist no encontrado. ID: ' + setlistId);
                    return;
                }

                console.log(' Setlist found:', setlistSnap.data().name);

                const setlistData = setlistSnap.data();
                const currentSongs = setlistData.songs || [];

                // Check if song already exists in setlist
                if (currentSongs.some(song => song.id === songId)) {
                    alert('Esta cancin ya est en el setlist');
                    return;
                }

                // Prepare tracks for online playback
                console.log(' Preparing tracks for online playback...');
                const preparedTracks = prepareTracksForSetlist(songData);

                // Add song to setlist with online track references
                currentSongs.push({
                    id: songId,
                    name: songData.name,
                    tracks: preparedTracks, // Use prepared tracks for online playback
                    originalTracks: songData.tracks, // Keep original B2 references
                    addedAt: new Date(),
                    onlinePlayback: true
                });

                // Update setlist in Firestore
                await window.firebase.updateDoc(setlistRef, {
                    songs: currentSongs,
                    updatedAt: new Date()
                });

                console.log(' Song added to setlist');
                alert(` Cancin agregada al setlist\n\n La cancin "${songData.name}" se ha agregado al setlist.\n\n Los archivos se reproducirn directamente desde Backblaze B2 para una experiencia online fluida.`);

                // Hide modal and refresh setlist view
                hideSongSelectionModal();
                loadSetlist(setlistId);

            } catch (error) {
                console.error(' Error adding song to setlist:', error);
                alert('Error al agregar cancin: ' + error.message);
            }
        }

        // Edit setlist
        async function editSetlist(setlistId) {
            try {
                console.log(' Editing setlist:', setlistId);

                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistSnap = await window.firebase.getDoc(setlistRef);

                if (!setlistSnap.exists()) {
                    alert('Setlist no encontrado');
                    return;
                }

                const setlistData = setlistSnap.data();

                // Show edit modal
                const newName = prompt('Nuevo nombre del setlist:', setlistData.name);
                if (!newName || newName === setlistData.name) return;

                // Update setlist name
                await window.firebase.updateDoc(setlistRef, {
                    name: newName,
                    updatedAt: new Date()
                });

                console.log(' Setlist updated');
                alert('Setlist actualizado');

                // Refresh setlist view
                loadSetlist(setlistId);

            } catch (error) {
                console.error(' Error editing setlist:', error);
                alert('Error al editar setlist: ' + error.message);
            }
        }

        // Debug setlists
        async function debugSetlists() {
            try {
                console.log(' Debugging setlists...');
                console.log(' Current user:', currentUser?.uid);

                if (!currentUser) {
                    alert(' No hay usuario autenticado');
                    return;
                }

                // Get all setlists
                const setlistsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'setlists'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );

                const querySnapshot = await window.firebase.getDocs(setlistsQuery);
                const setlists = [];

                querySnapshot.forEach((doc) => {
                    setlists.push({ id: doc.id, ...doc.data() });
                });

                console.log(' Found setlists:', setlists);

                let debugInfo = ` Debug Info:\n\n`;
                debugInfo += `Usuario: ${currentUser.email}\n`;
                debugInfo += `UID: ${currentUser.uid}\n\n`;
                debugInfo += `Setlists encontrados: ${setlists.length}\n\n`;

                setlists.forEach((setlist, index) => {
                    debugInfo += `${index + 1}. ID: ${setlist.id}\n`;
                    debugInfo += `   Nombre: ${setlist.name}\n`;
                    debugInfo += `   Canciones: ${setlist.songs?.length || 0}\n`;
                    debugInfo += `   Creado: ${setlist.createdAt?.toDate?.()?.toLocaleString() || 'N/A'}\n\n`;
                });

                alert(debugInfo);

            } catch (error) {
                console.error(' Error debugging setlists:', error);
                alert('Error al debuggear setlists: ' + error.message);
            }
        }

        // Delete song from library
        async function deleteSongFromLibrary(songId, songName) {
            try {
                console.log(' Deleting song from library:', songId, songName);

                // Show confirmation dialog
                const confirmMessage = `Ests seguro de que quieres eliminar la cancin "${songName}"?\n\nEsta accin eliminar:\n La cancin de tu biblioteca\n Todos los archivos de audio asociados\n La cancin de cualquier setlist donde est incluida\n\n Esta accin NO se puede deshacer.`;

                if (!confirm(confirmMessage)) {
                    console.log(' Song deletion cancelled by user');
                    return;
                }

                console.log(' User confirmed deletion');

                // Get song data first to check tracks
                const songRef = window.firebase.doc(window.firebase.db, 'songs', songId);
                const songSnap = await window.firebase.getDoc(songRef);

                if (!songSnap.exists()) {
                    alert('Error: La cancin no existe');
                    return;
                }

                const songData = songSnap.data();
                console.log(' Song data:', songData);

                // Check if song is in any setlists
                const setlistsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'setlists'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );

                const setlistsSnapshot = await window.firebase.getDocs(setlistsQuery);
                const setlistsWithSong = [];

                setlistsSnapshot.forEach((doc) => {
                    const setlistData = doc.data();
                    if (setlistData.songs && setlistData.songs.some(song => song.id === songId)) {
                        setlistsWithSong.push({ id: doc.id, name: setlistData.name });
                    }
                });

                if (setlistsWithSong.length > 0) {
                    const setlistNames = setlistsWithSong.map(s => s.name).join(', ');
                    const removeFromSetlists = confirm(`Esta cancin est en los siguientes setlists: ${setlistNames}\n\nQuieres eliminarla tambin de estos setlists?`);

                    if (removeFromSetlists) {
                        // Remove song from setlists
                        for (const setlist of setlistsWithSong) {
                            const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlist.id);
                            const setlistSnap = await window.firebase.getDoc(setlistRef);
                            const setlistData = setlistSnap.data();

                            const updatedSongs = setlistData.songs.filter(song => song.id !== songId);

                            await window.firebase.updateDoc(setlistRef, {
                                songs: updatedSongs,
                                updatedAt: new Date()
                            });

                            console.log(' Removed song from setlist:', setlist.name);
                        }
                    }
                }

                // Delete audio files from B2 (if needed)
                if (songData.tracks && songData.tracks.length > 0) {
                    console.log(' Deleting audio files from B2...');
                    // Note: B2 file deletion would require additional API calls
                    // For now, we'll just delete the metadata
                    console.log(' Audio files in B2 will remain (manual cleanup needed)');
                }

                // Delete song document from Firestore
                await window.firebase.deleteDoc(songRef);
                console.log(' Song deleted from Firestore');

                // Refresh library
                loadLibrarySongs();

                alert(` Cancin "${songName}" eliminada correctamente`);

            } catch (error) {
                console.error(' Error deleting song:', error);
                alert('Error al eliminar la cancin: ' + error.message);
            }
        }

        // Show delete multiple songs modal
        async function showDeleteMultipleModal() {
            try {
                console.log(' Showing delete multiple songs modal...');

                // Get user's songs
                const songsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'songs'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );

                const querySnapshot = await window.firebase.getDocs(songsQuery);
                const songs = [];

                querySnapshot.forEach((doc) => {
                    songs.push({ id: doc.id, ...doc.data() });
                });

                if (songs.length === 0) {
                    alert('No tienes canciones en tu biblioteca para eliminar');
                    return;
                }

                // Create modal HTML
                const modalHTML = `
                    <div id="deleteMultipleModal" style="display: flex; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.8); align-items: center; justify-content: center; z-index: 10000;">
                        <div style="background-color: #1a1a1a; border-radius: 10px; padding: 30px; width: 600px; max-width: 90vw; max-height: 80vh; border: 1px solid #333; overflow-y: auto;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                                <h2 style="color: #fff; font-size: 24px; font-weight: bold; margin: 0;"> Eliminar Mltiples Canciones</h2>
                                <button onclick="hideDeleteMultipleModal()" style="background: none; border: none; color: #ccc; font-size: 24px; cursor: pointer; padding: 5px;"></button>
                            </div>
                            
                            <div style="margin-bottom: 20px; color: #ff4444; font-size: 14px;">
                                 Selecciona las canciones que quieres eliminar. Esta accin NO se puede deshacer.
                            </div>
                            
                            <div id="deleteSongsList" style="display: flex; flex-direction: column; gap: 10px; max-height: 400px; overflow-y: auto;">
                                ${songs.map(song => `
                                    <div style="display: flex; align-items: center; gap: 10px; padding: 10px; background: #222; border-radius: 6px;">
                                        <input type="checkbox" id="delete_${song.id}" value="${song.id}" style="transform: scale(1.2);">
                                        <div style="flex: 1;">
                                            <div style="color: #fff; font-weight: bold;">${song.name}</div>
                                            <div style="color: #888; font-size: 12px;">${song.tracks ? song.tracks.length : 0} tracks  ${new Date(song.createdAt?.toDate()).toLocaleDateString()}</div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                            
                            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                                <button onclick="hideDeleteMultipleModal()" style="padding: 12px 24px; background-color: #666; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;">Cancelar</button>
                                <button onclick="deleteSelectedSongs()" style="padding: 12px 24px; background-color: #ff4444; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;">Eliminar Seleccionadas</button>
                            </div>
                        </div>
                    </div>
                `;

                // Add modal to page
                document.body.insertAdjacentHTML('beforeend', modalHTML);

            } catch (error) {
                console.error(' Error showing delete multiple modal:', error);
                alert('Error al mostrar modal de eliminacin: ' + error.message);
            }
        }

        // Hide delete multiple modal
        function hideDeleteMultipleModal() {
            const modal = document.getElementById('deleteMultipleModal');
            if (modal) {
                modal.remove();
            }
        }

        // Delete selected songs
        async function deleteSelectedSongs() {
            try {
                console.log(' Deleting selected songs...');

                // Get selected songs
                const checkboxes = document.querySelectorAll('#deleteSongsList input[type="checkbox"]:checked');
                const selectedSongIds = Array.from(checkboxes).map(cb => cb.value);

                if (selectedSongIds.length === 0) {
                    alert('Por favor selecciona al menos una cancin para eliminar');
                    return;
                }

                const confirmMessage = `Ests seguro de que quieres eliminar ${selectedSongIds.length} cancin(es)?\n\nEsta accin NO se puede deshacer.`;

                if (!confirm(confirmMessage)) {
                    console.log(' Multiple deletion cancelled by user');
                    return;
                }

                console.log(' User confirmed multiple deletion');

                let deletedCount = 0;
                let errorCount = 0;

                // Delete each selected song
                for (const songId of selectedSongIds) {
                    try {
                        // Get song data
                        const songRef = window.firebase.doc(window.firebase.db, 'songs', songId);
                        const songSnap = await window.firebase.getDoc(songRef);

                        if (songSnap.exists()) {
                            const songData = songSnap.data();

                            // Remove from setlists
                            const setlistsQuery = window.firebase.query(
                                window.firebase.collection(window.firebase.db, 'setlists'),
                                window.firebase.where('userId', '==', currentUser.uid)
                            );

                            const setlistsSnapshot = await window.firebase.getDocs(setlistsQuery);

                            setlistsSnapshot.forEach(async (doc) => {
                                const setlistData = doc.data();
                                if (setlistData.songs && setlistData.songs.some(song => song.id === songId)) {
                                    const updatedSongs = setlistData.songs.filter(song => song.id !== songId);
                                    await window.firebase.updateDoc(doc.ref, {
                                        songs: updatedSongs,
                                        updatedAt: new Date()
                                    });
                                }
                            });

                            // Delete song document
                            await window.firebase.deleteDoc(songRef);
                            deletedCount++;
                            console.log(' Deleted song:', songData.name);
                        }
                    } catch (error) {
                        console.error(' Error deleting song:', songId, error);
                        errorCount++;
                    }
                }

                // Hide modal and refresh
                hideDeleteMultipleModal();
                loadLibrarySongs();

                if (errorCount === 0) {
                    alert(` ${deletedCount} cancin(es) eliminada(s) correctamente`);
                } else {
                    alert(` ${deletedCount} cancin(es) eliminada(s)\n ${errorCount} error(es) encontrado(s)`);
                }

            } catch (error) {
                console.error(' Error deleting selected songs:', error);
                alert('Error al eliminar canciones: ' + error.message);
            }
        }

        // Simple function to prepare tracks for setlist (no download)
        function prepareTracksForSetlist(songData) {
            console.log(' Preparing tracks for setlist:', songData.name);

            // Simply return the original tracks with B2 URLs
            return songData.tracks.map(track => ({
                ...track,
                originalUrl: track.downloadUrl,
                onlinePlayback: true
            }));
        }

        // Get file extension from URL
        function getFileExtension(url) {
            const match = url.match(/\.([^.?]+)(\?|$)/);
            return match ? match[1] : 'mp3';
        }

        // Retrieve audio from IndexedDB
        async function getAudioFromIndexedDB(path) {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('AudioCache', 1);

                request.onerror = () => reject(request.error);

                request.onsuccess = () => {
                    const db = request.result;
                    const transaction = db.transaction(['audioFiles'], 'readonly');
                    const store = transaction.objectStore('audioFiles');
                    const getRequest = store.get(path);

                    getRequest.onsuccess = () => {
                        if (getRequest.result) {
                            const objectUrl = URL.createObjectURL(getRequest.result.blob);
                            resolve(objectUrl);
                        } else {
                            reject(new Error('Audio not found in cache'));
                        }
                    };

                    getRequest.onerror = () => reject(getRequest.error);
                };
            });
        }

        // Show playback information for a setlist
        async function showDownloadInfo(setlistId) {
            try {
                console.log(' Showing playback info for setlist:', setlistId);

                // Get setlist data
                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistSnap = await window.firebase.getDoc(setlistRef);

                if (!setlistSnap.exists()) {
                    alert('Setlist no encontrado');
                    return;
                }

                const setlistData = setlistSnap.data();
                const songs = setlistData.songs || [];

                let onlineCount = 0;
                let totalTracks = 0;
                let playbackInfo = ` Informacin de Reproduccin - ${setlistData.name}\n\n`;

                songs.forEach(song => {
                    totalTracks += song.tracks ? song.tracks.length : 0;
                    if (song.onlinePlayback) {
                        onlineCount += song.tracks ? song.tracks.length : 0;
                        playbackInfo += ` ${song.name}: ${song.tracks ? song.tracks.length : 0} tracks (online)\n`;
                    } else {
                        playbackInfo += ` ${song.name}: No configurado\n`;
                    }
                });

                playbackInfo += `\n Resumen:\n`;
                playbackInfo += ` Total de tracks: ${totalTracks}\n`;
                playbackInfo += ` Tracks online: ${onlineCount}\n`;
                playbackInfo += ` Modo: Reproduccin online desde Backblaze B2\n\n`;
                playbackInfo += ` Los archivos se reproducen directamente desde la nube para una experiencia fluida.`;

                alert(playbackInfo);

            } catch (error) {
                console.error(' Error showing playback info:', error);
                alert('Error al mostrar informacin de reproduccin: ' + error.message);
            }
        }

        // Test B2 URL accessibility
        async function testB2UrlAccessibility(url) {
            try {
                console.log(' Testing B2 URL accessibility:', url);

                const response = await fetch(url, {
                    method: 'HEAD',
                    mode: 'cors'
                });

                console.log(' Response status:', response.status);
                console.log(' Response headers:', Object.fromEntries(response.headers.entries()));

                if (response.ok) {
                    console.log(' B2 URL is accessible');
                    return { accessible: true, status: response.status, headers: response.headers };
                } else {
                    console.log(' B2 URL returned error:', response.status, response.statusText);
                    return { accessible: false, status: response.status, error: response.statusText };
                }

            } catch (error) {
                console.error(' Error testing B2 URL:', error);
                return { accessible: false, error: error.message };
            }
        }

        // Test a specific B2 URL directly
        async function testSpecificB2Url() {
            // Use one of the URLs from the logs
            const testUrl = 'https://f005.backblazeb2.com/file/cc12bbd592366bde909b0a1a/audio_Xj0QCnL6W2hdWAs3ZA6aAKQPhzo2_1758489707663_Click.wav';

            console.log(' Testing specific B2 URL with CORS enabled...');
            const result = await testB2UrlAccessibility(testUrl);

            if (result.accessible) {
                alert(` CORS funcionando!\n\n URL: ${testUrl}\n Estado: ${result.status}\n\n Las reglas CORS de B2 estn configuradas correctamente.`);
            } else {
                alert(` CORS an no funciona\n\n URL: ${testUrl}\n Estado: ${result.status}\n Error: ${result.error}\n\n Las reglas CORS pueden tardar unos minutos en propagarse.`);
            }

            return result;
        }

        // Test setlist audio
        async function testSetlistAudio(setlistId) {
            try {
                console.log(' Testing setlist audio for:', setlistId);

                // Get setlist data
                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistSnap = await window.firebase.getDoc(setlistRef);

                if (!setlistSnap.exists()) {
                    alert('Setlist no encontrado');
                    return;
                }

                const setlistData = setlistSnap.data();
                const songs = setlistData.songs || [];

                if (songs.length === 0) {
                    alert('No hay canciones en este setlist para probar');
                    return;
                }

                // Test the first song
                const firstSong = songs[0];
                console.log(' Testing first song:', firstSong.name);

                if (firstSong.tracks && firstSong.tracks.length > 0) {
                    const firstTrack = firstSong.tracks[0];
                    console.log(' Testing first track:', firstTrack.name);

                    // Test audio loading
                    const audioUrl = firstTrack.originalUrl || firstTrack.downloadUrl;
                    if (audioUrl) {
                        console.log(' Testing audio URL:', audioUrl);

                        // Test URL accessibility with CORS enabled
                        console.log(' Testing B2 URL with CORS enabled...');
                        const urlTest = await testB2UrlAccessibility(audioUrl);

                        if (urlTest.accessible) {
                            console.log(' B2 URL is accessible with CORS, testing audio playback...');
                            testAudioWithUrl(audioUrl, firstSong, firstTrack);
                        } else {
                            console.error(' B2 URL is not accessible:', urlTest);
                            alert(` URL no accesible\n\n URL: ${audioUrl}\n\n Estado: ${urlTest.status || 'Error'}\n Error: ${urlTest.error || 'Desconocido'}\n\n Posibles causas:\n Archivo no existe en B2\n URL mal formada\n Reglas CORS no configuradas\n Archivo corrupto\n\n Si acabas de configurar CORS, espera unos minutos para que se propague.`);
                        }

                    } else {
                        alert(' No se encontr URL de audio para probar');
                    }
                } else {
                    alert(' No hay tracks en la primera cancin para probar');
                }

            } catch (error) {
                console.error(' Error testing setlist audio:', error);
                alert('Error al probar audio del setlist: ' + error.message);
            }
        }

        // PADS functionality with ambient sounds (monophonic mode - only one pad at a time)
        let activePad = null; // Store only one active pad
        let padsVolume = 0.7; // Default volume for pads (70%)
        let padsAudioContext = null; // Separate audio context for PADS (isolated from EQ)

        // Initialize separate audio context for PADS (isolated from EQ)
        function initPadsAudioContext() {
            if (!padsAudioContext) {
                try {
                    padsAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log(' PADS Audio Context initialized (isolated)');
                } catch (error) {
                    console.error(' Error initializing PADS audio context:', error);
                }
            }
            return padsAudioContext;
        }


        // Octave control functions
        let currentOctave = 4; // Default octave 4 (can go 2-6)

        // Trigger pad with celestial Tone.js sounds
        async function triggerPad(fullNote) {
            try {
                console.log(` Triggering celestial pad: ${fullNote}`);

                // Find the button that was clicked
                const buttons = document.querySelectorAll('.pad-button');
                let clickedButton = null;
                buttons.forEach(btn => {
                    if (btn.textContent === fullNote.replace('4', '') ||
                        btn.textContent === fullNote.replace('#4', '#') ||
                        btn.textContent === fullNote.replace('b4', 'b')) {
                        clickedButton = btn;
                    }
                });

                if (!clickedButton) {
                    console.warn(' Button not found for note:', fullNote);
                    return;
                }

                const isActive = clickedButton.classList.contains('active');

                if (isActive) {
                    // Turn OFF
                    clickedButton.classList.remove('active');
                    stopCelestialPad();
                    console.log(` Celestial pad stopped: ${fullNote}`);
                } else {
                    // Turn OFF all other pads first (monophonic)
                    buttons.forEach(btn => btn.classList.remove('active'));

                    // Turn ON this pad
                    clickedButton.classList.add('active');
                    await playCelestialPad(fullNote);
                    console.log(` Celestial pad playing: ${fullNote}`);
                }

            } catch (error) {
                console.error(' Error triggering pad:', error);
            }
        }

        // Play celestial pad with Tone.js
        async function playCelestialPad(note) {
            try {
                // Initialize Tone.js pad sampler if not done
                if (!window.celestialPadSampler) {
                    console.log(' Initializing Celestial Pad Sampler...');

                    // Create PolySynth with lush ambient sound
                    window.celestialPadSampler = new Tone.PolySynth(Tone.Synth, {
                        oscillator: {
                            type: 'sine'
                        },
                        envelope: {
                            attack: 1.5,      // Faster attack for better response
                            decay: 1.0,
                            sustain: 0.9,     // High sustain
                            release: 4.0      // Long release
                        },
                        volume: -6           // Louder for better audibility
                    });

                    // Create reverb for spaciousness
                    const reverb = new Tone.Reverb({
                        decay: 10,           // Very long decay
                        wet: 0.8             // 80% wet
                    });

                    // Create chorus for richness
                    const chorus = new Tone.Chorus({
                        frequency: 1.2,
                        delayTime: 4,
                        depth: 0.8,
                        wet: 0.6
                    });

                    // Create filter for warmth
                    const filter = new Tone.Filter({
                        frequency: 2000,
                        type: 'lowpass',
                        rolloff: -24
                    });

                    // Connect effects chain
                    window.celestialPadSampler.chain(filter, chorus, reverb, Tone.Destination);

                    console.log(' Celestial Pad Sampler initialized');
                }

                // Start Tone.js if needed
                if (Tone.context.state !== 'running') {
                    await Tone.start();
                }

                // Stop any currently playing note with immediate release
                if (window.currentCelestialNote) {
                    window.celestialPadSampler.triggerRelease(window.currentCelestialNote);
                    // Small delay to allow release to start
                    await new Promise(resolve => setTimeout(resolve, 50));
                }

                // Play the new note
                window.celestialPadSampler.triggerAttack(note);
                window.currentCelestialNote = note;

                console.log(` Celestial pad playing: ${note}`);

            } catch (error) {
                console.error(' Error playing celestial pad:', error);
            }
        }

        // Stop celestial pad
        function stopCelestialPad() {
            try {
                if (window.celestialPadSampler && window.currentCelestialNote) {
                    window.celestialPadSampler.triggerRelease(window.currentCelestialNote);
                    window.currentCelestialNote = null;
                    console.log(' Celestial pad stopped');
                }
            } catch (error) {
                console.error(' Error stopping celestial pad:', error);
            }
        }

        // Initialize pad event listeners
        function initializePads() {
            console.log(' Pads initialized with celestial Tone.js sounds');
            // Pads are now using onclick in HTML with triggerPad()
        }

        // Trigger pad with current octave (wrapper function)
        function triggerPadWithOctave(noteName) {
            const fullNote = `${noteName}${currentOctave}`;
            console.log(` Pad pressed: ${noteName}  Playing: ${fullNote} (Octave ${currentOctave})`);
            triggerPad(fullNote);
        }

        function increaseOctave() {
            if (currentOctave < 6) { // Max octave 6 (4 + 2)
                currentOctave++;
                updateOctaveDisplay();
                updatePadNotes();
                console.log(' Octave increased to:', currentOctave);
            } else {
                console.log(' Maximum octave reached (6)');
            }
        }

        function decreaseOctave() {
            if (currentOctave > 2) { // Min octave 2 (4 - 2)
                currentOctave--;
                updateOctaveDisplay();
                updatePadNotes();
                console.log(' Octave decreased to:', currentOctave);
            } else {
                console.log(' Minimum octave reached (2)');
            }
        }

        function updateOctaveDisplay() {
            const octaveDisplay = document.getElementById('octaveDisplay');
            if (octaveDisplay) {
                octaveDisplay.textContent = currentOctave;
            }
        }

        function updatePadNotes() {
            // No longer needed - buttons now use triggerPadWithOctave() which handles octave dynamically
            // This function was causing duplicate event listeners
            console.log(' Octave changed - pads will use new octave on next click');
        }

        // Trigger pad with Tone.js celestial sounds (UPDATED VERSION - supports all octaves)
        async function triggerPad(note) {
            console.log(' Triggering celestial pad:', note);

            try {
                // Extract note name without octave (e.g., "C#" from "C#4")
                const noteWithoutOctave = note.replace(/[0-9]/g, '');

                // Get all pad buttons
                const padButtons = document.querySelectorAll('.pad-button');

                // Find button by matching note name (without octave)
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'Bb', 'B'];
                const buttonIndex = noteNames.indexOf(noteWithoutOctave);
                const padButton = padButtons[buttonIndex];

                if (!padButton) {
                    console.error(' Pad button not found for note:', note);
                    return;
                }

                // If this pad is already active, stop it
                if (activePad === note) {
                    stopCelestialPad();
                    padButton.classList.remove('active');
                    activePad = null;
                    console.log(' Celestial pad stopped:', note);
                } else {
                    // Stop any currently active pad
                    if (activePad) {
                        // Find and deactivate the previously active button
                        const prevNoteWithoutOctave = activePad.replace(/[0-9]/g, '');
                        const prevButtonIndex = noteNames.indexOf(prevNoteWithoutOctave);
                        if (prevButtonIndex !== -1 && padButtons[prevButtonIndex]) {
                            padButtons[prevButtonIndex].classList.remove('active');
                        }
                        stopCelestialPad();
                    }

                    // Start the new celestial pad
                    await playCelestialPad(note);
                    padButton.classList.add('active');
                    activePad = note;
                    console.log(' Celestial pad playing:', note);
                }
            } catch (error) {
                console.error(' Error in triggerPad:', error);
            }
        }

        // Create ambient pad synthesizer
        function createAmbientPad() {
            if (typeof Tone === 'undefined') {
                console.warn(' Tone.js not loaded, using fallback audio');
                return null;
            }

            // Create a beautiful ambient pad synthesizer
            const padSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: {
                    type: "sawtooth"
                },
                envelope: {
                    attack: 0.5,
                    decay: 0.3,
                    sustain: 0.7,
                    release: 2.0
                },
                filter: {
                    Q: 1,
                    type: "lowpass",
                    rolloff: -24
                },
                filterEnvelope: {
                    attack: 0.5,
                    decay: 0.2,
                    sustain: 0.3,
                    release: 1.5,
                    baseFrequency: 200,
                    octaves: 2
                }
            }).toDestination();

            // Add reverb for ambient effect
            const reverb = new Tone.Reverb({
                decay: 3.5,
                preDelay: 0.01
            }).toDestination();

            // Add chorus for richness
            const chorus = new Tone.Chorus({
                frequency: 1.5,
                delayTime: 3.5,
                depth: 0.7,
                type: "sine"
            }).connect(reverb);

            // Connect the synth through effects
            padSynth.connect(chorus);

            return padSynth;
        }

        // Play ambient pad sound (sustained) - using isolated audio context
        function playAmbientPad(note) {
            // Initialize PADS audio context (separate from main audio)
            const padsContext = initPadsAudioContext();
            if (!padsContext) {
                console.error(' Could not initialize PADS audio context');
                return;
            }

            if (typeof Tone !== 'undefined' && toneInitialized) {
                // Use Tone.js for high-quality ambient sounds
                if (!window.ambientPadSynth) {
                    window.ambientPadSynth = createAmbientPad();
                }

                if (window.ambientPadSynth) {
                    // Start the note (sustained)
                    window.ambientPadSynth.triggerAttack(note);
                    console.log(' Playing sustained ambient pad (Tone.js):', note);
                }
            } else {
                // Fallback: create a sustained ambient tone with Web Audio API (isolated)
                createSustainedAmbientPad(note);
            }
        }

        // Stop ambient pad sound
        function stopAmbientPad(note) {
            try {
                // Stop Tone.js pad sampler
                if (window.padSampler && window.currentPadNote) {
                    window.padSampler.triggerRelease(window.currentPadNote);
                    console.log(' Stopped Tone.js celestial pad:', window.currentPadNote);
                    window.currentPadNote = null;
                }

                // Fallback: Stop Web Audio API oscillator if exists
                if (window.currentPadOscillator) {
                    try {
                        window.currentPadOscillator.stop();
                    } catch (e) { }
                    window.currentPadOscillator = null;
                    console.log(' Stopped Web Audio pad');
                }
            } catch (error) {
                console.error(' Error stopping pad:', error);
            }
        }


        // DEPRECATED: Old system - now redirects to Tone.js celestial pads
        async function createSustainedAmbientPad(note) {
            console.log(' Old pad system called, redirecting to Tone.js celestial pads...');
            await playCelestialPad(note);
        }

        // DEPRECATED: Fallback - now redirects to Tone.js
        async function createFallbackAmbientPad(note) {
            console.log(' Fallback pad called, using Tone.js instead...');
            await playCelestialPad(note);
        }

        // Convert note to frequency
        function getFrequencyFromNote(note) {
            const noteFrequencies = {
                'C4': 261.63,
                'C#4': 277.18,
                'D4': 293.66,
                'D#4': 311.13,
                'E4': 329.63,
                'F4': 349.23,
                'F#4': 369.99,
                'G4': 392.00,
                'G#4': 415.30,
                'A4': 440.00,
                'Bb4': 466.16,
                'B4': 493.88
            };
            return noteFrequencies[note] || 440;
        }

        // Test audio with specific URL
        function testAudioWithUrl(audioUrl, firstSong, firstTrack) {
            console.log(' Testing audio with URL:', audioUrl);

            // Create a test audio element
            const testAudio = new Audio();
            testAudio.src = audioUrl;

            testAudio.onloadeddata = () => {
                console.log(' Audio loaded successfully');
                alert(` Audio funcionando correctamente\n\n Cancin: ${firstSong.name}\n Track: ${firstTrack.name}\n Duracin: ${testAudio.duration.toFixed(2)} segundos\n URL: ${audioUrl}\n\n Reproduccin online desde Backblaze B2 funcionando perfectamente.`);
            };

            testAudio.onerror = (error) => {
                console.error(' Audio loading error:', error);
                console.error(' Audio element error details:', {
                    error: error,
                    src: testAudio.src,
                    networkState: testAudio.networkState,
                    readyState: testAudio.readyState
                });

                let errorMessage = 'Error desconocido';
                if (testAudio.error) {
                    switch (testAudio.error.code) {
                        case 1:
                            errorMessage = 'MEDIA_ERR_ABORTED - El usuario cancel la carga';
                            break;
                        case 2:
                            errorMessage = 'MEDIA_ERR_NETWORK - Error de red';
                            break;
                        case 3:
                            errorMessage = 'MEDIA_ERR_DECODE - Error al decodificar el archivo';
                            break;
                        case 4:
                            errorMessage = 'MEDIA_ERR_SRC_NOT_SUPPORTED - Formato no soportado';
                            break;
                        default:
                            errorMessage = `Error de cdigo: ${testAudio.error.code}`;
                    }
                }

                const networkStateText = {
                    0: 'EMPTY',
                    1: 'IDLE',
                    2: 'LOADING',
                    3: 'NO_SOURCE'
                };

                const readyStateText = {
                    0: 'NOTHING',
                    1: 'METADATA',
                    2: 'CURRENT_DATA',
                    3: 'FUTURE_DATA',
                    4: 'ENOUGH_DATA'
                };

                alert(` Error al cargar audio\n\n Cancin: ${firstSong.name}\n Track: ${firstTrack.name}\n URL: ${audioUrl}\n\n Estado del elemento:\n Network: ${testAudio.networkState} (${networkStateText[testAudio.networkState]})\n Ready: ${testAudio.readyState} (${readyStateText[testAudio.readyState]})\n\n Error: ${errorMessage}\n\n Diagnstico:\n Network 3 = No se pudo encontrar el recurso\n Ready 0 = No hay datos disponibles\n\n Posibles soluciones:\n Verificar que la URL sea correcta\n Comprobar que el archivo existe en B2\n Revisar la configuracin de CORS\n Probar con un archivo ms pequeo`);
            };

            // Try to load the audio
            testAudio.load();
        }

        // Add song to setlist
        async function addToSetlist(songId) {
            try {
                console.log(' Adding song to setlist:', songId);

                if (!currentSetlist) {
                    alert(' No hay setlist activo. Crea un setlist primero.');
                    return;
                }

                // Get full song data from Firestore
                const songRef = window.firebase.doc(window.firebase.db, 'songs', songId);
                const songSnap = await window.firebase.getDoc(songRef);

                if (!songSnap.exists()) {
                    alert(' Cancin no encontrada en la biblioteca.');
                    return;
                }

                const fullSongData = songSnap.data();
                console.log(' Full song data for setlist:', fullSongData);

                // Check if song is already in setlist
                const existingSong = currentSetlist.songs.find(song => song.id === songId);
                if (existingSong) {
                    alert(' Esta cancin ya est en el setlist.');
                    return;
                }

                // Add song to setlist with complete information
                const newSong = {
                    id: songId,
                    name: fullSongData.name || '',
                    artist: fullSongData.artist || '',
                    tempo: fullSongData.tempo || null,
                    key: fullSongData.key || '',
                    timeSignature: fullSongData.timeSignature || '',
                    tracks: fullSongData.tracks || [],
                    order: currentSetlist.songs.length + 1
                };

                currentSetlist.songs.push(newSong);

                // Save to Firebase
                await saveSetlistToFirebase(currentSetlist);

                // Update display
                loadCurrentSetlistForSidebar();
                updateSetlistDisplay();

                // Update main setlist display
                if (currentSetlist.songs && currentSetlist.songs.length > 0) {
                    displaySongs(currentSetlist.songs);
                }

                console.log(' Song added to setlist:', fullSongData.name);
                alert(` "${fullSongData.name}" agregada al setlist`);

            } catch (error) {
                console.error(' Error adding song to setlist:', error);
                alert(' Error al agregar cancin al setlist: ' + error.message);
            }
        }

        // Download song locally
        async function downloadSong(songId) {
            // TODO: Implement local download functionality
            console.log(' Downloading song locally:', songId);
        }

        // Offline Cache System Functions (variables already declared above)

        // Helper to get backend URL (handles dev vs prod)
        function getBackendUrl() {
            // If running on dev server (local development), backend is on port 3001
            // Adjust this port check if you run on different ports
            if (window.location.hostname === 'localhost' && (window.location.port !== '3001' && window.location.port !== '')) {
                return 'http://localhost:3001';
            }
            // Otherwise (production or running via b2-proxy directly), use relative path
            return '';
        }

        // Initialize offline cache system (PERSISTENT)
        function initOfflineCache() {
            console.log(' Initializing PERSISTENT offline cache system...');
            try {
                // Load cache index from localStorage
                const savedIndex = localStorage.getItem(CACHE_STORAGE_KEY);
                if (savedIndex) {
                    cacheIndex = JSON.parse(savedIndex);
                    console.log(` Loaded PERSISTENT cache index: ${cacheIndex.length} songs`);

                    // Populate offlineCache map and show details
                    let persistentCount = 0;
                    let totalSize = 0;

                    cacheIndex.forEach(entry => {
                        offlineCache.set(entry.songId, entry);
                        if (entry.persistent) {
                            persistentCount++;
                            totalSize += entry.fileSize || 0;
                        }
                    });

                    console.log(` PERSISTENT songs found: ${persistentCount}/${cacheIndex.length}`);
                    console.log(` Total persistent cache size: ${(totalSize / 1024 / 1024).toFixed(2)}MB`);

                    if (persistentCount > 0) {
                        console.log(` These songs will load INSTANTLY after app restart!`);
                        cacheIndex.forEach(entry => {
                            if (entry.persistent) {
                                console.log(`    ${entry.songName} (${entry.trackCount} tracks, ${((entry.fileSize || 0) / 1024 / 1024).toFixed(2)}MB)`);
                            }
                        });
                    }
                } else {
                    console.log(' No persistent cache found - first time setup');
                }

                // Check cache integrity
                checkCacheIntegrity();
                console.log(' PERSISTENT offline cache system initialized');
            } catch (error) {
                console.error(' Error initializing persistent offline cache:', error);
                cacheIndex = [];
                offlineCache.clear();
            }
        }

        // Check if song is cached offline
        function isSongCachedOffline(songId) {
            return offlineCache.has(songId);
        }

        // Download song for offline use (PERSISTENT CACHE)
        async function downloadSongForOffline(songId, songData) {
            try {
                console.log(` Downloading song for PERSISTENT offline use: ${songId}`);

                if (!songData || !songData.tracks) {
                    console.log(' No song data or tracks available for offline download');
                    return false;
                }

                let downloadedTracks = 0;
                const totalTracks = songData.tracks.length;
                let totalSize = 0;

                for (let i = 0; i < songData.tracks.length; i++) {
                    const track = songData.tracks[i];
                    if (track.downloadUrl) {
                        try {
                            console.log(` Downloading track ${track.id} for persistent cache...`);

                            // Download track audio (using backend proxy to avoid CORS)
                            const backendUrl = getBackendUrl();
                            const proxyUrl = `${backendUrl}/download?url=${encodeURIComponent(track.downloadUrl)}`;
                            console.log(` Using proxy: ${proxyUrl}`);
                            const response = await fetch(proxyUrl);
                            const audioBlob = await response.blob();

                            console.log(` Track ${track.id || 'unknown'} downloaded: ${(audioBlob.size / 1024 / 1024).toFixed(2)}MB`);

                            // Convert to base64 for storage
                            const reader = new FileReader();
                            const audioData = await new Promise((resolve, reject) => {
                                reader.onload = () => resolve(reader.result);
                                reader.onerror = reject;
                                reader.readAsDataURL(audioBlob);
                            });

                            // Store in localStorage with quota management
                            if (audioBlob.size < 50 * 1024 * 1024) { // Reduced to 50MB limit per track
                                const trackId = track.id || `track_${i + 1}`;
                                const storageKey = `${CACHE_PREFIX}${songId}_${trackId}`;

                                try {
                                    // Check available space before storing
                                    const currentUsage = getCurrentStorageUsage();
                                    const availableSpace = getAvailableStorageSpace();

                                    if (audioBlob.size > availableSpace) {
                                        console.log(` Not enough space for track ${track.id}: ${(audioBlob.size / 1024 / 1024).toFixed(2)}MB needed, ${(availableSpace / 1024 / 1024).toFixed(2)}MB available`);
                                        console.log(` Clearing old cache to make space...`);
                                        clearOldestCacheEntries();
                                    }

                                    localStorage.setItem(storageKey, audioData);
                                    totalSize += audioBlob.size;
                                    console.log(` PERSISTENTLY cached track ${track.id} for song ${songId} (${(audioBlob.size / 1024 / 1024).toFixed(2)}MB)`);
                                    downloadedTracks++;
                                } catch (quotaError) {
                                    console.error(` Storage quota exceeded for track ${track.id}:`, quotaError);
                                    console.log(` Attempting to clear cache and retry...`);

                                    // Clear some old entries and retry
                                    clearOldestCacheEntries();

                                    try {
                                        localStorage.setItem(storageKey, audioData);
                                        totalSize += audioBlob.size;
                                        console.log(` PERSISTENTLY cached track ${track.id} after cleanup (${(audioBlob.size / 1024 / 1024).toFixed(2)}MB)`);
                                        downloadedTracks++;
                                    } catch (retryError) {
                                        console.error(` Still cannot store track ${track.id} after cleanup:`, retryError);
                                    }
                                }
                            } else {
                                console.log(` Track ${track.id || 'unknown'} too large for persistent cache: ${(audioBlob.size / 1024 / 1024).toFixed(2)}MB`);
                                console.log(` Storing only metadata - will need to re-download on next use`);

                                // Store only metadata for large files
                                const trackId = track.id || `track_${i + 1}`;
                                const metadataKey = `${CACHE_PREFIX}${songId}_${trackId}_meta`;
                                const metadata = {
                                    name: track.name || `Track ${i + 1}`,
                                    size: audioBlob.size,
                                    downloadUrl: track.downloadUrl,
                                    cached: false,
                                    largeFile: true
                                };

                                try {
                                    localStorage.setItem(metadataKey, JSON.stringify(metadata));
                                    console.log(` Stored metadata for large track: ${track.name || trackId}`);
                                } catch (metaError) {
                                    console.error(` Cannot even store metadata:`, metaError);
                                }
                            }
                        } catch (error) {
                            console.error(` Error downloading track ${track.id} for persistent cache:`, error);
                        }
                    }
                }

                if (downloadedTracks > 0) {
                    // Update cache index with persistent flag and full song data
                    const cacheEntry = {
                        songId: songId,
                        songName: songData.name,
                        downloadedAt: new Date().toISOString(),
                        fileSize: totalSize,
                        version: 1,
                        trackCount: downloadedTracks,
                        persistent: true, // Mark as persistent
                        songData: songData // Store full song data for instant loading
                    };

                    // Remove existing entry if any
                    cacheIndex = cacheIndex.filter(entry => entry.songId !== songId);
                    cacheIndex.push(cacheEntry);

                    offlineCache.set(songId, cacheEntry);
                    localStorage.setItem(CACHE_STORAGE_KEY, JSON.stringify(cacheIndex));

                    console.log(` Song PERSISTENTLY cached offline: ${songData.name} (${downloadedTracks}/${totalTracks} tracks, ${(totalSize / 1024 / 1024).toFixed(2)}MB total)`);
                    console.log(` Cache will survive app restart and browser refresh!`);
                    return true;
                }

                return false;
            } catch (error) {
                console.error(' Error downloading song for persistent offline:', error);
                return false;
            }
        }

        // Load song from offline cache (PERSISTENT) - supports both localStorage and disk
        async function loadSongFromOfflineCache(songId) {
            try {
                console.log(` Loading song from PERSISTENT offline cache: ${songId}`);

                const cacheEntry = offlineCache.get(songId);
                if (!cacheEntry) {
                    console.log(' Song not found in offline cache:', songId);
                    return false;
                }

                console.log(` Found persistent cache entry: ${cacheEntry.songName} (${cacheEntry.trackCount} tracks)`);

                // Check if song is stored on disk (new method)
                if (cacheEntry.storageType === 'disk' && cacheEntry.diskPath) {
                    console.log(` Loading song from DISK: ${cacheEntry.diskPath}`);
                    console.log(` Disk path: ${cacheEntry.diskPath}`);
                    console.log(` Song data:`, cacheEntry.songData);
                    return await loadSongFromDisk(songId, cacheEntry);
                }

                // Fallback: Load from localStorage (old method)
                console.log(` Loading song from localStorage cache...`);
                return loadSongFromLocalStorage(songId, cacheEntry);

            } catch (error) {
                console.error(' Error loading song from persistent offline cache:', error);
                return false;
            }
        }

        // Load song from disk storage
        async function loadSongFromDisk(songId, cacheEntry) {
            try {
                console.log(` Loading song from disk storage: ${cacheEntry.songName}`);
                console.log(` Cache entry details:`, cacheEntry);

                if (!cacheEntry.songData || !cacheEntry.songData.tracks) {
                    console.log(' No song data available for disk loading');
                    console.log(' Cache entry:', cacheEntry);
                    return false;
                }

                console.log(` Attempting to access disk directory: ${cacheEntry.diskPath}`);

                // Check if File System Access API is supported
                if (!('storage' in navigator) || !navigator.storage.getDirectory) {
                    console.log(' File System Access API not supported');
                    return false;
                }

                // Load tracks from disk
                const diskTracks = [];
                for (let i = 0; i < cacheEntry.songData.tracks.length; i++) {
                    const originalTrack = cacheEntry.songData.tracks[i];
                    const trackId = originalTrack.id || `track_${i + 1}`;

                    try {
                        console.log(` Loading track ${i + 1}/${cacheEntry.songData.tracks.length}: ${originalTrack.name}`);

                        // Get file from disk using File System Access API
                        const cacheDir = await navigator.storage.getDirectory();
                        console.log(` Got cache directory:`, cacheDir);

                        const songDir = await cacheDir.getDirectoryHandle(cacheEntry.diskPath);
                        console.log(` Got song directory:`, songDir);

                        const fileName = `${trackId}_${originalTrack.name.replace(/[^a-zA-Z0-9]/g, '_')}.wav`;
                        console.log(` Looking for file: ${fileName}`);

                        const fileHandle = await songDir.getFileHandle(fileName);
                        console.log(` Got file handle:`, fileHandle);

                        const file = await fileHandle.getFile();
                        console.log(` Got file:`, file.name, file.size);

                        // Create object URL for audio playback
                        const audioUrl = URL.createObjectURL(file);
                        console.log(` Created object URL: ${audioUrl}`);

                        diskTracks.push({
                            id: originalTrack.id || `track_${i + 1}`,
                            name: originalTrack.name || `Track ${i + 1}`,
                            audioUrl: audioUrl,
                            cached: true,
                            fromDisk: true,
                            originalTrack: originalTrack
                        });

                        console.log(` Loaded track from disk: ${originalTrack.name}`);

                    } catch (error) {
                        console.error(` Error loading track ${originalTrack.name} from disk:`, error);
                        console.error(` Track ID: ${trackId}, File name: ${fileName}`);
                    }
                }

                if (diskTracks.length > 0) {
                    // Stop all current playback before loading new song
                    console.log(' Stopping all current playback before loading from disk...');
                    isPlaying = false;
                    stopAllTracks();
                    stopAllAudioSources();
                    stopTimeUpdate();
                    stopVUMeters();

                    // Clear all audio sources and gain nodes
                    audioSources.clear();
                    gainNodes.clear();
                    analysers.clear();

                    // Clear tracks array to prevent mixing
                    tracks = [];
                    window.tracks = [];

                    // Update play button
                    const playBtn = document.getElementById('playBtn');
                    if (playBtn) {
                        playBtn.textContent = '';
                        playBtn.classList.remove('active');
                    }

                    // Reset all track playing states
                    tracks.forEach(track => {
                        track.playing = false;
                    });

                    // Reset playback time
                    pausedTime = 0;

                    // Set tracks for playback
                    window.tracks = diskTracks;
                    tracks = diskTracks; // Also set the global tracks variable
                    currentLoadedSongId = songId;

                    console.log(` Loaded ${diskTracks.length} tracks from disk for song: ${cacheEntry.songName}`);
                    console.log(` INSTANT loading from disk - no download needed!`);
                    console.log(` Tracks ready for playback:`, diskTracks.map(t => t.name));

                    // Assign colors to tracks
                    assignTrackColors(diskTracks);

                    // Load audio buffers for playback FIRST
                    await loadAudioBuffersFromTracks(diskTracks);

                    // Update the mixer interface AFTER buffers are loaded
                    updateTracksGrid();
                    updateCurrentSongLedDisplay(cacheEntry.songName);

                    return true;
                } else {
                    console.log(' No tracks were loaded from disk');
                    return false;
                }

            } catch (error) {
                console.error(' Error loading song from disk:', error);
                console.error(' Full error details:', error);
                return false;
            }
        }

        // Load song from localStorage cache (fallback)
        async function loadSongFromLocalStorage(songId, cacheEntry) {
            try {
                console.log(` Loading song from localStorage cache...`);

                // Use stored song data if available (for instant loading)
                if (cacheEntry.songData && cacheEntry.songData.tracks) {
                    console.log(` Using stored song data for instant loading...`);

                    // Load cached tracks from localStorage with original track names
                    const cachedTracks = [];
                    for (let i = 0; i < cacheEntry.songData.tracks.length; i++) {
                        const originalTrack = cacheEntry.songData.tracks[i];
                        const storageKey = `${CACHE_PREFIX}${songId}_${originalTrack.id}`;
                        const cachedData = localStorage.getItem(storageKey);

                        if (cachedData) {
                            cachedTracks.push({
                                id: originalTrack.id || `track_${i + 1}`,
                                name: originalTrack.name || `Track ${i + 1}`,
                                audioUrl: cachedData, // base64 data URL
                                cached: true,
                                originalTrack: originalTrack
                            });
                        }
                    }

                    if (cachedTracks.length > 0) {
                        // Stop all current playback before loading new song
                        console.log(' Stopping all current playback before loading from localStorage...');
                        isPlaying = false;
                        stopAllTracks();
                        stopAllAudioSources();
                        stopTimeUpdate();
                        stopVUMeters();

                        // Clear all audio sources and gain nodes
                        audioSources.clear();
                        gainNodes.clear();
                        analysers.clear();

                        // Clear tracks array to prevent mixing
                        tracks = [];
                        window.tracks = [];

                        // Update play button
                        const playBtn = document.getElementById('playBtn');
                        if (playBtn) {
                            playBtn.textContent = '';
                            playBtn.classList.remove('active');
                        }

                        // Reset all track playing states
                        tracks.forEach(track => {
                            track.playing = false;
                        });

                        window.tracks = cachedTracks;
                        tracks = cachedTracks; // Also set the global tracks variable
                        currentLoadedSongId = songId;

                        console.log(` Loaded ${cachedTracks.length} cached tracks for song: ${cacheEntry.songName}`);
                        console.log(` INSTANT loading from localStorage cache!`);

                        // Assign colors to tracks
                        assignTrackColors(cachedTracks);

                        // Load audio buffers for playback FIRST
                        await loadAudioBuffersFromTracks(cachedTracks);

                        // Update the mixer interface AFTER buffers are loaded
                        updateTracksGrid();
                        updateCurrentSongLedDisplay(cacheEntry.songName);

                        return true;
                    }
                }

                // Fallback: Load tracks by index (older cache format)
                console.log(` Loading tracks by index (fallback method)...`);
                const cachedTracks = [];
                for (let i = 1; i <= cacheEntry.trackCount; i++) {
                    const storageKey = `${CACHE_PREFIX}${songId}_${i}`;
                    const cachedData = localStorage.getItem(storageKey);

                    if (cachedData) {
                        cachedTracks.push({
                            id: i,
                            name: `Track ${i}`,
                            audioUrl: cachedData,
                            cached: true
                        });
                    }
                }

                if (cachedTracks.length > 0) {
                    window.tracks = cachedTracks;
                    console.log(` Loaded ${cachedTracks.length} cached tracks for song: ${songId}`);
                    return true;
                }

                return false;

            } catch (error) {
                console.error(' Error loading song from localStorage:', error);
                return false;
            }
        }

        // Check cache integrity (PERSISTENT)
        function checkCacheIntegrity() {
            console.log(' Checking PERSISTENT cache integrity...');
            let validEntries = 0;
            let totalSize = 0;
            let persistentEntries = 0;
            let persistentSize = 0;

            cacheIndex.forEach(entry => {
                const storageKey = `${CACHE_PREFIX}${entry.songId}_1`; // Check first track
                if (localStorage.getItem(storageKey)) {
                    validEntries++;
                    totalSize += entry.fileSize || 0;

                    if (entry.persistent) {
                        persistentEntries++;
                        persistentSize += entry.fileSize || 0;
                    }
                }
            });

            console.log(` PERSISTENT cache integrity check complete:`);
            console.log(`    Total valid entries: ${validEntries}/${cacheIndex.length}`);
            console.log(`    PERSISTENT entries: ${persistentEntries} (survive app restart)`);
            console.log(`    Total cache size: ${(totalSize / 1024 / 1024).toFixed(2)}MB`);
            console.log(`    PERSISTENT cache size: ${(persistentSize / 1024 / 1024).toFixed(2)}MB`);

            if (persistentEntries > 0) {
                console.log(` ${persistentEntries} songs ready for INSTANT loading after restart!`);
            }
        }

        // Get cache statistics
        function getCacheStats() {
            return {
                totalSongs: cacheIndex.length,
                totalSize: cacheIndex.reduce((total, entry) => total + (entry.fileSize || 0), 0),
                validEntries: Array.from(offlineCache.keys()).length
            };
        }

        // Get current storage usage
        function getCurrentStorageUsage() {
            let totalSize = 0;
            for (let key in localStorage) {
                if (localStorage.hasOwnProperty(key)) {
                    totalSize += localStorage[key].length;
                }
            }
            return totalSize;
        }

        // Get available storage space (estimated)
        function getAvailableStorageSpace() {
            const totalStorage = 5 * 1024 * 1024; // 5MB typical localStorage limit
            const currentUsage = getCurrentStorageUsage();
            return totalStorage - currentUsage;
        }

        // Clear ALL cache entries (for testing)
        function clearAllCache() {
            try {
                console.log(' Clearing ALL cache entries...');

                // Remove all cache entries from localStorage
                for (let key in localStorage) {
                    if (key.startsWith(CACHE_PREFIX)) {
                        localStorage.removeItem(key);
                        console.log(` Removed: ${key}`);
                    }
                }

                // Clear cache index
                cacheIndex = [];
                offlineCache.clear();
                localStorage.removeItem(CACHE_STORAGE_KEY);

                console.log(' All cache cleared - ready for fresh downloads');

            } catch (error) {
                console.error(' Error clearing all cache:', error);
            }
        }

        // Download to local disk (like Prime) - using File System Access API
        async function downloadToLocalDisk(songId, songData) {
            try {
                console.log(` Downloading ${songData.name} to local disk (like Prime)...`);

                // Check if File System Access API is supported
                if (!('storage' in navigator) || !navigator.storage.getDirectory) {
                    console.log(' File System Access API not supported - falling back to localStorage');
                    return await downloadSongForOffline(songId, songData);
                }

                // Create cache directory structure
                const cacheDir = await createCacheDirectory();
                const songDir = await createSongDirectory(cacheDir, songId, songData.name);

                let downloadedTracks = 0;
                const totalTracks = songData.tracks.length;

                for (const track of songData.tracks) {
                    if (track.downloadUrl) {
                        try {
                            console.log(` Downloading track to disk: ${track.name}`);

                            // Download track audio using B2 proxy to avoid CORS
                            const backendUrl = getBackendUrl();
                            const proxyUrl = `${backendUrl}/download?url=${encodeURIComponent(track.downloadUrl)}`;
                            console.log(` Using proxy: ${proxyUrl}`);
                            const response = await fetch(proxyUrl);

                            if (!response.ok) {
                                throw new Error(`Proxy download failed: ${response.status} ${response.statusText}`);
                            }

                            const audioBlob = await response.blob();

                            // Save to disk
                            const trackId = track.id || `track_${downloadedTracks + 1}`;
                            const fileName = `${trackId}_${track.name.replace(/[^a-zA-Z0-9]/g, '_')}.wav`;
                            const filePath = await saveTrackToDisk(songDir, fileName, audioBlob);

                            if (filePath) {
                                console.log(` Track saved to disk: ${filePath}`);
                                downloadedTracks++;
                            }

                        } catch (error) {
                            console.error(` Error downloading track ${track.name} to disk:`, error);
                        }
                    }
                }

                if (downloadedTracks > 0) {
                    // Update cache index with disk location
                    const cacheEntry = {
                        songId: songId,
                        songName: songData.name,
                        downloadedAt: new Date().toISOString(),
                        fileSize: songData.tracks.reduce((total, track) => total + (track.fileSize || 0), 0),
                        trackCount: downloadedTracks,
                        persistent: true,
                        songData: songData,
                        storageType: 'disk', // Mark as disk storage
                        diskPath: songDir.name
                    };

                    // Update cache index
                    cacheIndex = cacheIndex.filter(entry => entry.songId !== songId);
                    cacheIndex.push(cacheEntry);
                    offlineCache.set(songId, cacheEntry);
                    localStorage.setItem(CACHE_STORAGE_KEY, JSON.stringify(cacheIndex));

                    console.log(` Song saved to disk: ${songData.name} (${downloadedTracks}/${totalTracks} tracks)`);
                    console.log(` Location: ${songDir.name}`);
                    return true;
                }

                return false;

            } catch (error) {
                console.error(' Error downloading to local disk:', error);
                return false;
            }
        }

        // Create cache directory
        async function createCacheDirectory() {
            try {
                // Try to get existing cache directory
                const cacheDirHandle = await navigator.storage.getDirectory();
                return cacheDirHandle;
            } catch (error) {
                console.log(' Cannot create cache directory:', error);
                throw error;
            }
        }

        // Create song directory
        async function createSongDirectory(cacheDir, songId, songName) {
            try {
                const dirName = `${songId}_${songName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                const songDirHandle = await cacheDir.getDirectoryHandle(dirName, { create: true });
                return songDirHandle;
            } catch (error) {
                console.log(' Cannot create song directory:', error);
                throw error;
            }
        }

        // Save track to disk
        async function saveTrackToDisk(songDir, fileName, audioBlob) {
            try {
                const fileHandle = await songDir.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(audioBlob);
                await writable.close();
                return `${songDir.name}/${fileName}`;
            } catch (error) {
                console.log(' Cannot save track to disk:', error);
                return null;
            }
        }

        // EMERGENCY: Clear ALL localStorage (nuclear option)
        function emergencyClearAllStorage() {
            try {
                console.log(' EMERGENCY: Clearing ALL localStorage...');

                // Get all keys first
                const keys = Object.keys(localStorage);
                console.log(` Found ${keys.length} items in localStorage`);

                // Remove all items
                keys.forEach(key => {
                    localStorage.removeItem(key);
                    console.log(` Removed: ${key}`);
                });

                // Reset cache variables
                cacheIndex = [];
                offlineCache.clear();
                songCache.clear();

                console.log(' EMERGENCY CLEAR COMPLETE - All localStorage cleared');
                console.log(' Please refresh the page (F5) to reinitialize');

            } catch (error) {
                console.error(' Error in emergency clear:', error);
            }
        }

        // Assign colors to tracks
        function assignTrackColors(tracks) {
            const trackColors = [
                '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
                '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
                '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#D7BDE2',
                '#A9DFBF', '#F9E79F', '#D5DBDB', '#AED6F1', '#A3E4D7'
            ];

            tracks.forEach((track, index) => {
                if (!track.color) {
                    track.color = trackColors[index % trackColors.length];
                    console.log(` Assigned color ${track.color} to track: ${track.name}`);
                }
            });
        }

        // Load audio buffers from tracks (for disk/localStorage cache)
        async function loadAudioBuffersFromTracks(tracks) {
            try {
                console.log(` Loading audio buffers for ${tracks.length} tracks...`);

                // SMART CACHE: Instead of clearing ALL buffers, only clear buffers from DIFFERENT songs
                // This allows instant loading when switching back to a previously loaded song
                const currentSongId = window.currentLoadedSongId;
                // Get song ID from the first track if possible, or use a global current song check
                const newSongId = tracks[0]?.songId || 'unknown';

                // FORCE CLEAR if switching songs to avoid track mismatch
                // "Smart cache" was causing issues where tracks with same names (e.g. "Click") from different songs were being reused.
                if (currentSongId && (currentSongId !== newSongId || newSongId === 'unknown')) {
                    console.log(` Clearing ALL buffers from previous song (${currentSongId}) to load new song (${newSongId})`);
                    audioBuffers.clear();
                    console.log(` Cache cleared completely to prevent track mixing`);
                } else if (!currentSongId) {
                    console.log(` First load - keeping cache empty initially`);
                } else {
                    console.log(` Same song (${currentSongId}) - keeping valid buffers`);
                }

                // Update current song ID
                window.currentLoadedSongId = newSongId;

                // Mark song as loading buffers
                window.songBuffersLoading = true;
                updatePlayButtonState();

                let loadedBuffers = 0;
                const totalBuffers = tracks.length;

                for (let i = 0; i < tracks.length; i++) {
                    const track = tracks[i];
                    try {
                        const trackId = track.id || `track_${i + 1}`;

                        // Check if buffer already exists
                        if (audioBuffers.has(trackId) || audioBuffers.has(track.name)) {
                            console.log(` Buffer already exists for track: ${track.name} - skipping`);
                            loadedBuffers++;
                            continue;
                        }

                        console.log(` Loading audio buffer for track: ${track.name} (${loadedBuffers + 1}/${totalBuffers})`);

                        // Create audio buffer from URL
                        let urlToFetch = track.audioUrl;
                        // Use proxy if it's a remote URL (not blob/data) to avoid CORS
                        if (urlToFetch && urlToFetch.startsWith('http')) {
                            const backendUrl = getBackendUrl();
                            urlToFetch = `${backendUrl}/download?url=${encodeURIComponent(urlToFetch)}`;
                        }
                        const response = await fetch(urlToFetch);
                        const arrayBuffer = await response.arrayBuffer();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                        // Store buffer with track ID (use consistent naming)
                        audioBuffers.set(trackId, audioBuffer);

                        // Also store with the track name for compatibility
                        audioBuffers.set(track.name, audioBuffer);

                        loadedBuffers++;
                        console.log(` Audio buffer loaded for track: ${track.name} (${audioBuffer.duration.toFixed(2)}s) - ${loadedBuffers}/${totalBuffers}`);

                    } catch (error) {
                        console.error(` Error loading audio buffer for track ${track.name}:`, error);
                    }
                }

                // Only mark as ready if ALL buffers are loaded
                if (loadedBuffers === totalBuffers) {
                    window.songBuffersLoading = false;
                    updatePlayButtonState();
                    console.log(` ALL ${loadedBuffers}/${totalBuffers} audio buffers loaded - ready for playback`);
                } else {
                    console.log(` Only ${loadedBuffers}/${totalBuffers} buffers loaded - keeping play button disabled`);
                }

            } catch (error) {
                console.error(' Error loading audio buffers from tracks:', error);
                window.songBuffersLoading = false;
                updatePlayButtonState();
            }
        }

        // Update play button state based on buffer loading status
        function updatePlayButtonState() {
            const playBtn = document.getElementById('playBtn');
            if (!playBtn) return;

            if (window.songBuffersLoading) {
                playBtn.textContent = '';
                playBtn.disabled = true;
                playBtn.title = 'Cargando buffers de audio...';
                playBtn.style.opacity = '0.6';
            } else {
                // Double-check that all tracks have buffers
                const tracksWithoutBuffers = tracks.filter(track => {
                    const trackId = track.id || `track_${tracks.indexOf(track) + 1}`;
                    return !audioBuffers.has(trackId) && !audioBuffers.has(track.name);
                });

                if (tracksWithoutBuffers.length > 0) {
                    playBtn.textContent = '';
                    playBtn.disabled = true;
                    playBtn.title = `Faltan ${tracksWithoutBuffers.length} buffers de audio...`;
                    playBtn.style.opacity = '0.6';
                } else {
                    playBtn.textContent = isPlaying ? '' : '';
                    playBtn.disabled = false;
                    playBtn.title = isPlaying ? 'Pausar' : 'Reproducir';
                    playBtn.style.opacity = '1';
                }
            }
        }

        // Show what's stored on disk
        async function showDiskStorageInfo() {
            try {
                console.log(' DISK STORAGE INFO:');
                console.log('==================');

                // Show cache index
                const savedIndex = localStorage.getItem(CACHE_STORAGE_KEY);
                if (savedIndex) {
                    const cacheIndex = JSON.parse(savedIndex);
                    console.log(` Total songs in cache index: ${cacheIndex.length}`);

                    for (const entry of cacheIndex) {
                        console.log(` ${entry.songName}:`);
                        console.log(`    Disk Path: ${entry.diskPath}`);
                        console.log(`    Storage Type: ${entry.storageType}`);
                        console.log(`    Tracks: ${entry.trackCount}`);
                        console.log(`    Size: ${((entry.fileSize || 0) / 1024 / 1024).toFixed(2)}MB`);
                        console.log(`    Downloaded: ${entry.downloadedAt}`);
                        console.log('   ---');
                    }
                } else {
                    console.log(' No cache index found');
                }

                // Try to access File System API
                if ('storage' in navigator && navigator.storage.getDirectory) {
                    try {
                        const cacheDir = await navigator.storage.getDirectory();
                        console.log(' File System Access API available');
                        console.log(' Cache directory:', cacheDir);

                        // List directories
                        const entries = [];
                        for await (const [name, handle] of cacheDir.entries()) {
                            entries.push({ name, type: handle.kind });
                        }
                        console.log(` Directories found: ${entries.length}`);
                        entries.forEach(entry => {
                            console.log(`    ${entry.name} (${entry.type})`);
                        });

                    } catch (error) {
                        console.log(' Cannot access File System:', error.message);
                    }
                } else {
                    console.log(' File System Access API not supported');
                }

            } catch (error) {
                console.error(' Error showing disk storage info:', error);
            }
        }

        // Clear oldest cache entries to make space
        function clearOldestCacheEntries() {
            try {
                console.log(' Clearing oldest cache entries to make space...');

                // Sort cache entries by download date (oldest first)
                const sortedEntries = [...cacheIndex].sort((a, b) =>
                    new Date(a.downloadedAt) - new Date(b.downloadedAt)
                );

                // Remove oldest 25% of entries
                const entriesToRemove = Math.max(1, Math.floor(sortedEntries.length * 0.25));

                for (let i = 0; i < entriesToRemove; i++) {
                    const entry = sortedEntries[i];
                    console.log(` Removing old cache entry: ${entry.songName || entry.songId || 'unknown'}`);

                    // Remove from localStorage
                    for (let j = 1; j <= entry.trackCount; j++) {
                        const storageKey = `${CACHE_PREFIX}${entry.songId}_${j}`;
                        localStorage.removeItem(storageKey);
                    }

                    // Remove from cache index
                    cacheIndex = cacheIndex.filter(e => e.songId !== entry.songId);
                    offlineCache.delete(entry.songId);
                }

                // Save updated cache index
                localStorage.setItem(CACHE_STORAGE_KEY, JSON.stringify(cacheIndex));

                console.log(` Cleared ${entriesToRemove} old cache entries`);

            } catch (error) {
                console.error(' Error clearing cache entries:', error);
            }
        }

        // Block all user interactions during song loading
        function blockAllUserInteractions() {
            console.log(' Blocking all user interactions...');

            // Add overlay to block all clicks
            let overlay = document.getElementById('loadingOverlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'loadingOverlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: rgba(0, 0, 0, 0.3);
                    z-index: 99999;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    pointer-events: all;
                    cursor: wait;
                `;
                overlay.innerHTML = `
                    <div style="background: #1a1a1a; padding: 30px; border-radius: 15px; text-align: center; border: 2px solid #007AFF;">
                        <div style="font-size: 48px; margin-bottom: 20px;"></div>
                        <div style="color: #fff; font-size: 18px; font-weight: bold; margin-bottom: 10px;">Cargando Cancin...</div>
                        <div style="color: #ccc; font-size: 14px;">Por favor espera, no interrumpas la carga</div>
                        <div style="width: 50px; height: 50px; border: 4px solid #333; border-top: 4px solid #007AFF; border-radius: 50%; animation: spin 1s linear infinite; margin: 20px auto 0;"></div>
                    </div>
                `;
                document.body.appendChild(overlay);
            }

            // Disable all clickable elements
            const clickableElements = document.querySelectorAll('button, .song-item, .setlist-item, .library-item, input, select, textarea, [onclick], [href]');
            clickableElements.forEach(element => {
                element.style.pointerEvents = 'none';
                element.style.opacity = '0.6';
                element.style.cursor = 'wait';
            });

            // Prevent all clicks globally
            document.addEventListener('click', preventAllClicks, true);
            document.addEventListener('mousedown', preventAllClicks, true);
            document.addEventListener('touchstart', preventAllClicks, true);

            console.log(' All user interactions blocked');
        }

        // Unblock all user interactions after song loading
        function unblockAllUserInteractions() {
            console.log(' Unblocking all user interactions...');

            // Remove overlay
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) {
                overlay.remove();
            }

            // Re-enable all clickable elements
            const clickableElements = document.querySelectorAll('button, .song-item, .setlist-item, .library-item, input, select, textarea, [onclick], [href]');
            clickableElements.forEach(element => {
                element.style.pointerEvents = '';
                element.style.opacity = '';
                element.style.cursor = '';
            });

            // Remove global click prevention
            document.removeEventListener('click', preventAllClicks, true);
            document.removeEventListener('mousedown', preventAllClicks, true);
            document.removeEventListener('touchstart', preventAllClicks, true);

            console.log(' All user interactions unblocked');
        }

        // Prevent all clicks during loading
        function preventAllClicks(event) {
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
            console.log(' Click blocked during song loading');
            return false;
        }

        // Load song from memory cache (instant)
        function loadFromCache(songId) {
            try {
                console.log(' Loading song from memory cache:', songId);

                const cachedSong = songCache.get(songId);
                if (!cachedSong) {
                    console.log(' No cached song found:', songId);
                    return false;
                }

                // CRITICAL: Stop all current playback first
                console.log(' Stopping all current playback before loading from cache...');
                isPlaying = false;
                stopAllTracks();
                stopAllAudioSources();
                stopTimeUpdate();

                // Update play button UI
                const playBtn = document.getElementById('playBtn');
                if (playBtn) {
                    playBtn.textContent = '';
                    playBtn.classList.remove('active');
                }

                // Clear current tracks
                tracks = [];
                audioBuffers.clear();
                audioSources.clear();
                gainNodes.clear();
                analysers.clear();

                // Load cached data
                tracks = [...cachedSong.tracks];
                audioBuffers = new Map(cachedSong.audioBuffers);
                currentLoadedSongId = songId;

                // Update UI
                updateTracksGrid();
                updateCurrentSongLedDisplay(cachedSong.songData.name);

                console.log(' Song loaded from memory cache successfully:', songId);
                return true;

            } catch (error) {
                console.error(' Error loading from cache:', error);
                return false;
            }
        }

        // Switch to already loaded song (instant)
        function switchToSong(songId) {
            try {
                console.log(' Switching to already loaded song:', songId);

                const cachedSong = songCache.get(songId);
                if (!cachedSong) {
                    console.log(' No cached song found for switching:', songId);
                    return;
                }

                // CRITICAL: Stop all current playback first
                console.log(' Stopping all current playback before switching...');
                isPlaying = false;
                stopAllTracks();
                stopAllAudioSources();
                stopTimeUpdate();

                // Update play button UI
                const playBtn = document.getElementById('playBtn');
                if (playBtn) {
                    playBtn.textContent = '';
                    playBtn.classList.remove('active');
                }

                // Load cached data
                tracks = [...cachedSong.tracks];
                audioBuffers = new Map(cachedSong.audioBuffers);
                currentLoadedSongId = songId;

                // Update UI
                updateTracksGrid();
                updateCurrentSongLedDisplay(cachedSong.songData.name);

                console.log(' Switched to song successfully:', songId);

            } catch (error) {
                console.error(' Error switching to song:', error);
            }
        }

        // Add song to loading queue
        function addToLoadingQueue(songId) {
            if (!loadingQueue.includes(songId)) {
                loadingQueue.push(songId);
                songLoadingStates.set(songId, 'pending');
                updateSongLoadingIndicator(songId, 'pending');
                console.log(' Added song to loading queue:', songId, 'Queue length:', loadingQueue.length);
            }
        }

        // Start sequential loading process
        async function startSequentialLoading() {
            if (isAutoLoading) {
                console.log(' Sequential loading already in progress, skipping');
                return;
            }

            isAutoLoading = true;
            console.log(' Starting sequential loading process...');

            while (loadingQueue.length > 0) {
                const songId = loadingQueue.shift();
                console.log(` Loading song from queue: ${songId} (${loadingQueue.length} remaining)`);

                try {
                    await loadSongDirectly(songId);

                    // Download for offline after successful load
                    const songData = songCache.get(songId);
                    if (songData) {
                        downloadSongForOffline(songId, songData.songData);
                    }

                } catch (error) {
                    console.error(` Error loading song ${songId}:`, error);
                    songLoadingStates.set(songId, 'error');
                    updateSongLoadingIndicator(songId, 'error');
                }

                // Small delay between songs to prevent overwhelming the system
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            isAutoLoading = false;
            console.log(' Sequential loading process completed');
        }

        // Load song directly (without queue)
        async function loadSongDirectly(songId) {
            console.log(' Loading song directly:', songId);

            // Check if song is already loading
            const currentState = songLoadingStates.get(songId);
            if (currentState === 'loading') {
                console.log(' Song is already loading, please wait:', songId);
                return;
            }

            // CRITICAL: Block all user interactions during loading
            console.log(' BLOCKING ALL USER INTERACTIONS during song loading...');
            blockAllUserInteractions();

            // CRITICAL: Clear everything before loading new song
            console.log(' Clearing all previous data before loading new song...');
            tracks = [];
            audioBuffers.clear();
            audioSources.clear();
            gainNodes.clear();
            analysers.clear();
            stopAllAudioSources();
            currentLoadedSongId = null;

            isLoadingSong = true;
            songLoadingStates.set(songId, 'loading');
            updateSongLoadingIndicator(songId, 'loading');

            try {
                // Get song data from Firebase (songs collection)
                const songDoc = await window.firebase.getDoc(window.firebase.doc(window.firebase.db, 'songs', songId));
                if (!songDoc.exists()) {
                    console.error(' Song not found in Firebase:', songId);
                    throw new Error(`Song not found: ${songId}`);
                }

                const songData = songDoc.data();
                console.log(' Song data loaded from songs collection:', songData);
                console.log(' Song tempo field:', songData.tempo, 'type:', typeof songData.tempo);
                console.log(' Song key field:', songData.key, 'type:', typeof songData.key);
                console.log(' Song artist field:', songData.artist, 'type:', typeof songData.artist);

                // Validate song data
                if (!songData || !songData.tracks || songData.tracks.length === 0) {
                    console.error(' Invalid song data:', songData);
                    throw new Error('Invalid song data: no tracks found');
                }

                // Load the song tracks (tracks are in audioFiles collection)
                await loadSongTracks(songData, false);

                // Update current loaded song
                currentLoadedSongId = songId;

                // Cache the song
                songCache.set(songId, {
                    songData: songData,
                    tracks: tracks,
                    audioBuffers: new Map(audioBuffers),
                    loadedAt: new Date()
                });

                isLoadingSong = false;
                songLoadingStates.set(songId, 'loaded');
                updateSongLoadingIndicator(songId, 'loaded');

                // CRITICAL: Unblock all user interactions after successful loading
                console.log(' UNBLOCKING ALL USER INTERACTIONS after successful song loading...');
                unblockAllUserInteractions();

                console.log(' Song loaded successfully:', songId);

            } catch (error) {
                console.error(' Error loading song:', error);
                isLoadingSong = false;
                songLoadingStates.set(songId, 'error');
                updateSongLoadingIndicator(songId, 'error');

                // CRITICAL: Unblock all user interactions even on error
                console.log(' UNBLOCKING ALL USER INTERACTIONS after error...');
                unblockAllUserInteractions();

                // Show user-friendly error message
                if (error.message.includes('Song not found')) {
                    alert(` Error: La cancin no se encontr en la base de datos.\n\nID: ${songId}\n\nPor favor, intenta con otra cancin.`);
                } else {
                    alert(` Error al cargar la cancin:\n\n${error.message}`);
                }

                throw error;
            }
        }

        // Pre-load all setlist songs in background (like Prime/Loop Community)
        async function preloadSetlistSongsInBackground(songs) {
            console.log(` ========================================`);
            console.log(` BACKGROUND PRE-LOADING ${songs.length} SONGS`);
            console.log(` ========================================`);

            for (let i = 0; i < songs.length; i++) {
                const song = songs[i];
                try {
                    console.log(` [${i + 1}/${songs.length}] Pre-loading: ${song.name}`);

                    // Load song data from Firestore
                    const songData = await getSongData(song.id);
                    if (!songData || !songData.tracks) {
                        console.log(` Skipping ${song.name} - no track data`);
                        continue;
                    }

                    // Pre-decode all audio buffers for this song
                    for (const track of songData.tracks) {
                        try {
                            const trackId = track.id || track.name;

                            // Skip if already in cache
                            if (audioBuffers.has(trackId)) {
                                console.log(` Already cached: ${track.name}`);
                                continue;
                            }

                            // Load and decode audio (using proxy if needed)
                            let urlToFetch = track.audioUrl || track.downloadUrl;
                            if (urlToFetch && urlToFetch.startsWith('http')) {
                                const backendUrl = getBackendUrl();
                                urlToFetch = `${backendUrl}/download?url=${encodeURIComponent(urlToFetch)}`;
                            }
                            const response = await fetch(urlToFetch);
                            const arrayBuffer = await response.arrayBuffer();
                            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                            // Store in cache
                            audioBuffers.set(trackId, audioBuffer);
                            audioBuffers.set(track.name, audioBuffer);

                            console.log(` Cached: ${track.name} (${audioBuffer.duration.toFixed(1)}s)`);

                        } catch (error) {
                            console.error(` Error pre-loading track ${track.name}:`, error);
                        }
                    }

                    console.log(` [${i + 1}/${songs.length}] Pre-loaded: ${song.name}`);

                } catch (error) {
                    console.error(` Error pre-loading song ${song.name}:`, error);
                }
            }

            console.log(` ========================================`);
            console.log(` BACKGROUND PRE-LOADING COMPLETE`);
            console.log(` All songs ready for INSTANT playback!`);
            console.log(` ========================================`);
        }

        // Auto-load first setlist and song (like Prime/Loop Community)
        async function autoLoadFirstSetlistAndSong() {
            try {
                console.log(' Auto-loading first setlist and song...');

                // Load setlists first
                await loadSetlists();

                // Get the first setlist
                const setlists = await getSetlists();
                if (setlists && setlists.length > 0) {
                    const firstSetlist = setlists[0];
                    console.log(' Auto-loading first setlist:', firstSetlist.name);

                    // Load the setlist
                    await loadSetlist(firstSetlist.id);

                    // Get songs from the setlist
                    const songs = await getSetlistSongs(firstSetlist.id);
                    if (songs && songs.length > 0) {
                        const firstSong = songs[0];
                        console.log(' Auto-loading first song:', firstSong.name);

                        // Load the first song directly (not through queue)
                        await loadSongDirectly(firstSong.id);

                        console.log(' First song loaded successfully!');

                        // PRE-LOAD ALL OTHER SONGS IN BACKGROUND (like Prime/Loop Community)
                        if (songs.length > 1) {
                            console.log(` Pre-loading ${songs.length - 1} remaining songs in background...`);
                            preloadSetlistSongsInBackground(songs.slice(1)); // Skip first song (already loaded)
                        }

                        console.log(' Auto-loading completed successfully!');
                    } else {
                        console.log(' No songs found in first setlist');
                    }
                } else {
                    console.log(' No setlists found for auto-loading');
                }
            } catch (error) {
                console.error(' Error in auto-loading:', error);
            }
        }

        // Initialize when page loads
        async function init() {
            console.log(' Initializing MultiTrack Player...');

            // Hide any existing loading modals
            hideLoading();

            // Initialize offline-first system
            if (typeof initOfflineFirst === 'function') {
                await initOfflineFirst();
            }

            // Initialize offline cache system
            initOfflineCache();

            // Initialize audio context (will show prompt for user gesture)
            initAudioContext();

            console.log(' MultiTrack Player initialized successfully');
            console.log(' Please click "Iniciar Audio" to enable audio playback');
        }

        console.log(' ADDING DOMContentLoaded listener for init()...');
        document.addEventListener('DOMContentLoaded', init);
        console.log(' DOMContentLoaded listener added successfully');
    </script>

    <!-- Cache buster: Updated at 2024-12-19 17:20:00 - Arreglado master volume y track faders -->

    <!-- OFFLINE SYNC MODAL -->
    <div id="syncModal"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 10000; justify-content: center; align-items: center; backdrop-filter: blur(5px);">
        <div
            style="background: #1a1a1a; width: 500px; max-width: 90%; border-radius: 12px; border: 1px solid #333; overflow: hidden; box-shadow: 0 20px 50px rgba(0,0,0,0.5);">
            <div style="background: linear-gradient(135deg, #007AFF, #00C6FF); padding: 20px; text-align: center;">
                <div style="font-size: 40px; margin-bottom: 10px;"></div>
                <h2 style="margin: 0; color: white; font-size: 24px;">Sincronizacin Offline</h2>
                <p style="margin: 5px 0 0; color: rgba(255,255,255,0.8);">Descarga tu contenido para usar sin internet
                </p>
            </div>

            <div style="padding: 30px;">
                <!-- Stats Grid -->
                <!-- Initial State: Show Stats and Fill with JS -->
                <div id="syncStats"
                    style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 25px; text-align: center;">
                    <div style="background: #2a2a2a; padding: 15px; border-radius: 8px;">
                        <div id="syncSetlistCount" style="font-size: 24px; font-weight: bold; color: #007AFF;">0</div>
                        <div style="font-size: 12px; color: #888; margin-top: 5px;">Setlists</div>
                    </div>
                    <div style="background: #2a2a2a; padding: 15px; border-radius: 8px;">
                        <div id="syncSongCount" style="font-size: 24px; font-weight: bold; color: #34C759;">0</div>
                        <div style="font-size: 12px; color: #888; margin-top: 5px;">Canciones</div>
                    </div>
                    <div style="background: #2a2a2a; padding: 15px; border-radius: 8px;">
                        <div id="syncAudioCount" style="font-size: 24px; font-weight: bold; color: #FF9500;">0</div>
                        <div style="font-size: 12px; color: #888; margin-top: 5px;">Audios</div>
                    </div>
                </div>

                <!-- Progress Bar -->
                <div style="margin-bottom: 25px;">
                    <div
                        style="display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 14px; color: #ccc;">
                        <span id="syncProgressMessage">Esperando iniciar...</span>
                        <span id="syncProgressPercent">0%</span>
                    </div>
                    <div style="background: #333; height: 10px; border-radius: 5px; overflow: hidden;">
                        <div id="syncProgressFill"
                            style="background: #007AFF; width: 0%; height: 100%; transition: width 0.3s ease;"></div>
                    </div>
                </div>

                <!-- Actions -->
                <div id="syncActions" style="display: flex; gap: 15px;">
                    <button onclick="skipSync()"
                        style="flex: 1; padding: 12px; background: transparent; border: 1px solid #444; color: #888; border-radius: 6px; cursor: pointer; transition: all 0.2s;">
                        Saltar por ahora
                    </button>
                    <button id="startSyncBtn" onclick="startInitialSync()"
                        style="flex: 1.5; padding: 12px; background: #007AFF; border: none; color: white; border-radius: 6px; font-weight: bold; cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 12px rgba(0,122,255,0.3);">
                         Descargar Todo
                    </button>
                </div>

                <!-- Complete State -->
                <div id="syncComplete" style="display: none; text-align: center;">
                    <div style="color: #34C759; font-size: 18px; font-weight: bold; margin-bottom: 20px;">
                         Sincronizacin Completada!
                    </div>
                    <p style="color: #999; margin-bottom: 25px; font-size: 14px;">
                        Todo tu contenido est guardado localmente.<br>
                        Ahora puedes usar la app sin conexin a internet.
                    </p>
                    <button onclick="closeSyncModal()"
                        style="width: 100%; padding: 12px; background: #333; border: 1px solid #555; color: white; border-radius: 6px; font-weight: bold; cursor: pointer; transition: all 0.2s;">
                        Comenzar a usar App
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Auth Modal (Login) -->
    <div id="authModalNew"
        style="display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95);">
        <div
            style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1a1a1a; padding: 40px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.8); min-width: 400px;">
            <h2 style="color: #fff; margin-bottom: 30px; text-align: center;"> MultiTrack Player</h2>
            <h3 style="color: #aaa; margin-bottom: 20px; text-align: center; font-weight: normal;">Iniciar Sesin</h3>

            <div id="authError"
                style="display: none; background: #ff4444; color: white; padding: 12px; border-radius: 6px; margin-bottom: 20px; text-align: center;">
            </div>

            <form id="loginForm" onsubmit="handleLogin(event); return false;">
                <div style="margin-bottom: 20px;">
                    <label style="display: block; color: #aaa; margin-bottom: 8px; font-size: 14px;">Email</label>
                    <input type="email" id="loginEmail" required
                        style="width: 100%; padding: 12px; background: #2a2a2a; border: 1px solid #444; border-radius: 6px; color: #fff; font-size: 16px;"
                        placeholder="tu@email.com">
                </div>

                <div style="margin-bottom: 30px;">
                    <label style="display: block; color: #aaa; margin-bottom: 8px; font-size: 14px;">Contrasea</label>
                    <input type="password" id="loginPassword" required
                        style="width: 100%; padding: 12px; background: #2a2a2a; border: 1px solid #444; border-radius: 6px; color: #fff; font-size: 16px;"
                        placeholder="">
                </div>

                <button type="submit" id="loginButton"
                    style="width: 100%; padding: 14px; background: linear-gradient(145deg, #007AFF, #0051D5); border: none; border-radius: 6px; color: white; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s;"
                    onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,122,255,0.4)';"
                    onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                    Iniciar Sesin
                </button>
            </form>

            <p style="color: #666; text-align: center; margin-top: 20px; font-size: 13px;">
                No tienes cuenta? Regstrate en la pgina web
            </p>
        </div>
    </div>

    <script>
        // Show login modal on app start if not logged in
        document.addEventListener('DOMContentLoaded', () => {
            const modal = document.getElementById('authModal');
            if (window.firebase && window.firebase.auth) {
                window.firebase.onAuthStateChanged(window.firebase.auth, (user) => {
                    if (!user && modal) {
                        modal.style.display = 'block';
                    } else if (user && modal) {
                        modal.style.display = 'none';
                    }
                });
            }
        });

        // Handle login
        async function handleLogin(event) {
            event.preventDefault();

            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            const button = document.getElementById('loginButton');
            const errorDiv = document.getElementById('authError');

            button.disabled = true;
            button.textContent = 'Iniciando sesin...';
            errorDiv.style.display = 'none';

            try {
                await window.firebase.signInWithEmailAndPassword(
                    window.firebase.auth,
                    email,
                    password
                );

                // Success - modal will be hidden by auth state listener
                console.log(' Login successful');

            } catch (error) {
                console.error(' Login error:', error);

                let errorMessage = 'Error al iniciar sesin';
                if (error.code === 'auth/user-not-found') {
                    errorMessage = 'Usuario no encontrado. Regstrate en la pgina web primero.';
                } else if (error.code === 'auth/wrong-password') {
                    errorMessage = 'Contrasea incorrecta';
                } else if (error.code === 'auth/invalid-email') {
                    errorMessage = 'Email invlido';
                } else if (error.code === 'auth/too-many-requests') {
                    errorMessage = 'Demasiados intentos. Espera un momento.';
                } else {
                    errorMessage = error.message;
                }

                errorDiv.textContent = errorMessage;
                errorDiv.style.display = 'block';

                button.disabled = false;
                button.textContent = 'Iniciar Sesin';
            }
        }

        // Hide auth error
        function hideAuthError() {
            const errorDiv = document.getElementById('authError');
            if (errorDiv) {
                errorDiv.style.display = 'none';
            }
        }

        // Sign out user
        function signOutUser() {
            if (window.firebase && window.firebase.auth) {
                window.firebase.signOut(window.firebase.auth).then(() => {
                    console.log(' User signed out');
                    const modal = document.getElementById('authModal');
                    if (modal) {
                        modal.style.display = 'block';
                    }
                });
            }
        }
    </script>
</body>

</html>