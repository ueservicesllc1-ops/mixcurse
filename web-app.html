<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MultiTrack Player - Professional DAW</title>
    <!-- JSZip library for ZIP file handling -->
    <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
    <!-- Tone.js library for advanced audio processing -->
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0f0f0f;
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Top Bar */
        .top-bar {
            background: #1a1a1a;
            height: 90px;
            display: flex;
            align-items: center;
            padding: 0 20px;
            border-bottom: 1px solid #333;
        }
        
        .master-volume-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-right: 20px;
            min-width: 200px;
        }
        
        .master-label {
            color: #ffffff;
            font-weight: bold;
            font-size: 12px;
            min-width: 50px;
        }
        
        .master-volume-slider {
            flex: 1;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .master-volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #007AFF;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .master-volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #007AFF;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .master-volume-value {
            color: #ffffff;
            font-size: 11px;
            min-width: 35px;
            text-align: right;
        }
        
        .transport-controls {
            display: flex;
            gap: 10px;
            margin-right: 30px;
        }
        
        .transport-btn {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            color: white;
            border: 1px solid #444;
            width: 50px;
            height: 50px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            position: relative;
            box-shadow: 
                0 4px 8px rgba(0,0,0,0.3),
                inset 0 1px 0 rgba(255,255,255,0.1);
            transition: all 0.2s ease;
        }
        
        .transport-btn::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 10px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .transport-btn:hover {
            transform: translateY(-1px);
            box-shadow: 
                0 6px 12px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.2);
        }
        
        .transport-btn.active::before {
            opacity: 1;
            background: radial-gradient(circle, rgba(0, 255, 0, 0.3) 0%, transparent 70%);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6);
        }
        
        .transport-btn.stop-btn::before {
            background: radial-gradient(circle, rgba(255, 0, 0, 0.3) 0%, transparent 70%);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.6);
        }
        
        .transport-btn.stop-btn {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
        }
        
        .transport-btn.stop-btn:hover {
            transform: translateY(-1px);
        }
        
        .time-display {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-right: 30px;
        }
        
        .center-time-display {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
            margin: 0 30px;
        }
        
        .time-info {
            font-size: 24px;
            color: #3DA9FC;
            font-weight: bold;
            background: linear-gradient(135deg, #0D0D0D 0%, #1F1F1F 100%);
            border: 3px solid #E0E0E0;
            border-radius: 12px;
            padding: 16px 24px;
            text-shadow: 0 0 12px #3DA9FC;
            position: relative;
            box-shadow: 
                0 0 15px rgba(61, 169, 252, 0.4),
                inset 0 0 15px rgba(61, 169, 252, 0.2);
            min-width: 220px;
            text-align: center;
            overflow: hidden;
            letter-spacing: 2px;
        }
        
        .time-info::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(61, 169, 252, 0.3), transparent);
            animation: ledScan 4s infinite;
        }
        
        .bpm-display {
            background: #333;
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .bpm-btn {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            color: white;
            border: 1px solid #444;
            width: 24px;
            height: 24px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 
                0 2px 4px rgba(0,0,0,0.3),
                inset 0 1px 0 rgba(255,255,255,0.1);
        }
        
        .bpm-btn:hover {
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            border-color: #555;
            transform: translateY(-1px);
            box-shadow: 
                0 4px 8px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.2);
        }
        
        .bpm-btn:active {
            transform: translateY(0);
            box-shadow: 
                0 1px 2px rgba(0,0,0,0.3),
                inset 0 1px 0 rgba(255,255,255,0.1);
        }
        
        .bpm-reset-btn {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            color: #ff6b6b;
            border: 1px solid #444;
            width: 24px;
            height: 24px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            margin-left: 4px;
            box-shadow: 
                0 2px 4px rgba(0,0,0,0.3),
                inset 0 1px 0 rgba(255,255,255,0.1);
        }
        
        .bpm-reset-btn:hover {
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            border-color: #555;
            color: #ff5252;
            transform: translateY(-1px);
            box-shadow: 
                0 4px 8px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.2);
        }
        
        .bpm-reset-btn:active {
            transform: translateY(0);
            box-shadow: 
                0 1px 2px rgba(0,0,0,0.3),
                inset 0 1px 0 rgba(255,255,255,0.1);
        }
        
        .key-display {
            background: #333;
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .key-btn {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            color: white;
            border: 1px solid #444;
            width: 24px;
            height: 24px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 
                0 2px 4px rgba(0,0,0,0.3),
                inset 0 1px 0 rgba(255,255,255,0.1);
        }
        
        .key-btn:hover {
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            border-color: #555;
            transform: translateY(-1px);
            box-shadow: 
                0 4px 8px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.2);
        }
        
        .key-btn:active {
            transform: translateY(0);
            box-shadow: 
                0 1px 2px rgba(0,0,0,0.3),
                inset 0 1px 0 rgba(255,255,255,0.1);
        }
        
        .key-reset-btn {
            background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
            color: #ff6b6b;
            border: 1px solid #444;
            width: 24px;
            height: 24px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            margin-left: 4px;
            box-shadow: 
                0 2px 4px rgba(0,0,0,0.3),
                inset 0 1px 0 rgba(255,255,255,0.1);
        }
        
        .key-reset-btn:hover {
            background: linear-gradient(145deg, #3a3a3a, #2a2a2a);
            border-color: #555;
            color: #ff5252;
            transform: translateY(-1px);
            box-shadow: 
                0 4px 8px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.2);
        }
        
        .key-reset-btn:active {
            transform: translateY(0);
            box-shadow: 
                0 1px 2px rgba(0,0,0,0.3),
                inset 0 1px 0 rgba(255,255,255,0.1);
        }
        
        
        .midi-indicators {
            display: flex;
            gap: 10px;
            margin-right: 20px;
        }
        
        .midi-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #333;
        }
        
        .midi-indicator.active {
            background: #00ff00;
        }
        
        .upload-btn {
            background: #34C759;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            margin-right: 15px;
        }
        
        .upload-btn:hover {
            background: #28A745;
        }
        
        .library-btn {
            background: #FF9500;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            margin-right: 15px;
        }
        
        .library-btn:hover {
            background: #E6850E;
        }
        
        .test-b2-btn {
            background: #FF6B35;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            margin-right: 15px;
        }
        
        .test-b2-btn:hover {
            background: #E55A2B;
        }
        
        .auth-btn {
            background: #007AFF;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            margin-right: 15px;
        }
        
        .auth-btn:hover {
            background: #0056CC;
        }
        
        .settings-btn {
            background: none;
            border: none;
            color: #ccc;
            font-size: 20px;
            cursor: pointer;
        }
        
        /* Main Content */
        .main-content {
            display: flex;
            height: calc(100vh - 60px);
        }
        
        
        /* Mixer Section */
        .mixer-section {
            flex: 7;
            background: #1a1a1a;
            border-right: 1px solid #333;
            padding: 20px;
            overflow-y: auto;
        }
        
        .led-progress-container {
            width: 100%;
            margin: 20px 0;
            padding: 0 20px;
        }
        
        .led-progress-bar {
            width: 100%;
            height: 12px;
            background: linear-gradient(135deg, #0D0D0D 0%, #1F1F1F 100%);
            border: 2px solid #E0E0E0;
            border-radius: 8px;
            position: relative;
            cursor: pointer;
            overflow: hidden;
            box-shadow: 
                0 0 15px rgba(61, 169, 252, 0.3),
                inset 0 0 15px rgba(61, 169, 252, 0.1);
        }
        
        .led-progress-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(61, 169, 252, 0.4), transparent);
            animation: ledScan 4s infinite;
        }
        
        .led-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3DA9FC, #00D4FF);
            border-radius: 6px;
            width: 0%;
            transition: width 0.1s ease;
            box-shadow: 0 0 8px rgba(61, 169, 252, 0.6);
        }
        
        .led-progress-thumb {
            position: absolute;
            top: -4px;
            width: 20px;
            height: 20px;
            background: #3DA9FC;
            border-radius: 50%;
            left: 0%;
            transition: left 0.1s ease;
            cursor: pointer;
            box-shadow: 
                0 0 12px rgba(61, 169, 252, 0.8),
                0 0 6px rgba(61, 169, 252, 0.4);
            border: 2px solid #E0E0E0;
        }
        
        .led-progress-thumb:hover {
            background: #00D4FF;
            transform: scale(1.2);
            box-shadow: 
                0 0 16px rgba(0, 212, 255, 0.9),
                0 0 8px rgba(0, 212, 255, 0.5);
        }
        
        .tracks-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 15px;
        }
        
        .track-channel {
            background: #222;
            border-radius: 8px;
            padding: 8px;
            text-align: center;
            min-width: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .track-name {
            font-size: 11px;
            font-weight: bold;
            color: #3DA9FC;
            margin-bottom: 10px;
            height: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #0D0D0D 0%, #1F1F1F 100%);
            border-radius: 6px;
            border: 2px solid #E0E0E0;
            text-shadow: 0 0 8px #3DA9FC;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 2px 6px;
            position: relative;
            box-shadow: 
                0 0 10px rgba(61, 169, 252, 0.3),
                inset 0 0 10px rgba(61, 169, 252, 0.1);
            width: 100%;
        }
        
        .track-name::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(61, 169, 252, 0.4), transparent);
            animation: ledScan 4s infinite;
        }
        
        @keyframes ledScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        .track-name-text {
            font-family: 'Courier New', 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 12px;
            font-weight: normal;
            color: #00FF41;
            margin-bottom: 0px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 100%;
            line-height: 1.1;
            letter-spacing: 0.8px;
            text-transform: uppercase;
        }
        
        .track-volume-indicator {
            font-size: 9px;
            color: #a0aec0;
            font-weight: normal;
        }
        
        .track-status {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 8px;
            margin-bottom: 5px;
        }
        
        .track-led {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            border: 1px solid #333;
            transition: all 0.3s ease;
        }
        
        .track-led.led-on {
            background-color: #007AFF;
            box-shadow: 0 0 6px #007AFF;
            border-color: #007AFF;
        }
        
        .track-led.led-off {
            background-color: #333;
            box-shadow: none;
            border-color: #555;
        }
        
        .track-name.muted {
            background: linear-gradient(135deg, #0D0D0D 0%, #1F1F1F 100%);
            border-color: #ff6b6b;
            box-shadow: 
                0 0 10px rgba(255, 107, 107, 0.3),
                inset 0 0 10px rgba(255, 107, 107, 0.1);
        }
        
        .track-name.muted::before {
            background: linear-gradient(90deg, transparent, rgba(255, 107, 107, 0.4), transparent);
        }
        
        .track-name.solo {
            background: linear-gradient(135deg, #0D0D0D 0%, #1F1F1F 100%);
            border-color: #ffd700;
            box-shadow: 
                0 0 10px rgba(255, 215, 0, 0.3),
                inset 0 0 10px rgba(255, 215, 0, 0.1);
        }
        
        .track-name.solo::before {
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.4), transparent);
        }
        
        .track-name.muted .track-name-text {
            color: #FF0040;
        }
        
        .track-name.solo .track-name-text {
            color: #FFD700;
        }
        
        .track-name.click-cue {
            background: linear-gradient(135deg, #0D0D0D 0%, #1F1F1F 100%);
            border-color: #ff6b6b;
            font-weight: bold;
            box-shadow: 
                0 0 10px rgba(255, 107, 107, 0.3),
                inset 0 0 10px rgba(255, 107, 107, 0.1);
        }
        
        .track-name.click-cue::before {
            background: linear-gradient(90deg, transparent, rgba(255, 107, 107, 0.4), transparent);
        }
        
        .track-name.click-cue .track-name-text {
            color: #FF0040;
        }
        
        .track-channel.click-cue {
            border-left: 4px solid #dc3545;
        }
        
        .vu-meter-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 8px 0;
            height: 60px;
        }
        
        .vu-meter {
            width: 8px;
            height: 50px;
            background: linear-gradient(to top, #1a1a1a 0%, #2a2a2a 50%, #1a1a1a 100%);
            border: 1px solid #333;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.5);
        }
        
        .vu-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, 
                #00ff00 0%, 
                #80ff00 30%, 
                #ffff00 60%, 
                #ff8000 80%, 
                #ff0000 100%);
            transition: height 0.1s ease;
            border-radius: 3px;
            box-shadow: 0 0 3px rgba(255,255,255,0.3);
        }
        
        .vu-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(to top, 
                rgba(0,255,0,0.8) 0%, 
                rgba(128,255,0,0.8) 30%, 
                rgba(255,255,0,0.8) 60%, 
                rgba(255,128,0,0.8) 80%, 
                rgba(255,0,0,0.8) 100%);
            border-radius: 3px;
        }
        
        .track-channel.click-cue .fader-level {
            background: linear-gradient(180deg, #dc3545, #c82333);
        }
        
        .track-channel.click-cue .fader-thumb {
            background: #dc3545;
        }
        
        .fader-container {
            height: 160px;
            position: relative;
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #0a0a0a;
            border-radius: 4px;
            padding: 8px;
            border: 1px solid #333;
        }
        
        .fader-track {
            width: 20px;
            height: 100%;
            background: #1a1a1a;
            border-radius: 2px;
            position: relative;
            margin: 0 auto;
            border: 1px solid #444;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.8);
        }
        
        .fader-thumb {
            width: 24px;
            height: 16px;
            background: linear-gradient(145deg, #e0e0e0, #c0c0c0);
            border-radius: 2px;
            position: absolute;
            left: -2px;
            cursor: pointer;
            transition: all 0.1s ease;
            box-shadow: 
                0 2px 4px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.3);
            border: 1px solid #999;
        }
        
        .fader-thumb:hover {
            background: linear-gradient(145deg, #f0f0f0, #d0d0d0);
            box-shadow: 
                0 3px 6px rgba(0,0,0,0.5),
                inset 0 1px 0 rgba(255,255,255,0.4);
        }
        
        .fader-level {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #ff0000 0%, #ff8800 20%, #ffff00 40%, #88ff00 60%, #00ff00 80%, #00ff88 100%);
            border-radius: 0 0 2px 2px;
            transition: height 0.1s ease;
            opacity: 0.9;
        }
        
        .fader-scale {
            position: absolute;
            left: -30px;
            top: 0;
            height: 100%;
            width: 25px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-size: 7px;
            color: #fff;
            text-align: right;
            font-weight: bold;
        }
        
        .fader-scale span {
            line-height: 1;
            opacity: 0.8;
            text-shadow: 0 0 2px rgba(255,255,255,0.3);
        }
        
        .track-controls {
            display: flex;
            gap: 5px;
            justify-content: center;
            flex-direction: row;
            align-items: center;
        }
        
        .track-control-btn {
            width: 25px;
            height: 25px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
        }
        
        .track-play-btn {
            width: 30px;
            height: 30px;
            background: #28a745;
            color: #fff;
            font-size: 12px;
            margin-bottom: 3px;
        }
        
        .track-play-btn:hover {
            background: #218838;
        }
        
        .track-play-btn.playing {
            background: #dc3545;
        }
        
        .track-play-btn.playing:hover {
            background: #c82333;
        }
        
        .mute-btn {
            background: #333;
            color: white;
        }
        
        .mute-btn.active {
            background: #ff0000;
        }
        
        .solo-btn {
            background: #333;
            color: white;
        }
        
        .solo-btn.active {
            background: #ffff00;
            color: #000;
        }
        
        /* Right Panel */
        .right-panel {
            flex: 3;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
        }

        /* Panel Tabs */
        .panel-tabs {
            display: flex;
            background: #222;
            border-bottom: 1px solid #333;
        }

        .tab-btn {
            flex: 1;
            padding: 12px 16px;
            background: transparent;
            color: #888;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .tab-btn:hover {
            background: #333;
            color: #fff;
        }

        .tab-btn.active {
            background: #007AFF;
            color: #fff;
        }

        .tab-content {
            display: none;
            padding: 20px;
            height: calc(100vh - 200px);
            overflow-y: auto;
        }

        .tab-content.active {
            display: block;
        }

        /* Library and Setlist Styles */
        .library-items, .setlist-list {
            padding: 10px 0;
        }

        .library-song-item, .setlist-item {
            background: #2a2a2a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .library-song-item:hover, .setlist-item:hover {
            background: #333;
            border-color: #007AFF;
        }

        .song-info, .setlist-info {
            flex: 1;
        }

        .song-info h4, .setlist-info h4 {
            margin: 0 0 4px 0;
            color: #fff;
            font-size: 14px;
        }

        .song-info p, .setlist-info p {
            margin: 0;
            color: #888;
            font-size: 12px;
        }

        .song-actions, .setlist-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            background: #444;
            border: none;
            border-radius: 4px;
            padding: 6px 8px;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
        }

        .action-btn:hover {
            background: #555;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #888;
        }

        .empty-state p {
            margin: 8px 0;
        }

        .create-setlist-btn {
            background: #007AFF;
            border: none;
            border-radius: 6px;
            padding: 10px 16px;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            margin-top: 12px;
            transition: background 0.3s ease;
        }

        .create-setlist-btn:hover {
            background: #0056CC;
        }

        /* Library and Setlist Items */

        .library-song-item:hover, .setlist-item:hover {
            background: #333;
            border-color: #007AFF;
        }

        .song-info, .setlist-info {
            flex: 1;
        }

        .song-info h4, .setlist-info h4 {
            color: #fff;
            margin: 0 0 4px 0;
            font-size: 16px;
        }
        
        .song-info p, .setlist-info p {
            color: #888;
            margin: 2px 0;
            font-size: 14px;
        }

        .song-date, .setlist-date {
            color: #666 !important;
            font-size: 12px !important;
        }

        .song-actions, .setlist-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            background: #444;
            border: none;
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s ease;
        }

        .action-btn:hover {
            background: #007AFF;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #888;
        }

        .empty-state p {
            margin: 8px 0;
        }

        .create-setlist-btn {
            background: #007AFF;
            color: #fff;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 16px;
        }

        .create-setlist-btn:hover {
            background: #0056b3;
        }
        
        .setlist-section {
            flex: 1;
            padding: 20px;
            border-bottom: 1px solid #333;
            width: 100%;
        }
        
        .canciones-section {
            flex: 1;
            padding: 20px;
            border-bottom: 1px solid #333;
            width: 100%;
        }
        
        .canciones-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .canciones-title {
            font-size: 18px;
            font-weight: bold;
            color: #007AFF;
        }
        
        .canciones-container {
            width: 100%;
            height: 100%;
            background-color: #000000;
            margin: 0;
            padding: 20px;
            border-radius: 0;
        }
        
        .setlist-button-container {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .canciones-list {
            margin-top: 60px;
        }
        
        .setlist-led-display {
            background: #000;
            border: 2px solid #333;
            border-radius: 4px;
            padding: 8px 16px;
            min-width: 180px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .led-text {
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .canciones-container {
            position: relative;
        }
        
        .setlist-main-btn {
            background: #555;
            color: white;
            border: none;
            padding: 8px 16px;
            font-size: 12px;
            font-weight: 500;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .setlist-main-btn:hover {
            background: #666;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .setlist-sidebar {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: #1a1a1a;
            border-left: 1px solid #333;
            transition: right 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
        }
        
        .setlist-sidebar.open {
            right: 0;
        }
        
        .setlist-sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #333;
            background: #2a2a2a;
        }
        
        .setlist-sidebar-header h3 {
            color: #007AFF;
            margin: 0;
            font-size: 20px;
        }
        
        .close-setlist-btn {
            background: none;
            border: none;
            color: #ccc;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
        }
        
        .close-setlist-btn:hover {
            color: #fff;
        }
        
        .setlist-sidebar-content {
            padding: 20px;
        }
        
        .setlist-sidebar-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .setlist-sidebar-item {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid #444;
        }
        
        .setlist-sidebar-item:hover {
            background: #444;
            border-color: #007AFF;
        }
        
        .setlist-sidebar-item h4 {
            color: #fff;
            margin: 0 0 5px 0;
            font-size: 16px;
        }
        
        .setlist-sidebar-item p {
            color: #ccc;
            margin: 0;
            font-size: 12px;
        }
        
        .canciones-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .setlist-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .setlist-title {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
        }
        
        .setlist-btn {
            background: #007AFF;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }
        
        .sync-btn {
            background: #333;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }
        
        .song-list {
            max-height: 400px;
            overflow-y: auto;
            width: 100%;
        }
        
        .song-item {
            display: flex;
            align-items: center;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 8px;
            background: #222;
            cursor: pointer;
            width: 100%;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }
        
        .song-item:hover {
            background: #333;
            border-color: #007AFF;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.2);
        }
        
        .song-item:active {
            transform: translateY(0);
            box-shadow: 0 1px 4px rgba(0, 122, 255, 0.3);
        }
        
        .song-number-container {
            display: flex;
            align-items: center;
            margin-right: 10px;
            position: relative;
        }

        .song-number {
            width: 20px;
            text-align: center;
            font-weight: bold;
        }

        .song-loading-indicator {
            position: absolute;
            top: -3px;
            left: 0;
            right: 0;
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
            z-index: 10;
        }

        .mini-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00D4FF, #007AFF);
            width: 0%;
            border-radius: 2px;
            transition: width 0.3s ease;
            animation: mini-progress-pulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 8px rgba(0, 212, 255, 0.6);
        }

        @keyframes mini-progress-pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }
        
        
        .song-info {
            flex: 1;
        }
        
        .song-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 4px;
        }
        
        .song-artist {
            font-size: 11px;
            color: #999;
            font-weight: normal;
            margin-top: 2px;
        }
        
        .song-details {
            display: flex;
            gap: 8px;
            margin-top: 4px;
            font-size: 10px;
            color: #666;
        }
        
        .song-meta {
            display: flex;
            gap: 6px;
            align-items: center;
            font-size: 11px;
            color: #888;
            margin-right: 10px;
        }
        
        .song-tempo, .song-key, .song-time-sig {
            background: #333;
            padding: 1px 4px;
            border-radius: 2px;
            color: #ccc;
            font-size: 10px;
            white-space: nowrap;
        }
        
        .song-tempo {
            color: #4CAF50;
        }
        
        .song-key {
            color: #FF9800;
        }
        
        .song-time-sig {
            color: #2196F3;
        }
        
        .song-menu {
            position: relative;
            display: inline-block;
        }
        
        .menu-btn {
            background: #333;
            border: none;
            color: #ccc;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s ease;
        }
        
        .menu-btn:hover {
            background: #444;
            color: #fff;
        }
        
        .menu-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            min-width: 120px;
        }
        
        .menu-item {
            display: block;
            width: 100%;
            padding: 10px 15px;
            background: none;
            border: none;
            color: #ccc;
            text-align: left;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s ease;
        }
        
        .menu-item:hover {
            background: #333;
            color: #fff;
        }
        
        .song-key {
            background: #2a2a2a;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            color: #007AFF;
            border: 1px solid #444;
            text-align: center;
            min-width: 50px;
        }
        
        .song-bpm {
            background: #2a2a2a;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            color: #4CAF50;
            border: 1px solid #444;
            text-align: center;
            min-width: 50px;
        }
        
        .song-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .play-btn, .delete-btn {
            background: #333;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 6px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
            min-width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .play-btn {
            color: #4CAF50;
        }
        
        .play-btn:hover {
            background: #4CAF50;
            color: #fff;
            border-color: #4CAF50;
        }
        
        .delete-btn {
            color: #f44336;
        }
        
        .delete-btn:hover {
            background: #f44336;
            color: #fff;
            border-color: #f44336;
        }
        
        /* Library Section */
        .library-section {
            flex: 1;
            padding: 20px;
        }
        
        .library-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .library-title {
            font-size: 16px;
            font-weight: bold;
            color: #fff;
        }
        
        .edit-btn {
            background: #333;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }
        
        .library-item {
            background: #222;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 10px;
        }
        
        .library-item-title {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .library-item-url {
            font-size: 10px;
            color: #888;
            margin-bottom: 10px;
        }
        
        .library-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .waveform-icon {
            width: 20px;
            height: 20px;
            background: #444;
            border-radius: 2px;
        }
        
        .power-btn {
            background: #333;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
        }
        
        .power-btn.active {
            background: #00ff00;
            color: #000;
        }
        
        .pads-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            margin-top: 15px;
        }
        
        .pad-btn {
            background: #333;
            color: white;
            border: none;
            padding: 15px 5px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .pad-btn:hover {
            background: #444;
        }
        
        .pad-btn.active {
            background: #007AFF;
        }
        
        .library-fader {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .library-fader-container {
            flex: 1;
            height: 80px;
            position: relative;
        }
        
        .library-fader-track {
            width: 15px;
            height: 100%;
            background: #333;
            border-radius: 8px;
            position: relative;
            margin: 0 auto;
        }
        
        .library-fader-thumb {
            width: 20px;
            height: 6px;
            background: #007AFF;
            border-radius: 3px;
            position: absolute;
            left: -2.5px;
            cursor: pointer;
        }
        
        .library-fader-level {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #ff0000 0%, #ffff00 50%, #00ff00 100%);
            border-radius: 0 0 8px 8px;
        }
        
        .library-controls-bottom {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .library-mute-btn, .library-solo-btn {
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 8px;
            font-weight: bold;
            background: #333;
            color: white;
        }
        
        .library-mute-btn.active {
            background: #ff0000;
        }
        
        .library-solo-btn.active {
            background: #ffff00;
            color: #000;
        }
        
        /* Audio Files Section */
        .audio-files-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #222;
            border-radius: 8px;
        }
        
        .audio-files-header {
            margin-bottom: 15px;
        }
        
        .audio-files-list {
            max-height: 200px;
            overflow-y: auto;
        }
        
        .audio-file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #333;
            border-radius: 6px;
            margin-bottom: 8px;
        }
        
        .file-info {
            flex: 1;
        }
        
        .file-name {
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .file-size {
            color: #888;
            font-size: 10px;
        }
        
        .file-actions {
            display: flex;
            gap: 5px;
        }
        
        .play-btn, .delete-btn {
            background: #333;
            color: white;
            border: none;
            padding: 5px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .play-btn:hover {
            background: #007AFF;
        }
        
        .delete-btn:hover {
            background: #FF3B30;
        }
        
        /* Google Sign In Button */
        .google-signin-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
            padding: 12px 16px;
            background: #fff;
            color: #333;
            border: 1px solid #dadce0;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            margin-bottom: 20px;
            transition: all 0.2s ease;
        }
        
        .google-signin-btn:hover {
            background: #f8f9fa;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .google-logo {
            width: 18px;
            height: 18px;
        }
        
        /* Divider */
        .divider {
            display: flex;
            align-items: center;
            margin: 20px 0;
            color: #888;
            font-size: 14px;
        }
        
        .divider::before,
        .divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: #333;
        }
        
        .divider span {
            padding: 0 15px;
            background: #1a1a1a;
        }
        
        /* Library Sidebar */
        .library-sidebar {
            position: fixed;
            top: 0;
            right: -60vw;
            width: 60vw;
            height: 100vh;
            background: #1a1a1a;
            border-left: 1px solid #333;
            z-index: 1000;
            transition: right 0.3s ease;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .library-sidebar.open {
            right: 0;
        }
        
        .library-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #333;
            background: #222;
        }
        
        .library-header h2 {
            color: #fff;
            font-size: 18px;
            margin: 0;
        }
        
        .close-library-btn {
            background: none;
            border: none;
            color: #ccc;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
        }
        
        .close-library-btn:hover {
            color: #fff;
        }
        
        .library-content {
            padding: 20px;
        }
        
        .library-search {
            margin-bottom: 20px;
        }
        
        .search-input {
            width: 100%;
            padding: 12px;
            border: 1px solid #333;
            border-radius: 6px;
            background: #222;
            color: #fff;
            font-size: 14px;
        }
        
        .search-input:focus {
            outline: none;
            border-color: #007AFF;
        }
        
        .library-categories {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
        }
        
        .category-btn {
            padding: 8px 12px;
            background: #333;
            color: #ccc;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .category-btn:hover {
            background: #444;
            color: #fff;
        }
        
        .category-btn.active {
            background: #007AFF;
            color: #fff;
        }
        
        .library-items {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        /* Library Setlist Container */
        .library-setlist-container {
            display: flex;
            flex: 1;
            height: calc(75vw - 200px);
            max-height: calc(100vh - 200px);
        }
        
        .library-column, .setlist-column {
            flex: 1;
            padding: 10px;
            border-right: 1px solid #333;
        }
        
        .setlist-column {
            border-right: none;
        }
        
        .library-column h4, .setlist-column h4 {
            color: #fff;
            margin: 0 0 15px 0;
            padding: 10px;
            background: #333;
            border-radius: 5px;
            text-align: center;
        }
        
        .library-items, .setlist-items {
            height: calc(100% - 50px);
            overflow-y: auto;
            padding: 0;
        }
        
        .setlist-items {
            border: 2px dashed #555;
            border-radius: 5px;
            min-height: 200px;
            padding: 10px;
        }
        
        .setlist-items.drag-over {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }
        
        .setlist-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }
        
        .setlist-item:hover {
            background: #333;
        }
        
        .setlist-item-info {
            flex: 1;
            display: flex;
            align-items: center;
        }
        
        .setlist-item-order {
            background: #007AFF;
            color: #fff;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .setlist-item-name {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .setlist-item-details {
            color: #888;
            font-size: 12px;
        }
        
        .setlist-loading-indicator {
            width: 16px;
            height: 16px;
            border: 2px solid #333;
            border-top: 2px solid #007AFF;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 8px;
            display: none;
        }
        
        .setlist-loading-indicator.loading {
            display: block;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .remove-btn {
            background: #ff4444;
            color: #fff;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s ease;
        }
        
        .remove-btn:hover {
            background: #ff6666;
        }
        
        /* Setlist Buttons */
        .setlist-buttons-container {
            margin-bottom: 15px;
        }
        
        .setlist-buttons {
            display: flex;
            flex-direction: column;
            gap: 5px;
            max-height: 120px;
            overflow-y: auto;
        }
        
        .setlist-btn {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 5px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
            text-align: left;
            transition: all 0.2s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .setlist-btn:hover {
            background: #444;
            border-color: #666;
        }
        
        .setlist-btn.active {
            background: #007AFF;
            border-color: #007AFF;
        }
        
        .current-setlist-header {
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #444;
        }
        
        .current-setlist-header h5 {
            color: #fff;
            margin: 0;
            font-size: 14px;
            font-weight: bold;
        }
        
        .library-item {
            display: flex;
            align-items: center;
            padding: 12px;
            background: #222;
            border-radius: 6px;
            cursor: grab;
            transition: all 0.2s ease;
            user-select: none;
        }
        
        .library-item:hover {
            background: #333;
        }
        
        .library-item:active {
            cursor: grabbing;
        }
        
        .library-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }
        
        .library-item-icon {
            width: 40px;
            height: 40px;
            background: #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-size: 18px;
        }
        
        .library-item-info {
            flex: 1;
        }
        
        .library-item-name {
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .library-item-details {
            color: #888;
            font-size: 12px;
        }
        
        .library-item-actions {
            display: flex;
            gap: 5px;
        }
        
        .library-action-btn, .delete-library-btn {
            background: #333;
            color: #ccc;
            border: none;
            padding: 6px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .delete-library-btn {
            color: #f44336;
        }
        
        .delete-library-btn:hover {
            background: #f44336;
            color: #fff;
        }
        
        .library-action-btn:hover {
            background: #444;
            color: #fff;
        }
        
        /* Progress Bar Styles */
        .progress-container {
            width: 100%;
            margin: 15px 0 20px 0;
            padding: 0 20px;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            position: relative;
            cursor: pointer;
            overflow: hidden;
            transition: background-color 0.2s ease;
        }
        
        .progress-bar.playing {
            background: #444;
            cursor: not-allowed;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007AFF, #00D4FF);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s ease;
        }
        
        .progress-thumb {
            position: absolute;
            top: -3px;
            width: 12px;
            height: 12px;
            background: #007AFF;
            border-radius: 50%;
            left: 0%;
            transition: left 0.1s ease;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .progress-thumb:hover {
            background: #00D4FF;
            transform: scale(1.2);
        }
    </style>
</head>
<body>
    <!-- Top Bar -->
    <div class="top-bar">
        <div class="master-volume-container">
            <label class="master-label">MASTER</label>
            <input type="range" class="master-volume-slider" id="masterVolumeSlider" min="0" max="100" value="80" oninput="updateMasterVolume(this.value)">
            <span class="master-volume-value" id="masterVolumeValue">80%</span>
        </div>
        
        <div class="transport-controls">
            <button class="transport-btn" onclick="rewind()"></button>
            <button class="transport-btn" id="playBtn" onclick="togglePlay()"></button>
            <button class="transport-btn stop-btn" id="stopBtn" onclick="stopPlayback()"></button>
            <button class="transport-btn" onclick="fastForward()"></button>
        </div>
        
        <div class="time-display">
            <div class="bpm-display">
                <button class="bpm-btn" onclick="decreaseBPM()">-</button>
                <span id="bpmDisplay">128 BPM</span>
                <button class="bpm-btn" onclick="increaseBPM()">+</button>
                <button class="bpm-reset-btn" onclick="resetBPM()" title="Reset to Original"></button>
            </div>
            <div class="key-display">
                <button class="key-btn" onclick="decreaseKey()">-</button>
                <span id="keyDisplay">C</span>
                <button class="key-btn" onclick="increaseKey()">+</button>
                <button class="key-reset-btn" onclick="resetKey()" title="Reset to Original"></button>
            </div>
        </div>
        
        <div class="center-time-display">
            <div class="time-info">
                <span id="currentTime">00:00</span> / <span id="totalTime">00:00</span>
            </div>
        </div>
        
        <div class="midi-indicators">
            <div class="midi-indicator" id="midiIn"></div>
            <div class="midi-indicator" id="midiOut"></div>
        </div>
        
        <input type="file" id="audioFileInput" accept="audio/*,.zip" style="display: none;" onchange="handleFileUpload(event)">
        <button class="upload-btn" onclick="showTrackNamesModal()"> Subir ZIP/Audio</button>
        <button class="test-b2-btn" onclick="testB2Connection()" style="display: none;"> Test B2</button>
        <button class="test-b2-btn" onclick="debugTimeSync()" style="display: none;"> Debug Time</button>
        <button class="test-b2-btn" onclick="debugPlaybackState()" style="display: none;"> Debug Play</button>
        <button class="test-b2-btn" onclick="testSeek()" style="display: none;"> Test Seek</button>
        <button class="test-b2-btn" onclick="testClickCueDetection()" style="display: none;"> Test Click/Cue</button>
        <button class="library-btn" onclick="toggleLibrary()"> Biblioteca</button>
        <button class="test-b2-btn" onclick="loadLibrarySongsForSidebar()" style="display: none;"> Test Library</button>
        <button class="auth-btn" id="authButton" onclick="showAuthModal()"> Login</button>
        <button class="settings-btn" onclick="hotReload()" title="Hot Reload (F5)"></button>
        <button class="settings-btn" onclick="openSettings()"></button>
        <button class="settings-btn" onclick="testVolumeLevels()" title="Test Volume" style="display: none;"></button>
        <button class="settings-btn" onclick="debugAudioBuffers()" title="Debug Buffers" style="display: none;"></button>
        <button class="settings-btn" onclick="testB2Urls()" title="Test B2 URLs" style="display: none;"></button>
        <button class="settings-btn" onclick="reloadAudioBuffers()" title="Reload Audio Buffers" style="display: none;"></button>
        <button class="settings-btn" onclick="checkFileSizes()" title="Check File Sizes" style="display: none;"></button>
        <button class="settings-btn" onclick="testSingleAudioFile()" title="Test Single Audio File" style="display: none;"></button>
                <button class="settings-btn" onclick="testAudio()" title="Test Audio" style="display: none;"></button>
                <button class="settings-btn" onclick="testAuthState()" title="Test Auth" style="display: none;"></button>
                <button class="settings-btn" onclick="testSpecificB2Url()" title="Test CORS" style="display: none;"></button>
    </div>
    
    <!-- Library Sidebar -->
    <div id="librarySidebar" class="library-sidebar">
        <div class="library-header">
            <h2> Biblioteca & Setlist</h2>
            <button class="close-library-btn" onclick="toggleLibrary()"></button>
        </div>
        
        <div class="library-content">
            <div class="library-search">
                <input type="text" id="librarySearch" placeholder="Buscar en biblioteca..." class="search-input">
            </div>
            
            <div class="library-categories">
                <button class="category-btn active" data-category="all">Todos</button>
                <button class="category-btn" data-category="loops">Loops</button>
                <button class="category-btn" data-category="samples">Samples</button>
                <button class="category-btn" data-category="instruments">Instrumentos</button>
                <button class="category-btn" data-category="vocals">Vocales</button>
            </div>
            
            <div class="library-setlist-container">
                <div class="library-column">
                    <h4> Biblioteca</h4>
                    <div id="sidebarLibraryItems" class="library-items">
                        <!-- Library items will be loaded here -->
                    </div>
                </div>
                
                <div class="setlist-column">
                    <h4> Setlists</h4>
                    <div class="setlist-buttons-container">
                        <div id="sidebarSetlistButtons" class="setlist-buttons">
                            <!-- Setlist buttons will be loaded here -->
                        </div>
                    </div>
                    <div class="current-setlist-header">
                        <h5 id="currentSetlistTitle">Setlist Actual</h5>
                    </div>
                    <div id="sidebarSetlistItems" class="setlist-items">
                        <!-- Current setlist items will be loaded here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Mixer Section -->
        <div class="mixer-section">
            <div class="led-progress-container">
                <div class="led-progress-bar" id="progressBar" onclick="handleProgressBarClick(event)">
                    <div class="led-progress-fill" id="progressFill"></div>
                    <div class="led-progress-thumb" id="progressThumb"></div>
                </div>
            </div>
            <div class="tracks-grid" id="tracksGrid">
                <!-- Tracks will be generated here -->
            </div>
        </div>
        
        <!-- Right Panel -->
        <div class="right-panel">
            <!-- Panel Tabs -->
            <div class="panel-tabs">
                <button class="tab-btn active" onclick="switchTab('library')" style="display: none;"> Biblioteca</button>
                <button class="tab-btn active" onclick="switchTab('setlist')" style="display: none;"> Setlist</button>
            </div>
            
            <!-- Library Tab Content -->
            <div id="libraryTab" class="tab-content" style="display: none;">
                <div class="library-section">
                    <div class="library-header">
                        <div class="library-title"> Mi Biblioteca</div>
                        <button class="edit-btn" onclick="loadLibrarySongs()" title="Recargar biblioteca"></button>
                        <button class="edit-btn" onclick="testLibraryLoad()" title="Test biblioteca" style="margin-left: 5px;"></button>
                        <button class="edit-btn" onclick="showDeleteMultipleModal()" title="Eliminar mltiples canciones" style="margin-left: 5px; background: #ff4444;"></button>
                    </div>
                    
                    <div id="libraryItems" class="library-items">
                        <!-- Library items will be loaded here -->
                    </div>
                </div>
            </div>
            
            <!-- Setlist Tab Content -->
            <div id="setlistTab" class="tab-content active">
                <div class="canciones-container">
                    <div class="setlist-button-container">
                        <div class="setlist-led-display" id="setlistLedDisplay">
                            <div class="led-text">Sin Setlist</div>
                        </div>
                        <button class="setlist-main-btn" onclick="toggleSetlistSidebar()">Setlist</button>
                    </div>
                    <div class="canciones-list" id="cancionesList">
                        <!-- Canciones will be generated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Setlist Sidebar -->
    <div id="setlistSidebar" class="setlist-sidebar">
        <div class="setlist-sidebar-header">
            <h3> Mis Setlists</h3>
            <button class="close-setlist-btn" onclick="toggleSetlistSidebar()"></button>
        </div>
        
        <div class="setlist-sidebar-content">
            <div class="setlist-sidebar-list" id="setlistSidebarList">
                <!-- Setlists will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Track Names Modal -->
    <div id="trackNamesModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.8); align-items: center; justify-content: center; z-index: 1001;">
        <div style="background-color: #1a1a1a; border-radius: 10px; padding: 30px; width: 700px; max-width: 90vw; max-height: 90vh; border: 1px solid #333; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="color: #fff; font-size: 24px; font-weight: bold; margin: 0;"> Subir Cancin</h2>
                <button onclick="hideTrackNamesModal()" style="background: none; border: none; color: #ccc; font-size: 24px; cursor: pointer; padding: 5px;"></button>
            </div>
            
            <!-- Song Metadata Form -->
            <div style="margin-bottom: 25px; padding: 20px; background: #222; border-radius: 8px; border: 1px solid #333;">
                <h3 style="color: #fff; font-size: 18px; margin: 0 0 15px 0;"> Informacin de la Cancin</h3>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div>
                        <label style="color: #ccc; font-size: 14px; font-weight: bold; margin-bottom: 8px; display: block;"> Nombre de la Cancin *</label>
                        <input type="text" id="songName" placeholder="Ej: Mi Cancin" style="width: 100%; padding: 12px; border-radius: 6px; border: 1px solid #333; background-color: #333; color: #fff; font-size: 14px;">
                    </div>
                    <div>
                        <label style="color: #ccc; font-size: 14px; font-weight: bold; margin-bottom: 8px; display: block;"> Artista</label>
                        <input type="text" id="songArtist" placeholder="Ej: Mi Banda" style="width: 100%; padding: 12px; border-radius: 6px; border: 1px solid #333; background-color: #333; color: #fff; font-size: 14px;">
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px;">
                    <div>
                        <label style="color: #ccc; font-size: 14px; font-weight: bold; margin-bottom: 8px; display: block;"> Tempo (BPM)</label>
                        <input type="number" id="songTempo" placeholder="120" min="60" max="200" style="width: 100%; padding: 12px; border-radius: 6px; border: 1px solid #333; background-color: #333; color: #fff; font-size: 14px;">
                    </div>
                    <div>
                        <label style="color: #ccc; font-size: 14px; font-weight: bold; margin-bottom: 8px; display: block;"> Nota</label>
                        <select id="songKey" style="width: 100%; padding: 12px; border-radius: 6px; border: 1px solid #333; background-color: #333; color: #fff; font-size: 14px;">
                            <option value="">Seleccionar...</option>
                            <option value="C">C</option>
                            <option value="C#">C#</option>
                            <option value="D">D</option>
                            <option value="D#">D#</option>
                            <option value="E">E</option>
                            <option value="F">F</option>
                            <option value="F#">F#</option>
                            <option value="G">G</option>
                            <option value="G#">G#</option>
                            <option value="A">A</option>
                            <option value="A#">A#</option>
                            <option value="B">B</option>
                        </select>
                    </div>
                    <div>
                        <label style="color: #ccc; font-size: 14px; font-weight: bold; margin-bottom: 8px; display: block;"> Comps</label>
                        <select id="songTimeSignature" style="width: 100%; padding: 12px; border-radius: 6px; border: 1px solid #333; background-color: #333; color: #fff; font-size: 14px;">
                            <option value="">Seleccionar...</option>
                            <option value="4/4">4/4</option>
                            <option value="3/4">3/4</option>
                            <option value="2/4">2/4</option>
                            <option value="6/8">6/8</option>
                            <option value="12/8">12/8</option>
                            <option value="7/8">7/8</option>
                            <option value="5/4">5/4</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <!-- File Upload Section -->
            <div style="margin-bottom: 25px; padding: 20px; background: #222; border-radius: 8px; border: 1px solid #333;">
                <h3 style="color: #fff; font-size: 18px; margin: 0 0 15px 0;"> Archivo ZIP</h3>
                <div style="border: 2px dashed #555; border-radius: 8px; padding: 30px; text-align: center; background: #1a1a1a;">
                    <div style="color: #888; font-size: 16px; margin-bottom: 10px;"> Arrastra tu archivo ZIP aqu o haz clic para seleccionar</div>
                    <input type="file" id="zipFileInput" accept=".zip" style="display: none;" onchange="handleZipFileSelect(event)">
                    <button onclick="document.getElementById('zipFileInput').click()" style="padding: 12px 24px; background-color: #007AFF; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer; margin-top: 10px;">Seleccionar ZIP</button>
                    <div id="selectedFileInfo" style="margin-top: 15px; color: #4CAF50; font-size: 14px; display: none;"></div>
                </div>
            </div>
            
            <!-- Track Names Section (shown after ZIP is selected) -->
            <div id="trackNamesSection" style="margin-bottom: 25px; display: none;">
                <h3 style="color: #fff; font-size: 18px; margin: 0 0 15px 0;"> Tracks Encontrados</h3>
                <div id="trackNamesList" style="display: flex; flex-direction: column; gap: 10px; max-height: 300px; overflow-y: auto; padding: 15px; background: #222; border-radius: 8px; border: 1px solid #333;">
                    <!-- Track names will be populated here -->
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="hideTrackNamesModal()" style="padding: 12px 24px; background-color: #666; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;">Cancelar</button>
                <button id="saveSongBtn" onclick="saveSongWithTracks()" style="padding: 12px 24px; background-color: #007AFF; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer; display: none;"> Guardar Cancin</button>
            </div>
        </div>
    </div>


    <!-- Auth Modal -->
    <div id="authModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 1000;">
        <div style="background-color: #1a1a1a; border-radius: 10px; padding: 30px; width: 400px; max-width: 90vw; border: 1px solid #333;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 id="authTitle" style="color: #fff; font-size: 24px; font-weight: bold; margin: 0;">Iniciar Sesin</h2>
                <button onclick="hideAuthModal()" style="background: none; border: none; color: #ccc; font-size: 24px; cursor: pointer; padding: 5px;"></button>
            </div>
            
            <!-- Google Sign In Button -->
            <button id="googleSignInBtn" onclick="handleGoogleSignIn()" class="google-signin-btn">
                <img src="https://developers.google.com/identity/images/g-logo.png" alt="Google" class="google-logo">
                Continuar con Google
            </button>
            
            <div class="divider">
                <span>o</span>
            </div>
            
            <form id="authForm" onsubmit="handleAuthSubmit(event)" style="display: flex; flex-direction: column; gap: 15px;">
                <div id="displayNameGroup" style="display: none; flex-direction: column; gap: 5px;">
                    <label style="color: #ccc; font-size: 14px; font-weight: bold;">Nombre de Usuario</label>
                    <input type="text" id="displayName" placeholder="Tu nombre de usuario" style="padding: 12px; border-radius: 6px; border: 1px solid #333; background-color: #222; color: #fff; font-size: 16px;">
                </div>
                
                <div style="display: flex; flex-direction: column; gap: 5px;">
                    <label style="color: #ccc; font-size: 14px; font-weight: bold;">Email</label>
                    <input type="email" id="email" placeholder="tu@email.com" required style="padding: 12px; border-radius: 6px; border: 1px solid #333; background-color: #222; color: #fff; font-size: 16px;">
                </div>
                
                <div style="display: flex; flex-direction: column; gap: 5px;">
                    <label style="color: #ccc; font-size: 14px; font-weight: bold;">Contrasea</label>
                    <input type="password" id="password" placeholder="Tu contrasea" required minlength="6" style="padding: 12px; border-radius: 6px; border: 1px solid #333; background-color: #222; color: #fff; font-size: 16px;">
                </div>
                
                <div id="authError" style="color: #ff4444; font-size: 14px; text-align: center; padding: 10px; background-color: rgba(255, 68, 68, 0.1); border-radius: 6px; display: none;"></div>
                
                <button type="submit" id="authSubmit" style="padding: 15px; background-color: #007AFF; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer; margin-top: 10px;">Iniciar Sesin</button>
            </form>
            
            <div style="margin-top: 20px; text-align: center;">
                <button id="authSwitch" onclick="toggleAuthMode()" style="background: none; border: none; color: #007AFF; font-size: 14px; cursor: pointer; text-decoration: underline;">No tienes cuenta? Crear una</button>
            </div>
        </div>
    </div>

    <!-- Loading Modal -->
    <div id="loadingModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 1002;">
        <div style="background-color: #1a1a1a; border-radius: 10px; padding: 30px; width: 400px; max-width: 90vw; border: 1px solid #333; text-align: center;">
            <div style="margin-bottom: 20px;">
                <div style="width: 50px; height: 50px; border: 4px solid #333; border-top: 4px solid #007AFF; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
                <div id="loadingText" style="color: #fff; font-size: 18px; font-weight: bold; margin-bottom: 15px;">Cargando...</div>
            </div>
            
            <div id="progressContainer" style="display: none;">
                <div style="background: #333; height: 8px; border-radius: 4px; overflow: hidden; margin-bottom: 10px;">
                    <div id="progressBar" style="background: linear-gradient(90deg, #007AFF, #00D4FF); height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                </div>
                <div id="progressText" style="color: #007AFF; font-size: 14px; font-weight: bold;">0%</div>
                <div id="progressDetails" style="color: #888; font-size: 12px; margin-top: 5px;">0 / 0</div>
            </div>
        </div>
    </div>

    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>

    <!-- Firebase SDK -->
        <script type="module">
            // Import Firebase modules
            import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
            import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, GoogleAuthProvider, signInWithPopup } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
            import { getFirestore, collection, addDoc, getDocs, doc, setDoc, getDoc, deleteDoc, updateDoc, query, where } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
            import { getStorage, ref, uploadBytes, getDownloadURL } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBR8aKDqgib3w149Dcl0IFfFsqLReui3Jo",
            authDomain: "mixercurse2.firebaseapp.com",
            projectId: "mixercurse2",
            storageBucket: "mixercurse2.firebasestorage.app",
            messagingSenderId: "509189891821",
            appId: "1:509189891821:web:bf05edec645d067d6f0ee4"
        };

        // Configurar Firebase para desarrollo local
        if (window.location.protocol === 'file:' || window.location.hostname === 'localhost') {
            console.log(' Configurando Firebase para desarrollo local...');
        }

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);

            // Make Firebase available globally
            window.firebase = { auth, db, storage, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, collection, addDoc, getDocs, doc, setDoc, getDoc, deleteDoc, updateDoc, query, where, ref, uploadBytes, getDownloadURL };
    </script>

    <script>
        console.log(' MAIN SCRIPT STARTED - Main JavaScript is running...');
        let tracks = [];
        let isPlaying = false;
        let currentBPM = 128;
        let originalBPM = 128; // BPM original de la cancin
        let tempoMultiplier = 1.0; // Multiplicador de tempo (1.0 = tempo original)
        let currentKey = 'C';
        let originalKey = 'C'; // Key original de la cancin
        let keyOffset = 0; // Offset en semitonos (0 = tono original)
        let currentTime = 0;
        let totalTime = 0; // Will be set when audio loads
        let timeUpdateInterval = null;
        let audioStartTime = 0;
        let pausedTime = 0;
        let isLooping = false;
        let masterVolume = 0.8; // Master volume (0.0 to 1.0)
        let currentUser = null;
        let lastUsedSetlist = null; // Store last used setlist
        let currentSetlist = null; // Current active setlist
        let audioContext = null;
        let audioBuffers = new Map(); // Store loaded audio buffers
        let audioSources = new Map(); // Store active audio sources
        let gainNodes = new Map(); // Store gain nodes for volume control
        let analysers = new Map(); // Store analyser nodes for VU meters
        let toneInitialized = false; // Track Tone.js initialization
        let vuMeterInterval = null; // Interval for updating VU meters
        
        // Song cache system
        let songCache = new Map(); // Cache loaded songs: songId -> {tracks, audioBuffers, metadata}
        let currentLoadedSongId = null; // Track currently loaded song
        let isLoadingSong = false; // Prevent multiple simultaneous loads
        
        // Progressive loading system
        let progressiveLoadingQueue = []; // Queue of songs to load progressively
        let isProgressiveLoading = false; // Flag to control progressive loading
        let currentLoadingSongIndex = 0; // Current song being loaded
        
        console.log(' SCRIPT LOADED - JavaScript is running...');
        
        // Initialize the application
        function init() {
            console.log(' INIT STARTED - Initializing MultiTrack Player...');
            
            // Try to restore user session from localStorage
            try {
                const savedUser = localStorage.getItem('lastUser');
                if (savedUser) {
                    const userData = JSON.parse(savedUser);
                    console.log(' Restoring user session:', userData.email);
                    // Set currentUser for immediate use
                    currentUser = userData;
                    // Update auth button
                    const authButton = document.getElementById('authButton');
                    if (authButton) {
                        authButton.textContent = ' ' + (userData.displayName || userData.email);
                    }
                }
            } catch (error) {
                console.log('No saved user session found');
            }
            
            // Check if JSZip is loaded
            if (typeof JSZip === 'undefined') {
                console.warn('JSZip not loaded. ZIP file upload will not work.');
            }
            
            // Ensure loading modal is hidden on startup
            hideLoading();
            
            // Clear any pending upload state
            currentExtractedFiles = [];
            currentSongName = '';
            hideTrackNamesModal();
            
            // Initialize audio context
            initAudioContext();
            
            generateTracks();
            generateSongs();
            generatePads();
            startTimeUpdate();
            initAuth();
            initLibrary();
            
            // Load library songs (auto-load is now handled in onAuthStateChanged)
            setTimeout(() => {
                if (currentUser) {
                    loadLibrarySongs();
                    loadLibrarySongsForSidebar();
                }
            }, 2000);
            
            // Add keyboard shortcut for debug buttons (Ctrl+Shift+D)
            document.addEventListener('keydown', function(e) {
                if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                    e.preventDefault();
                    toggleDebugButtons();
                }
            });
        }

        // Test Firebase connectivity
        async function testFirebaseConnectivity() {
            try {
                console.log(' Testing Firebase connectivity...');
                
                // Test Firestore connection
                const testCollection = window.firebase.collection(window.firebase.db, 'connectivity-test');
                const testDoc = window.firebase.doc(testCollection, 'test');
                
                // Try to write a test document
                await window.firebase.setDoc(testDoc, {
                    timestamp: new Date(),
                    test: true
                });
                console.log(' Firestore write test successful');
                
                // Try to read the test document
                const docSnap = await window.firebase.getDoc(testDoc);
                if (docSnap.exists()) {
                    console.log(' Firestore read test successful');
                }
                
                // Clean up test document
                await window.firebase.deleteDoc(testDoc);
                console.log(' Firestore connectivity test passed');
                
                return { success: true, message: 'Firebase connectivity OK' };
            } catch (error) {
                console.error(' Firebase connectivity test failed:', error);
                return { success: false, error: error.message };
            }
        }

        // Initialize Firebase Auth
        function initAuth() {
            console.log(' Initializing Firebase Auth...');
            console.log('Firebase object:', window.firebase);
            
            if (window.firebase) {
                console.log(' Firebase is available');
                console.log('Auth object:', window.firebase.auth);
                console.log('DB object:', window.firebase.db);
                
                // Test connectivity first
                testFirebaseConnectivity().then(result => {
                    if (result.success) {
                        console.log(' Firebase connectivity verified');
                    } else {
                        console.error(' Firebase connectivity issue:', result.error);
                        alert(` Firebase Connection Issue:\n\n${result.error}\n\nPlease check your internet connection and try again.`);
                    }
                });
                
                console.log(' SETTING UP onAuthStateChanged listener...');
                window.firebase.onAuthStateChanged(window.firebase.auth, (user) => {
                    console.log(' Auth state changed:', user ? 'User logged in' : 'User logged out');
                    currentUser = user;
                    updateAuthUI();
                    
                    if (user) {
                        console.log(' USER AUTHENTICATED - Starting user setup...');
                        console.log(' User details:', {
                            uid: user.uid,
                            email: user.email,
                            displayName: user.displayName
                        });
                        
                        // Loading screen removed
                        
                        // Load user's audio files and songs when logged in
                        loadUserAudioFiles();
                        loadUserSongs();
                        // Load library songs
                        setTimeout(() => {
                            loadLibrarySongs();
                            loadLibrarySongsForSidebar();
                        }, 1000);
                        
                        // Auto-load first setlist after user is authenticated
                        console.log(' SETTING TIMEOUT for auto-load first setlist...');
                        setTimeout(() => {
                            console.log(' Auto-loading first setlist...');
                            autoLoadLastSetlist();
                        }, 2000);
                    } else {
                        // Clear audio files list when logged out
                        const audioFilesContainer = document.getElementById('audioFilesList');
                        if (audioFilesContainer) {
                            audioFilesContainer.innerHTML = '';
                        }
                    }
                });
            } else {
                console.error(' Firebase not initialized');
            }
        }

        // Update UI based on auth state
        function updateAuthUI() {
            console.log(' Updating auth UI...');
            console.log(' Current user:', currentUser);
            
            const authButton = document.getElementById('authButton');
            if (authButton) {
                if (currentUser) {
                    console.log(' User is authenticated, updating UI...');
                    // Show user info with profile picture if available
                    const displayName = currentUser.displayName || currentUser.email;
                    const profileIcon = currentUser.photoURL ? 
                        `<img src="${currentUser.photoURL}" alt="Profile" style="width: 20px; height: 20px; border-radius: 50%; margin-right: 8px;">` : 
                        ' ';
                    
                    authButton.innerHTML = `${profileIcon}${displayName}`;
                    authButton.onclick = signOutUser;
                    console.log(' Auth button updated with user info');
                    
                    // Load user's audio files and songs when logged in
                    loadUserAudioFiles();
                    loadUserSongs();
                    // Load library songs
                    setTimeout(() => {
                        loadLibrarySongs();
                    }, 1000);
                } else {
                    console.log(' No user authenticated, showing login button');
                    authButton.textContent = ' Login';
                    authButton.onclick = showAuthModal;
                    // Clear audio files list when logged out
                    const audioFilesContainer = document.getElementById('audioFilesList');
                    if (audioFilesContainer) {
                        audioFilesContainer.innerHTML = '';
                    }
                }
            } else {
                console.error(' Auth button element not found');
            }
        }

        // Show auth modal
        function showAuthModal() {
            const modal = document.getElementById('authModal');
            if (modal) {
                modal.style.display = 'block';
                hideAuthError(); // Clear any previous errors
            }
        }

        // Hide auth modal
        function hideAuthModal() {
            const modal = document.getElementById('authModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Register user
        async function registerUser(email, password, displayName) {
            try {
                console.log(' Registering user:', email);
                const userCredential = await window.firebase.createUserWithEmailAndPassword(window.firebase.auth, email, password);
                const user = userCredential.user;
                console.log(' User created:', user.uid);
                
                // Create user document in Firestore
                console.log(' Creating user document in Firestore...');
                await window.firebase.setDoc(window.firebase.doc(window.firebase.db, 'users', user.uid), {
                    uid: user.uid,
                    email: user.email,
                    displayName: displayName,
                    createdAt: new Date(),
                    setlists: [],
                    preferences: {
                        theme: 'dark',
                        defaultBPM: 120,
                        defaultKey: 'C'
                    }
                });
                console.log(' User document created');
                
                hideAuthModal();
                return { success: true };
            } catch (error) {
                console.error(' Registration error:', error);
                return { success: false, error: error.message };
            }
        }

        // Sign in user
        async function signInUser(email, password) {
            try {
                await window.firebase.signInWithEmailAndPassword(window.firebase.auth, email, password);
                hideAuthModal();
                return { success: true };
            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        // Sign out user
        async function signOutUser() {
            try {
                await window.firebase.signOut(window.firebase.auth);
                return { success: true };
            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        // Sign in with Google
        async function signInWithGoogle() {
            try {
                console.log(' Starting Google Sign-In...');
                
                // Test connectivity first
                const connectivityTest = await testFirebaseConnectivity();
                if (!connectivityTest.success) {
                    throw new Error(`Firebase connectivity issue: ${connectivityTest.error}`);
                }
                
                const provider = new window.firebase.GoogleAuthProvider();
                console.log(' Opening Google Sign-In popup...');
                
                const result = await window.firebase.signInWithPopup(window.firebase.auth, provider);
                const user = result.user;
                console.log(' Google Sign-In successful:', user.email);

                // Update current user immediately
                currentUser = user;
                console.log(' Current user updated:', currentUser.uid);

                // Save user data to Firestore if it's a new user
                console.log(' Checking user document in Firestore...');
                const userRef = window.firebase.doc(window.firebase.db, 'users', user.uid);
                const userSnap = await window.firebase.getDoc(userRef);

                if (!userSnap.exists()) {
                    console.log(' Creating new user document...');
                    await window.firebase.setDoc(userRef, {
                        uid: user.uid,
                        email: user.email,
                        displayName: user.displayName,
                        photoURL: user.photoURL,
                        createdAt: new Date(),
                        setlists: [],
                        preferences: {
                            theme: 'dark',
                            defaultBPM: 120,
                            defaultKey: 'C'
                        }
                    });
                    console.log(' User document created');
                } else {
                    console.log(' User document already exists');
                }

                // Update UI immediately
                console.log(' Updating UI after successful sign-in...');
                updateAuthUI();

                return { success: true, user };
            } catch (error) {
                console.error(' Google Sign-In error:', error);
                
                // Provide more specific error messages
                let errorMessage = error.message;
                if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = 'Sign-in cancelled by user';
                } else if (error.code === 'auth/popup-blocked') {
                    errorMessage = 'Popup blocked by browser. Please allow popups for this site.';
                } else if (error.message.includes('client is offline')) {
                    errorMessage = 'No internet connection. Please check your connection and try again.';
                } else if (error.message.includes('Failed to fetch')) {
                    errorMessage = 'Network error. Please check your internet connection.';
                }
                
                return { success: false, error: errorMessage };
            }
        }

        // Upload audio file to B2 via proxy
        async function uploadAudioFile(file, userId) {
            try {
                console.log(' Uploading to B2 via proxy...');
                console.log(' Original file size:', file.size, 'bytes (', (file.size / 1024 / 1024).toFixed(2), 'MB)');
                console.log(' File type:', file.type);
                console.log(' File name:', file.name);
                console.log(' File instanceof File:', file instanceof File);
                console.log(' File constructor:', file.constructor.name);
                
                // Check file size limit (2GB)
                const maxSize = 2 * 1024 * 1024 * 1024; // 2GB
                if (file.size > maxSize) {
                    const errorTitle = 'Archivo Demasiado Grande';
                    const errorMessage = `El archivo "${file.name}" supera el lmite permitido.`;
                    const errorDetails = `Tamao actual: ${(file.size / 1024 / 1024).toFixed(2)} MB\nLmite mximo: 2,048 MB (2 GB)`;
                    
                    showErrorMessage(errorTitle, errorMessage, errorDetails);
                    throw new Error(`File too large: ${(file.size / 1024 / 1024).toFixed(2)}MB > 2048MB`);
                }
                
                // Convert to base64 using FileReader (more reliable for large files)
                console.log(' Converting file to base64...');
                const base64Data = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const result = reader.result;
                        console.log(' FileReader result length:', result.length, 'characters');
                        console.log(' FileReader result type:', typeof result);
                        console.log(' FileReader result starts with:', result.substring(0, 50));
                        
                        // Remove data URL prefix (data:audio/wav;base64,)
                        const base64 = result.split(',')[1];
                        console.log(' Base64 data length:', base64.length, 'characters');
                        console.log(' Base64 size estimate:', (base64.length * 0.75).toFixed(0), 'bytes');
                        console.log(' Base64 starts with:', base64.substring(0, 50));
                        console.log(' Base64 ends with:', base64.substring(base64.length - 50));
                        
                        // Verify base64 is not empty
                        if (!base64 || base64.length === 0) {
                            console.error(' Base64 data is empty!');
                            reject(new Error('Base64 conversion resulted in empty data'));
                            return;
                        }
                        
                        resolve(base64);
                    };
                    reader.onerror = (error) => {
                        console.error(' FileReader error:', error);
                        reject(error);
                    };
                    reader.onabort = (error) => {
                        console.error(' FileReader aborted:', error);
                        reject(new Error('FileReader was aborted'));
                    };
                    reader.onprogress = (event) => {
                        if (event.lengthComputable) {
                            const percentComplete = (event.loaded / event.total) * 100;
                            console.log(' FileReader progress:', percentComplete.toFixed(1) + '%');
                        }
                    };
                    reader.readAsDataURL(file);
                });
                
                const fileName = `audio/${userId}/${Date.now()}_${file.name}`;
                console.log(' Generated filename:', fileName);
                
                // Use single upload for now (more reliable)
                console.log(' Starting single upload...');
                return await uploadSingleFile(fileName, base64Data, file.type, userId, file.size, file.name);
                
            } catch (error) {
                console.error(' B2 upload error:', error);
                return { success: false, error: error.message };
            }
        }


        // Upload single file
        async function uploadSingleFile(fileName, base64Data, contentType, userId, fileSize, originalName) {
            const response = await fetch('http://localhost:3001/upload', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    fileName: fileName,
                    fileData: base64Data,
                    contentType: contentType
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Upload failed');
            }

            const result = await response.json();
            console.log('B2 upload successful:', result);
            console.log('Uploaded file size from B2:', result.data.size || 'unknown');

            // Save to Firestore
            const audioFileData = {
                userId: userId,
                originalName: originalName,
                fileName: fileName,
                fileId: result.data.fileId,
                downloadUrl: result.data.downloadUrl,
                size: fileSize,
                type: contentType,
                createdAt: new Date()
            };

            const docRef = await window.firebase.addDoc(window.firebase.collection(window.firebase.db, 'audioFiles'), audioFileData);
            
            return { 
                success: true, 
                data: {
                    id: docRef.id,
                    ...audioFileData
                }
            };
        }

        // Test B2 connection via proxy
        async function testB2Connection() {
            try {
                console.log(' Testing B2 connection via proxy...');
                
                // Test proxy connection
                const response = await fetch('http://localhost:3001/test');
                
                if (!response.ok) {
                    throw new Error(`Proxy test failed: ${response.status}`);
                }
                
                const result = await response.json();
                console.log('B2 proxy test result:', result);
                
                if (result.success) {
                    alert(' B2 Connection Successful!\n\nProxy: OK\nAuth: OK\nUpload URL: OK\nStorage: Backblaze B2');
                    return { success: true };
                } else {
                    throw new Error(result.error);
                }
                
            } catch (error) {
                console.error(' B2 connection test failed:', error);
                
                let errorMessage = error.message;
                if (error.message.includes('Failed to fetch')) {
                    errorMessage = 'El servidor proxy B2 no est ejecutndose.\n\nEjecuta: node b2-proxy.js';
                }
                
                alert(` B2 Connection Test Failed:\n\n${errorMessage}`);
                return { success: false, error: error.message };
            }
        }

        // Get B2 upload URL (deprecated - using Firebase Storage now)
        async function getB2UploadUrl() {
            return { success: false, error: 'B2 deprecated - using Firebase Storage' };
        }

        // Handle file upload
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!currentUser) {
                alert('Debes iniciar sesin para subir archivos');
                return;
            }

            // Check if it's a ZIP file for songs
            if (file.type === 'application/zip' || file.name.toLowerCase().endsWith('.zip')) {
                // Validate ZIP file size (max 500MB)
                const maxZipSize = 500 * 1024 * 1024; // 500MB
                if (file.size > maxZipSize) {
                    alert(`El archivo ZIP es demasiado grande. Mximo 500MB. Tamao actual: ${(file.size / 1024 / 1024).toFixed(2)}MB`);
                    return;
                }
                handleSongZipUpload(file);
            } else {
                // Handle single audio file
                const allowedTypes = ['audio/mpeg', 'audio/wav', 'audio/mp3', 'audio/m4a', 'audio/aac'];
                if (!allowedTypes.includes(file.type)) {
                    alert('Tipo de archivo no soportado. Use MP3, WAV, M4A, AAC o ZIP.');
                    return;
                }

                // Validate file size (max 100MB)
                const maxSize = 100 * 1024 * 1024; // 100MB
                if (file.size > maxSize) {
                    alert(`El archivo es demasiado grande. Mximo 100MB. Tamao actual: ${(file.size / 1024 / 1024).toFixed(2)}MB`);
                    return;
                }

                // Upload single audio file
                uploadAudioFile(file, currentUser.uid).then(result => {
                    if (result.success) {
                        alert('Archivo subido correctamente');
                        loadUserAudioFiles();
                    } else {
                        alert('Error al subir archivo: ' + result.error);
                    }
                });
            }
        }

        // Handle ZIP file upload for songs
        async function handleSongZipUpload(zipFile) {
            try {
                // Show loading
                showLoading('Descomprimiendo archivo ZIP...');

                // Add timeout to prevent hanging
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Timeout: El archivo ZIP es demasiado grande o est corrupto')), 60000); // 60 seconds
                });

                // Extract ZIP file with timeout
                const extractedFiles = await Promise.race([
                    extractZipFile(zipFile),
                    timeoutPromise
                ]);
                
                if (extractedFiles.length === 0) {
                    hideLoading();
                    alert('El archivo ZIP est vaco o no contiene archivos de audio vlidos.');
                    return;
                }

                // Validate individual track sizes
                const maxTrackSize = 100 * 1024 * 1024; // 100MB per track
                const oversizedTracks = [];
                
                extractedFiles.forEach((file, index) => {
                    if (file.size > maxTrackSize) {
                        oversizedTracks.push({
                            name: file.name,
                            size: (file.size / 1024 / 1024).toFixed(2) + 'MB'
                        });
                    }
                });

                if (oversizedTracks.length > 0) {
                    hideLoading();
                    const trackList = oversizedTracks.map(t => `- ${t.name} (${t.size})`).join('\n');
                    alert(`Los siguientes tracks exceden el lmite de 100MB:\n\n${trackList}\n\nPor favor, reduce el tamao de estos archivos.`);
                    return;
                }

                // Show track names for editing
                showTrackNamesModal(extractedFiles, zipFile.name);
                
            } catch (error) {
                hideLoading();
                alert('Error al procesar el archivo ZIP: ' + error.message);
            }
        }

        // Extract ZIP file
        async function extractZipFile(zipFile) {
            return new Promise((resolve, reject) => {
                // Check if JSZip is available
                if (typeof JSZip === 'undefined') {
                    reject(new Error('JSZip library not loaded. Please refresh the page.'));
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const zip = new JSZip();
                        zip.loadAsync(e.target.result).then(function(zip) {
                            const audioFiles = [];
                            const promises = [];

                            Object.keys(zip.files).forEach(function(filename) {
                                const file = zip.files[filename];
                                if (!file.dir && isAudioFile(filename)) {
                                    promises.push(
                                        file.async('blob').then(function(blob) {
                                            audioFiles.push({
                                                name: filename,
                                                blob: blob,
                                                size: blob.size,
                                                type: getAudioMimeType(filename)
                                            });
                                        })
                                    );
                                }
                            });

                            Promise.all(promises).then(() => {
                                resolve(audioFiles);
                            }).catch(reject);
                        }).catch(reject);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = reject;
                reader.readAsArrayBuffer(zipFile);
            });
        }

        // Check if file is audio
        function isAudioFile(filename) {
            const audioExtensions = ['.mp3', '.wav', '.m4a', '.aac', '.flac', '.ogg'];
            const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            return audioExtensions.includes(ext);
        }

        // Get MIME type from filename
        function getAudioMimeType(filename) {
            const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            const mimeTypes = {
                '.mp3': 'audio/mpeg',
                '.wav': 'audio/wav',
                '.m4a': 'audio/mp4',
                '.aac': 'audio/aac',
                '.flac': 'audio/flac',
                '.ogg': 'audio/ogg'
            };
            return mimeTypes[ext] || 'audio/mpeg';
        }

        // Load user's audio files
        async function loadUserAudioFiles() {
            if (!currentUser) return;

            try {
                const q = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'audioFiles'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );
                
                const querySnapshot = await window.firebase.getDocs(q);
                const audioFiles = [];
                
                querySnapshot.forEach((doc) => {
                    audioFiles.push({
                        id: doc.id,
                        ...doc.data()
                    });
                });
                
                displayAudioFiles(audioFiles);
            } catch (error) {
                console.error('Error loading audio files:', error);
            }
        }

        // Display audio files in UI
        function displayAudioFiles(files) {
            const audioFilesContainer = document.getElementById('audioFilesList');
            if (!audioFilesContainer) return;

            audioFilesContainer.innerHTML = '';
            
            files.forEach(file => {
                const fileItem = document.createElement('div');
                fileItem.className = 'audio-file-item';
                fileItem.innerHTML = `
                    <div class="file-info">
                        <div class="file-name">${file.originalName}</div>
                        <div class="file-size">${(file.size / 1024 / 1024).toFixed(2)} MB</div>
                    </div>
                    <div class="file-actions">
                        <button onclick="playAudioFile('${file.downloadUrl}')" class="play-btn"></button>
                        <button onclick="deleteAudioFile('${file.id}')" class="delete-btn"></button>
                    </div>
                `;
                audioFilesContainer.appendChild(fileItem);
            });
        }

        // Play audio file
        function playAudioFile(url) {
            const audio = new Audio(url);
            audio.play().catch(error => {
                console.error('Error playing audio:', error);
                alert('Error al reproducir el archivo');
            });
        }

        // Delete audio file
        async function deleteAudioFile(fileId) {
            if (!confirm('Ests seguro de que quieres eliminar este archivo?')) return;

            try {
                await window.firebase.deleteDoc(window.firebase.doc(window.firebase.db, 'audioFiles', fileId));
                loadUserAudioFiles();
                alert('Archivo eliminado correctamente');
            } catch (error) {
                console.error('Error deleting file:', error);
                alert('Error al eliminar el archivo');
            }
        }

        // Handle Google Sign In
        async function handleGoogleSignIn() {
            try {
                const result = await signInWithGoogle();
                if (result.success) {
                    hideAuthModal();
                    // UI is already updated in signInWithGoogle()
                    console.log(' Google Sign-In completed successfully');
                } else {
                    showAuthError(result.error);
                }
            } catch (error) {
                showAuthError('Error al iniciar sesin con Google: ' + error.message);
            }
        }

        // Show auth error
        function showAuthError(message) {
            const errorDiv = document.getElementById('authError');
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
            }
        }

        // Hide auth error
        function hideAuthError() {
            const errorDiv = document.getElementById('authError');
            if (errorDiv) {
                errorDiv.style.display = 'none';
            }
        }

        // Library functions
        let libraryOpen = false;
        let currentCategory = 'all';

        function toggleLibrary() {
            console.log(' Toggle library called, current state:', libraryOpen);
            const sidebar = document.getElementById('librarySidebar');
            if (sidebar) {
                libraryOpen = !libraryOpen;
                console.log(' New library state:', libraryOpen);
                if (libraryOpen) {
                    sidebar.classList.add('open');
                    console.log(' Loading library items...');
                    loadLibraryItems();
                } else {
                    sidebar.classList.remove('open');
                    console.log(' Library sidebar closed');
                }
            } else {
                console.error(' Library sidebar element not found');
            }
        }

        function loadLibraryItems() {
            const libraryItems = document.getElementById('sidebarLibraryItems');
            if (!libraryItems) return;

            // Load real library songs
            loadLibrarySongsForSidebar();
            
            // Load setlist buttons
            loadSetlistButtonsForSidebar();
            
            // Load current setlist
            loadCurrentSetlistForSidebar();
        }
        
        // Load library songs for sidebar (using the working logic from loadLibrarySongs)
        async function loadLibrarySongsForSidebar() {
            try {
                console.log(' Loading library songs for sidebar...');
                const libraryItems = document.getElementById('sidebarLibraryItems');
                if (!libraryItems) {
                    console.error(' sidebarLibraryItems element not found');
                    return;
                }
                
                libraryItems.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">Cargando biblioteca...</div>';
                
                console.log(' Current user:', currentUser ? currentUser.uid : 'No user');
                if (!currentUser) {
                    console.log(' No user logged in');
                    libraryItems.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">Inicia sesin para ver tu biblioteca</div>';
                    return;
                }

                console.log(' Querying Firestore for songs...');
                const songsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'songs'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );
                
                const querySnapshot = await window.firebase.getDocs(songsQuery);
                const songs = [];
                
                console.log(' Query snapshot size:', querySnapshot.size);
                
                querySnapshot.forEach((doc) => {
                    const songData = { id: doc.id, ...doc.data() };
                    console.log(' Found song:', songData.name, 'with', songData.tracks?.length || 0, 'tracks');
                    songs.push(songData);
                });
                
                console.log(' Library songs loaded:', songs.length);
                displayLibrarySongsForSidebar(songs);
                
            } catch (error) {
                console.error(' Error loading library songs for sidebar:', error);
                const libraryItems = document.getElementById('sidebarLibraryItems');
                if (libraryItems) {
                    libraryItems.innerHTML = '<div style="text-align: center; padding: 20px; color: #ff4444;">Error al cargar biblioteca: ' + error.message + '</div>';
                }
            }
        }

        // Display library songs for sidebar
        function displayLibrarySongsForSidebar(songs) {
            console.log(' Displaying library songs for sidebar:', songs.length);
            const libraryItems = document.getElementById('sidebarLibraryItems');
            
            if (!libraryItems) {
                console.error(' Sidebar library items element not found');
                return;
            }
            
            if (songs.length === 0) {
                console.log(' No songs found, showing empty state');
                libraryItems.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #888;">
                        <p>No tienes canciones en tu biblioteca</p>
                    </div>
                `;
                return;
            }
            
            let songsHTML = '';
            songs.forEach((song) => {
                songsHTML += `
                    <div class="library-item" draggable="true" data-song-id="${song.id}" data-song-name="${song.name}" data-song-tracks="${song.tracks?.length || 0}">
                        <div class="library-item-info">
                            <div class="library-item-name">${song.name}</div>
                            <div class="library-item-details">${song.tracks?.length || 0} tracks</div>
                        </div>
                        <div class="library-item-actions">
                            <button class="delete-library-btn" onclick="deleteSongFromLibrary('${song.id}', '${song.name}')" title="Eliminar cancin"></button>
                        </div>
                    </div>
                `;
            });
            
            libraryItems.innerHTML = songsHTML;
            console.log(' Generated HTML for', songs.length, 'songs in sidebar');
            
            // Add drag event listeners
            addDragListeners();
        }

        // Load setlist buttons for sidebar
        async function loadSetlistButtonsForSidebar() {
            try {
                console.log(' Loading setlist buttons for sidebar...');
                const setlistButtons = document.getElementById('sidebarSetlistButtons');
                
                if (!setlistButtons) {
                    console.error(' Sidebar setlist buttons element not found');
                    return;
                }
                
                if (!currentUser) {
                    console.log(' No user logged in');
                    setlistButtons.innerHTML = '<div style="text-align: center; padding: 10px; color: #888; font-size: 12px;">Inicia sesin para ver setlists</div>';
                    return;
                }

                console.log(' Querying Firestore for setlists...');
                const setlistsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'setlists'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );
                
                const querySnapshot = await window.firebase.getDocs(setlistsQuery);
                const setlists = [];
                
                console.log(' Setlists query result:', querySnapshot.size, 'setlists found');
                
                querySnapshot.forEach((doc) => {
                    const setlistData = { id: doc.id, ...doc.data() };
                    console.log(' Found setlist:', setlistData.name, 'with', setlistData.songs?.length || 0, 'songs');
                    setlists.push(setlistData);
                });
                
                if (setlists.length === 0) {
                    console.log(' No setlists found');
                    setlistButtons.innerHTML = '<div style="text-align: center; padding: 10px; color: #888; font-size: 12px;">No hay setlists creados</div>';
                    return;
                }
                
                let buttonsHTML = '';
                setlists.forEach((setlist) => {
                    const isActive = currentSetlist && currentSetlist.id === setlist.id;
                    buttonsHTML += `
                        <button class="setlist-btn ${isActive ? 'active' : ''}" 
                                onclick="switchToSetlist('${setlist.id}')" 
                                title="${setlist.name} (${setlist.songs?.length || 0} canciones)">
                            ${setlist.name}
                        </button>
                    `;
                });
                
                setlistButtons.innerHTML = buttonsHTML;
                console.log(' Generated HTML for', setlists.length, 'setlist buttons');
                
            } catch (error) {
                console.error(' Error loading setlist buttons for sidebar:', error);
                const setlistButtons = document.getElementById('sidebarSetlistButtons');
                if (setlistButtons) {
                    setlistButtons.innerHTML = '<div style="text-align: center; padding: 10px; color: #ff4444; font-size: 12px;">Error al cargar setlists</div>';
                }
            }
        }

        // Load current setlist for sidebar
        function loadCurrentSetlistForSidebar() {
            console.log(' SIDEBAR - Loading current setlist for sidebar...');
            console.log(' SIDEBAR - Current setlist:', currentSetlist);
            const setlistItems = document.getElementById('sidebarSetlistItems');
            const currentSetlistTitle = document.getElementById('currentSetlistTitle');
            
            console.log(' SIDEBAR - setlistItems element:', setlistItems);
            console.log(' SIDEBAR - currentSetlistTitle element:', currentSetlistTitle);
            
            if (!setlistItems) {
                console.error(' SIDEBAR - Sidebar setlist items element not found');
                return;
            }
            
            // Update title
            if (currentSetlistTitle) {
                const titleText = currentSetlist ? currentSetlist.name : 'Sin Setlist';
                console.log(' SIDEBAR - Updating title to:', titleText);
                currentSetlistTitle.textContent = titleText;
            }
            
            if (!currentSetlist || !currentSetlist.songs || currentSetlist.songs.length === 0) {
                console.log(' No current setlist or empty setlist');
                setlistItems.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: #888;">
                        <p>No hay setlist activo</p>
                        <p style="font-size: 12px; margin-top: 10px;">Arrastra canciones aqu desde la biblioteca</p>
                    </div>
                `;
                return;
            }
            
            let setlistHTML = '';
            currentSetlist.songs.forEach((song, index) => {
                setlistHTML += `
                    <div class="setlist-item" data-song-id="${song.id}" onclick="selectLibrarySong('${song.id}')">
                        <div class="setlist-item-info">
                            <div class="setlist-item-order">${index + 1}</div>
                            <div class="setlist-item-name">${song.name}</div>
                            <div class="setlist-item-details">${song.tracks?.length || 0} tracks</div>
                            <div class="setlist-loading-indicator" id="loading-${song.id}"></div>
                        </div>
                        <button class="remove-btn" onclick="event.stopPropagation(); removeFromSetlist('${song.id}')" title="Eliminar del setlist"></button>
                    </div>
                `;
            });
            
            console.log(' SIDEBAR - Generated HTML:', setlistHTML);
            setlistItems.innerHTML = setlistHTML;
            console.log(' SIDEBAR - Generated HTML for', currentSetlist.songs.length, 'songs in setlist sidebar');
            console.log(' SIDEBAR - setlistItems.innerHTML length:', setlistItems.innerHTML.length);
        }

        // Add drag and drop event listeners
        function addDragListeners() {
            const libraryItems = document.querySelectorAll('.library-item');
            const setlistItems = document.getElementById('sidebarSetlistItems');
            
            // Add drag start listeners to library items
            libraryItems.forEach(item => {
                item.addEventListener('dragstart', handleDragStart);
                item.addEventListener('dragend', handleDragEnd);
            });
            
            // Add drop listeners to setlist area
            if (setlistItems) {
                setlistItems.addEventListener('dragover', handleDragOver);
                setlistItems.addEventListener('drop', handleDrop);
                setlistItems.addEventListener('dragenter', handleDragEnter);
                setlistItems.addEventListener('dragleave', handleDragLeave);
            }
        }

        // Drag and drop event handlers
        function handleDragStart(e) {
            const songId = e.target.dataset.songId;
            const songName = e.target.dataset.songName;
            const songTracks = e.target.dataset.songTracks;
            
            e.dataTransfer.setData('text/plain', JSON.stringify({
                songId: songId,
                songName: songName,
                songTracks: songTracks
            }));
            
            e.target.classList.add('dragging');
            console.log(' Drag started for song:', songName);
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            console.log(' Drag ended');
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            e.target.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.target.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.target.classList.remove('drag-over');
            
            try {
                const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                console.log(' Dropped song:', data);
                
                // Add song to current setlist
                addSongToSetlist(data.songId, data.songName, data.songTracks);
                
            } catch (error) {
                console.error(' Error handling drop:', error);
            }
        }

        // Add song to setlist
        async function addSongToSetlist(songId, songName, songTracks) {
            try {
                if (!currentSetlist) {
                    alert(' No hay setlist activo. Crea un setlist primero.');
                    return;
                }
                
                // Check if song is already in setlist
                const existingSong = currentSetlist.songs.find(song => song.id === songId);
                if (existingSong) {
                    alert(' Esta cancin ya est en el setlist.');
                    return;
                }
                
                // Get full song data from Firestore to include artist, tempo, etc.
                const songRef = window.firebase.doc(window.firebase.db, 'songs', songId);
                const songSnap = await window.firebase.getDoc(songRef);
                
                if (!songSnap.exists()) {
                    alert(' Cancin no encontrada en la biblioteca.');
                    return;
                }
                
                const fullSongData = songSnap.data();
                console.log(' Full song data for setlist:', fullSongData);
                
                // Add song to setlist with complete information
                const newSong = {
                    id: songId,
                    name: fullSongData.name || songName,
                    artist: fullSongData.artist || '',
                    tempo: fullSongData.tempo || null,
                    key: fullSongData.key || '',
                    timeSignature: fullSongData.timeSignature || '',
                    tracks: fullSongData.tracks || [],
                    order: currentSetlist.songs.length + 1
                };
                
                currentSetlist.songs.push(newSong);
                
                // Save to Firebase
                await saveSetlistToFirebase(currentSetlist);
                
                // Update display
                loadCurrentSetlistForSidebar();
                updateSetlistDisplay();
                
                console.log(' Song added to setlist:', songName);
                alert(` "${songName}" agregada al setlist`);
                
            } catch (error) {
                console.error(' Error adding song to setlist:', error);
                alert(' Error al agregar cancin al setlist: ' + error.message);
            }
        }

        // Delete song from library
        async function deleteSongFromLibrary(songId, songName) {
            try {
                if (!currentUser) {
                    alert(' Debes iniciar sesin para eliminar canciones');
                    return;
                }
                
                if (!confirm(`Eliminar "${songName}" de la biblioteca?\n\nEsta accin eliminar la cancin permanentemente y no se puede deshacer.`)) {
                    return;
                }
                
                console.log(' Deleting song from library:', songId, songName);
                
                // Delete from Firestore
                const songRef = window.firebase.doc(window.firebase.db, 'songs', songId);
                await window.firebase.deleteDoc(songRef);
                
                console.log(' Song deleted from Firestore');
                
                // Reload library to update display
                await loadLibrarySongsForSidebar();
                
                alert(` "${songName}" eliminada de la biblioteca`);
                
            } catch (error) {
                console.error(' Error deleting song from library:', error);
                alert(' Error al eliminar cancin: ' + error.message);
            }
        }

        // Remove song from setlist
        async function removeFromSetlist(songId) {
            try {
                if (!currentSetlist || !currentSetlist.songs) {
                    return;
                }
                
                const songIndex = currentSetlist.songs.findIndex(song => song.id === songId);
                if (songIndex === -1) {
                    return;
                }
                
                const songName = currentSetlist.songs[songIndex].name;
                
                if (confirm(`Eliminar "${songName}" del setlist?`)) {
                    currentSetlist.songs.splice(songIndex, 1);
                    
                    // Update order numbers
                    currentSetlist.songs.forEach((song, index) => {
                        song.order = index + 1;
                    });
                    
                    // Save to Firebase
                    await saveSetlistToFirebase(currentSetlist);
                    
                    // Update display
                    loadCurrentSetlistForSidebar();
                    updateSetlistDisplay();
                    
                    // Update main setlist display
                    if (currentSetlist.songs && currentSetlist.songs.length > 0) {
                        displaySongs(currentSetlist.songs);
                    } else {
                        displayEmptySetlist();
                    }
                    
                    console.log(' Song removed from setlist:', songName);
                }
                
            } catch (error) {
                console.error(' Error removing song from setlist:', error);
                alert(' Error al eliminar cancin del setlist: ' + error.message);
            }
        }

        // Switch to a different setlist
        async function switchToSetlist(setlistId) {
            try {
                console.log(' Switching to setlist:', setlistId);
                
                if (!currentUser) {
                    alert(' Debes iniciar sesin para cambiar de setlist');
                    return;
                }
                
                // Load the setlist from Firebase
                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistDoc = await window.firebase.getDoc(setlistRef);
                
                if (!setlistDoc.exists()) {
                    alert(' El setlist no existe');
                    return;
                }
                
                const setlistData = { id: setlistDoc.id, ...setlistDoc.data() };
                
                // Set as current setlist
                currentSetlist = setlistData;
                
                // Save to localStorage and Firestore
                saveLastUsedSetlist(currentSetlist);
                
                // Update displays
                loadCurrentSetlistForSidebar();
                loadSetlistButtonsForSidebar(); // Refresh buttons to show active state
                updateSetlistDisplay();
                
                console.log(' Switched to setlist:', setlistData.name);
                alert(` Cambiado a setlist: "${setlistData.name}"`);
                
            } catch (error) {
                console.error(' Error switching to setlist:', error);
                alert(' Error al cambiar de setlist: ' + error.message);
            }
        }

        // Select and load a song from library
        async function selectLibrarySong(songId) {
            try {
                console.log(' Selecting library song:', songId);
                console.log(' About to call loadSong with ID:', songId);
                await loadSong(songId);
                console.log(' loadSong completed for ID:', songId);
            } catch (error) {
                console.error(' Error selecting library song:', error);
                console.error(' Error details:', error.message);
                console.error(' Error stack:', error.stack);
            }
        }

        // Download song locally
        async function downloadSong(songId) {
            try {
                console.log(' Downloading song:', songId);
                // TODO: Implement local download
                alert('Funcionalidad de descarga local en desarrollo');
            } catch (error) {
                console.error(' Error downloading song:', error);
            }
        }

        // Test library load function
        async function testLibraryLoad() {
            console.log(' Testing library load...');
            console.log(' Current user:', currentUser);
            console.log(' Firebase object:', window.firebase);
            
            if (!currentUser) {
                alert(' No hay usuario autenticado');
                return;
            }
            
            if (!window.firebase) {
                alert(' Firebase no est disponible');
                return;
            }
            
            try {
                await loadLibrarySongs();
                alert(' Test de biblioteca completado. Revisa la consola para detalles.');
            } catch (error) {
                alert(' Error en test de biblioteca: ' + error.message);
            }
        }

        // Load tracks for a specific song
        async function loadSongTracks(songData, useModal = true) {
            console.log(' Loading song tracks:', songData);
            console.log(' Song name:', songData.name);
            console.log(' Song tracks:', songData.tracks);
            
            // Show loading indicator (modal only if requested)
            if (useModal) {
                showLoading(`Cargando "${songData.name}" en cach...`);
            }
            
            // No cleanup here - let loadSong handle it
            console.log(' No cleanup in loadSongTracks - loadSong handles it');
            
            // Load tracks based on song data
            console.log(' Song data structure:', songData);
            console.log(' Song tracks:', songData.tracks);
            
            // Handle different track data structures
            let trackData = [];
            if (songData.tracks && Array.isArray(songData.tracks)) {
                // Check if tracks are objects or strings
                if (typeof songData.tracks[0] === 'object' && songData.tracks[0] !== null) {
                    // Tracks are objects with name, downloadUrl, etc.
                    trackData = songData.tracks;
                } else {
                    // Tracks are just names (strings)
                    trackData = songData.tracks.map(name => ({ name: name }));
                }
            } else {
                // Fallback to default track names
                trackData = [
                    { name: 'Drums' },
                    { name: 'Bass' },
                    { name: 'Guitar' },
                    { name: 'Keys' },
                    { name: 'Vocals' },
                    { name: 'Backing Vocals' }
                ];
            }
            
            tracks = trackData.map((track, index) => {
                // Extract track name properly
                let trackName = '';
                if (typeof track === 'string') {
                    trackName = track;
                } else if (track && typeof track === 'object') {
                    trackName = track.name || track.title || `Track ${index + 1}`;
                } else {
                    trackName = `Track ${index + 1}`;
                }
                
                const trackObj = {
                    id: index + 1,
                    name: trackName,
                    volume: 0.8,
                    muted: false,
                    solo: false,
                    playing: false,
                    audioUrl: track.downloadUrl || track.audioUrl || null
                };
                console.log(` Created track ${index + 1}:`, trackObj);
                return trackObj;
            });
            
            // Load audio files for each track (online playback from B2)
            let maxDuration = 0;
            console.log(' Starting to load audio files for', tracks.length, 'tracks');
            
            // Start loading tracks
            console.log(' Starting to load audio files for', tracks.length, 'tracks');
            
            for (let i = 0; i < tracks.length; i++) {
                const track = tracks[i];
                let audioUrl = track.audioUrl;
                
                // Update loading progress
                const progress = Math.round((i / tracks.length) * 100);
                if (useModal) {
                    updateLoadingProgress(`Cargando track ${i + 1}/${tracks.length}: ${track.name}`, progress);
                } else {
                    // Update small progress bar for the song being loaded
                    updateSongLoadingProgress(songData.id, progress);
                }
                
                console.log(` Processing track ${track.id} (${track.name}):`);
                console.log('  - track.audioUrl:', track.audioUrl);
                console.log('  - track.originalUrl:', track.originalUrl);
                console.log('  - track.downloadUrl:', track.downloadUrl);
                console.log('  - Full track object:', track);
                
                // Use B2 URLs for online playback
                if (track.originalUrl) {
                    console.log(' Using B2 URL for online playback:', track.name);
                    audioUrl = track.originalUrl;
                } else if (track.downloadUrl) {
                    console.log(' Using download URL for online playback:', track.name);
                    audioUrl = track.downloadUrl;
                }
                
                if (audioUrl) {
                    console.log(' Loading audio for track:', track.name, 'from B2 (online playback)');
                    console.log(' Audio URL:', audioUrl);
                    console.log(' Track ID:', track.id);
                    
                    // Log progress
                    console.log(` Loading track ${i + 1}/${tracks.length}: ${track.name}`);
                    
                    try {
                        console.log(' Calling loadAudioFile for track:', track.id);
                        const audioBuffer = await loadAudioFile(audioUrl, track.id);
                        console.log(' loadAudioFile returned:', audioBuffer ? 'SUCCESS' : 'FAILED');
                        
                        if (audioBuffer) {
                            maxDuration = Math.max(maxDuration, audioBuffer.duration);
                            console.log(' Track duration:', audioBuffer.duration, 'seconds');
                            console.log(' Track duration formatted:', formatTime(audioBuffer.duration));
                            console.log(' Max duration so far:', maxDuration, 'seconds');
                            console.log(' Audio buffer stored for track:', track.id);
                            console.log(' Audio buffers map size:', audioBuffers.size);
                            console.log(' Buffer exists in map:', audioBuffers.has(track.id));
                        } else {
                            console.error(' Failed to load audio buffer for track:', track.id);
                            console.error(' loadAudioFile returned null/undefined');
                        }
                    } catch (error) {
                        console.error(' Error loading audio for track:', track.id, error);
                        console.error(' Error details:', error.message);
                        console.error(' Error stack:', error.stack);
                    }
                } else {
                    console.warn(' No audio URL for track:', track.name);
                    console.warn(' Track object:', track);
                }
                
                // Log progress for this track
                console.log(` Track ${i + 1}/${tracks.length} completed: ${track.name}`);
            }
            
            console.log(' Finished loading audio files. Total buffers:', audioBuffers.size);
            console.log(' Available buffer IDs:', Array.from(audioBuffers.keys()));
            
            // Verify all tracks have buffers
            const missingBuffers = tracks.filter(track => !audioBuffers.has(track.id));
            if (missingBuffers.length > 0) {
                console.warn(' Tracks without buffers:', missingBuffers.map(t => `${t.id} (${t.name})`));
                console.warn(' This will cause playback issues');
            } else {
                console.log(' All tracks have audio buffers loaded');
            }
            
            // Set total time to the longest track duration
            if (maxDuration > 0) {
                totalTime = maxDuration;
                console.log(' Total song duration set to:', totalTime, 'seconds');
                updateTimeDisplay();
            }
            
            updateTracksGrid();
            
            // Update BPM and Key displays with song metadata
            if (songData.tempo) {
                setOriginalBPM(songData.tempo);
            }
            if (songData.key) {
                setOriginalKey(songData.key);
            }
            
            // Debug: Check loaded buffers
            console.log(' Debug: Checking loaded audio buffers...');
            console.log(' Total tracks:', tracks.length);
            console.log(' Audio buffers map size:', audioBuffers.size);
            console.log(' Available buffer IDs:', Array.from(audioBuffers.keys()));
            
            // Check each track
            tracks.forEach(track => {
                const hasBuffer = audioBuffers.has(track.id);
                console.log(` Track ${track.id} (${track.name}): ${hasBuffer ? ' Has buffer' : ' No buffer'}`);
                console.log(`  - Audio URL: ${track.audioUrl || 'None'}`);
            });
            
            console.log(' Finished loading all tracks');
            
            // Show 100% completion before hiding
            updateLoadingProgress('Carga completa! Preparando mezcla...', 100);
            
            // Small delay to show completion, then hide loading indicator
            setTimeout(() => {
                hideLoading();
            }, 800);
        }

        // Clear tracks when no song is selected
        function clearTracks() {
            tracks = [];
            updateTracksGrid();
        }

        // Global variables for song upload
        let currentExtractedFiles = [];
        let currentSongName = '';

        // Show track names modal
        // Show track names modal (new version for form-based upload)
        function showTrackNamesModal() {
            const modal = document.getElementById('trackNamesModal');
            
            // Reset form
            document.getElementById('songName').value = '';
            document.getElementById('songArtist').value = '';
            document.getElementById('songTempo').value = '';
            document.getElementById('songKey').value = '';
            document.getElementById('songTimeSignature').value = '';
            
            // Hide sections that will be shown after ZIP selection
            document.getElementById('trackNamesSection').style.display = 'none';
            document.getElementById('saveSongBtn').style.display = 'none';
            document.getElementById('selectedFileInfo').style.display = 'none';
            
            modal.style.display = 'flex';
        }

        // Handle ZIP file selection
        async function handleZipFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                console.log(' ZIP file selected:', file.name);
                
                // Show file info
                const fileInfo = document.getElementById('selectedFileInfo');
                fileInfo.innerHTML = ` Archivo seleccionado: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
                fileInfo.style.display = 'block';
                
                // Show loading
                showLoading('Descomprimiendo archivo ZIP...');
                
                // Extract ZIP file
                await extractZipFile(file);
                
                // Hide loading
                hideLoading();
                
                // Show track names section
                showTrackNamesSection();
                
            } catch (error) {
                console.error(' Error processing ZIP file:', error);
                hideLoading();
                alert(' Error al procesar el archivo ZIP: ' + error.message);
            }
        }

        // Extract ZIP file
        async function extractZipFile(zipFile) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        JSZip.loadAsync(e.target.result).then(function(zip) {
                            const files = [];
                            let processedCount = 0;
                            const totalFiles = Object.keys(zip.files).length;
                            
                            if (totalFiles === 0) {
                                reject(new Error('El archivo ZIP est vaco'));
                                return;
                            }
                            
                            Object.keys(zip.files).forEach(function(filename) {
                                const file = zip.files[filename];
                                
                                // Skip directories and non-audio files
                                if (file.dir || !isAudioFile(filename)) {
                                    processedCount++;
                                    if (processedCount === totalFiles) {
                                        if (files.length === 0) {
                                            reject(new Error('No se encontraron archivos de audio en el ZIP'));
                                        } else {
                                            currentExtractedFiles = files;
                                            resolve(files);
                                        }
                                    }
                                    return;
                                }
                                
                                // Extract audio file
                                file.async('blob').then(function(content) {
                                    const audioFile = new File([content], filename, { type: getAudioMimeType(filename) });
                                    files.push(audioFile);
                                    
                                    processedCount++;
                                    if (processedCount === totalFiles) {
                                        if (files.length === 0) {
                                            reject(new Error('No se encontraron archivos de audio vlidos en el ZIP'));
                                        } else {
                                            currentExtractedFiles = files;
                                            resolve(files);
                                        }
                                    }
                                }).catch(function(error) {
                                    console.error('Error extracting file:', filename, error);
                                    processedCount++;
                                    if (processedCount === totalFiles) {
                                        if (files.length === 0) {
                                            reject(new Error('Error al extraer archivos del ZIP'));
                                        } else {
                                            currentExtractedFiles = files;
                                            resolve(files);
                                        }
                                    }
                                });
                            });
                        }).catch(function(error) {
                            reject(new Error('Error al leer el archivo ZIP: ' + error.message));
                        });
                    } catch (error) {
                        reject(new Error('Error al procesar el archivo ZIP: ' + error.message));
                    }
                };
                reader.onerror = function() {
                    reject(new Error('Error al leer el archivo'));
                };
                reader.readAsArrayBuffer(zipFile);
            });
        }

        // Check if file is audio
        function isAudioFile(filename) {
            const audioExtensions = ['.mp3', '.wav', '.m4a', '.aac', '.ogg', '.flac'];
            const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            return audioExtensions.includes(ext);
        }

        // Get MIME type for audio file
        function getAudioMimeType(filename) {
            const ext = filename.toLowerCase().substring(filename.lastIndexOf('.'));
            const mimeTypes = {
                '.mp3': 'audio/mpeg',
                '.wav': 'audio/wav',
                '.m4a': 'audio/mp4',
                '.aac': 'audio/aac',
                '.ogg': 'audio/ogg',
                '.flac': 'audio/flac'
            };
            return mimeTypes[ext] || 'audio/mpeg';
        }

        // Show track names section
        function showTrackNamesSection() {
            const trackNamesSection = document.getElementById('trackNamesSection');
            const trackNamesList = document.getElementById('trackNamesList');
            const saveSongBtn = document.getElementById('saveSongBtn');
            
            // Populate track names
            trackNamesList.innerHTML = '';
            currentExtractedFiles.forEach((file, index) => {
                const trackItem = document.createElement('div');
                trackItem.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 10px; background: #333; border-radius: 6px;';
                
                const trackName = file.name.replace(/\.[^/.]+$/, ""); // Remove extension
                
                trackItem.innerHTML = `
                    <div style="color: #888; font-size: 12px; min-width: 30px;">${index + 1}</div>
                    <input type="text" value="${trackName}" data-index="${index}" 
                           style="flex: 1; padding: 8px; border: 1px solid #555; border-radius: 4px; background: #444; color: #fff; font-size: 14px;">
                    <div style="color: #888; font-size: 12px;">${(file.size / 1024 / 1024).toFixed(2)} MB</div>
                `;
                
                trackNamesList.appendChild(trackItem);
            });
            
            // Show sections
            trackNamesSection.style.display = 'block';
            saveSongBtn.style.display = 'inline-block';
        }

        // Hide track names modal
        function hideTrackNamesModal() {
            const modal = document.getElementById('trackNamesModal');
            modal.style.display = 'none';
            currentExtractedFiles = [];
        }

        // Show loading indicator for specific song in setlist
        function showSetlistLoading(songId) {
            console.log(' Showing loading indicator for song:', songId);
            const loadingIndicator = document.getElementById(`loading-${songId}`);
            console.log(' Loading indicator element:', loadingIndicator);
            if (loadingIndicator) {
                loadingIndicator.classList.add('loading');
                console.log(' Loading indicator activated for song:', songId);
            } else {
                console.error(' Loading indicator not found for song:', songId);
                console.error(' Expected ID:', `loading-${songId}`);
            }
        }
        
        // Hide loading indicator for specific song in setlist
        function hideSetlistLoading(songId) {
            console.log(' Hiding loading indicator for song:', songId);
            const loadingIndicator = document.getElementById(`loading-${songId}`);
            console.log(' Loading indicator element:', loadingIndicator);
            if (loadingIndicator) {
                loadingIndicator.classList.remove('loading');
                console.log(' Loading indicator deactivated for song:', songId);
            } else {
                console.error(' Loading indicator not found for song:', songId);
                console.error(' Expected ID:', `loading-${songId}`);
            }
        }
        
        // Show loading modal
        function showLoading(text = 'Procesando...') {
            const modal = document.getElementById('loadingModal');
            const loadingText = document.getElementById('loadingText');
            const progressContainer = document.getElementById('progressContainer');
            
            if (modal) {
                modal.style.display = 'flex';
            }
            
            if (loadingText) {
                loadingText.textContent = text;
            }
            
            if (progressContainer) {
                progressContainer.style.display = 'none'; // Hide progress bar by default
            }
        }

        // Show loading modal with progress bar
        function showLoadingWithProgress(text = 'Procesando...', total = 0) {
            const modal = document.getElementById('loadingModal');
            const loadingText = document.getElementById('loadingText');
            const progressContainer = document.getElementById('progressContainer');
            const progressText = document.getElementById('progressText');
            const progressDetails = document.getElementById('progressDetails');
            const progressBar = document.getElementById('progressBar');
            
            if (modal) {
                modal.style.display = 'flex';
            }
            
            if (loadingText) {
                loadingText.textContent = text;
            }
            
            if (progressContainer) {
                progressContainer.style.display = 'block';
            }
            
            if (progressText) {
                progressText.textContent = '0%';
            }
            
            if (progressDetails) {
                progressDetails.textContent = `0 / ${total}`;
            }
            
            if (progressBar) {
                progressBar.style.width = '0%';
            }
        }

        // Update progress bar
        function updateProgress(current, total, text = '') {
            const progressText = document.getElementById('progressText');
            const progressDetails = document.getElementById('progressDetails');
            const progressBar = document.getElementById('progressBar');
            const loadingText = document.getElementById('loadingText');
            
            // Check if elements exist before updating
            if (progressText) {
                const percentage = Math.round((current / total) * 100);
                progressText.textContent = `${percentage}%`;
            }
            
            if (progressDetails) {
                progressDetails.textContent = `${current} / ${total}`;
            }
            
            if (progressBar) {
                const percentage = Math.round((current / total) * 100);
                progressBar.style.width = `${percentage}%`;
            }
            
            if (text && loadingText) {
                loadingText.textContent = text;
            }
        }

        // Update loading progress for cache operations
        function updateLoadingProgress(text, progress) {
            const modal = document.getElementById('loadingModal');
            const loadingText = document.getElementById('loadingText');
            const progressContainer = document.getElementById('progressContainer');
            const progressText = document.getElementById('progressText');
            const progressBar = document.getElementById('progressBar');
            
            // Ensure modal is shown
            if (modal) {
                modal.style.display = 'flex';
            }
            
            // Update loading text
            if (loadingText) {
                loadingText.textContent = text;
            }
            
            // Show and update progress bar
            if (progressContainer) {
                progressContainer.style.display = 'block';
            }
            
            if (progressText) {
                progressText.textContent = `${progress}%`;
            }
            
            if (progressBar) {
                progressBar.style.width = `${progress}%`;
            }
        }

        // Hide loading modal
        function hideLoading() {
            const modal = document.getElementById('loadingModal');
            const progressContainer = document.getElementById('progressContainer');
            
            if (modal) {
                modal.style.display = 'none';
            }
            if (progressContainer) {
                progressContainer.style.display = 'none';
            }
        }

        // Show error message modal
        function showErrorMessage(title, message, details = '') {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1003;
            `;
            
            modal.innerHTML = `
                <div style="
                    background-color: #1a1a1a;
                    border-radius: 10px;
                    padding: 30px;
                    text-align: center;
                    border: 1px solid #333;
                    max-width: 500px;
                    width: 90vw;
                ">
                    <div style="color: #ff4444; font-size: 48px; margin-bottom: 20px;"></div>
                    <div style="color: #fff; font-size: 20px; font-weight: bold; margin-bottom: 15px;">${title}</div>
                    <div style="color: #ccc; font-size: 16px; margin-bottom: 20px; line-height: 1.5;">${message}</div>
                    ${details ? `<div style="color: #888; font-size: 14px; margin-bottom: 20px; background: #222; padding: 10px; border-radius: 5px; font-family: monospace;">${details}</div>` : ''}
                    <button onclick="this.parentElement.parentElement.remove()" style="
                        padding: 12px 24px;
                        background-color: #007AFF;
                        color: white;
                        border: none;
                        border-radius: 6px;
                        font-size: 14px;
                        cursor: pointer;
                    ">Entendido</button>
                </div>
            `;
            
            document.body.appendChild(modal);
        }

        // Save song with tracks
        async function saveSongWithTracks() {
            try {
                if (!currentUser) {
                    alert('Debes iniciar sesin para guardar canciones');
                    return;
                }

                // Get form data
                const songName = document.getElementById('songName').value.trim();
                const songArtist = document.getElementById('songArtist').value.trim();
                const songTempo = document.getElementById('songTempo').value;
                const songKey = document.getElementById('songKey').value;
                const songTimeSignature = document.getElementById('songTimeSignature').value;

                // Validate required fields
                if (!songName) {
                    alert('Por favor ingresa un nombre para la cancin');
                    return;
                }

                if (currentExtractedFiles.length === 0) {
                    alert('No hay archivos de audio para guardar');
                    return;
                }

                // Check total song size (sum of all tracks)
                const totalSize = currentExtractedFiles.reduce((sum, file) => sum + file.size, 0);
                const maxTotalSize = 10 * 1024 * 1024 * 1024; // 10GB total limit
                
                if (totalSize > maxTotalSize) {
                    const errorTitle = 'Cancin Demasiado Grande';
                    const errorMessage = `La cancin completa supera el lmite permitido.`;
                    const errorDetails = `Tamao total: ${(totalSize / 1024 / 1024 / 1024).toFixed(2)} GB\nLmite mximo: 10 GB\nNmero de tracks: ${currentExtractedFiles.length}`;
                    
                    showErrorMessage(errorTitle, errorMessage, errorDetails);
                    return;
                }

                // Check individual track sizes
                const oversizedTracks = currentExtractedFiles.filter(file => file.size > 2 * 1024 * 1024 * 1024);
                if (oversizedTracks.length > 0) {
                    const trackNames = oversizedTracks.map(file => file.name).join(', ');
                    const errorTitle = 'Tracks Demasiado Grandes';
                    const errorMessage = `Algunos tracks superan el lmite individual permitido.`;
                    const errorDetails = `Tracks problemticos: ${trackNames}\nLmite por track: 2 GB`;
                    
                    showErrorMessage(errorTitle, errorMessage, errorDetails);
                    return;
                }

                // Get track names from inputs
                const trackNames = [];
                const trackInputs = document.querySelectorAll('#trackNamesList input[data-index]');
                trackInputs.forEach(input => {
                    const index = parseInt(input.dataset.index);
                    const name = input.value.trim() || `Track ${index + 1}`;
                    trackNames[index] = name;
                });

                // Show progress bar
                showLoadingWithProgress('Subiendo archivos a la nube...', currentExtractedFiles.length);

                // Upload files to B2 and save to Firestore with metadata
                const songData = await uploadSongToCloud(songName, trackNames, currentExtractedFiles, {
                    artist: songArtist,
                    tempo: songTempo ? parseInt(songTempo) : null,
                    key: songKey,
                    timeSignature: songTimeSignature
                });
                
                if (songData.success) {
                    hideTrackNamesModal();
                    hideLoading();
                    alert(songData.message || 'Cancin guardada exitosamente!');
                    loadLibrarySongs(); // Load updated songs list
                    loadLibrarySongsForSidebar(); // Update sidebar
                } else {
                    hideLoading();
                    alert('Error al guardar la cancin: ' + songData.error);
                }
                
            } catch (error) {
                hideLoading();
                
                // Show detailed error message
                const errorTitle = 'Error al Guardar Cancin';
                let errorMessage = 'Ocurri un error inesperado al guardar la cancin.';
                let errorDetails = error.message;
                
                // Provide more specific error messages
                if (error.message.includes('File too large')) {
                    errorMessage = 'Uno o ms archivos superan el lmite permitido.';
                    errorDetails = 'Lmite por archivo: 2 GB\nLmite total de cancin: 10 GB';
                } else if (error.message.includes('network') || error.message.includes('fetch')) {
                    errorMessage = 'Error de conexin. Verifica tu conexin a internet.';
                    errorDetails = 'Detalles: ' + error.message;
                } else if (error.message.includes('auth') || error.message.includes('permission')) {
                    errorMessage = 'Error de autenticacin. Inicia sesin nuevamente.';
                    errorDetails = 'Detalles: ' + error.message;
                }
                
                showErrorMessage(errorTitle, errorMessage, errorDetails);
            }
        }

        // Upload song to B2
        async function uploadSongToCloud(songName, trackNames, extractedFiles, metadata = {}) {
            try {
                const userId = currentUser.uid;
                const songId = Date.now().toString();
                
                // Upload each track file to B2
                const uploadedTracks = [];
                
                for (let i = 0; i < extractedFiles.length; i++) {
                    const file = extractedFiles[i];
                    const trackName = trackNames[i] || `Track ${i + 1}`;
                    
                    // Update progress
                    updateProgress(i, extractedFiles.length, `Subiendo ${trackName} a B2...`);
                    
                    console.log(` Uploading track ${i + 1}: ${trackName} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);
                    
                    // Upload to B2 (file is already a valid File object)
                    const uploadResult = await uploadAudioFile(file, userId);
                    if (!uploadResult.success) {
                        throw new Error(`Error al subir ${trackName}: ${uploadResult.error}`);
                    }
                    
                    console.log(` Track ${i + 1} uploaded successfully: ${trackName}`);
                    
                    uploadedTracks.push({
                        name: trackName,
                        fileName: uploadResult.data.fileName,
                        fileId: uploadResult.data.fileId,
                        downloadUrl: uploadResult.data.downloadUrl,
                        size: file.size,
                        type: file.type,
                        storage: 'b2'
                    });
                }
                
                // Update progress to 100%
                updateProgress(extractedFiles.length, extractedFiles.length, 'Guardando en base de datos...');
                
                    // Save song data to Firestore
                    const songData = {
                        userId: userId,
                        songId: songId,
                        name: songName,
                        artist: metadata.artist || '',
                        tempo: metadata.tempo || null,
                        key: metadata.key || '',
                        timeSignature: metadata.timeSignature || '',
                        tracks: uploadedTracks,
                        storage: 'b2',
                        createdAt: new Date(),
                        updatedAt: new Date()
                    };
                    
                    console.log(' Saving song to Firestore:', songData.name, 'with', songData.tracks.length, 'tracks');
                    const docRef = await window.firebase.addDoc(window.firebase.collection(window.firebase.db, 'songs'), songData);
                    console.log(' Song saved with ID:', docRef.id);
                
                return { 
                    success: true, 
                    data: songData,
                    message: 'Cancin guardada en Backblaze B2'
                };
                
            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        // Load user's songs
        async function loadUserSongs() {
            if (!currentUser) return;

            try {
                console.log(' Loading user songs for:', currentUser.uid);
                
                const q = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'songs'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );
                
                const querySnapshot = await window.firebase.getDocs(q);
                const songs = [];
                
                console.log(' Query snapshot size:', querySnapshot.size);
                
                querySnapshot.forEach((doc) => {
                    const songData = {
                        id: doc.id,
                        ...doc.data()
                    };
                    console.log(' Found song:', songData.name, 'with', songData.tracks?.length || 0, 'tracks');
                    songs.push(songData);
                });
                
                console.log(' Total songs loaded:', songs.length);
                // Note: Songs are now displayed in library tab, not setlist
            } catch (error) {
                console.error('Error loading songs:', error);
            }
        }

        // Update song data in setlist with complete information from Firestore
        async function updateSetlistSongData(songs) {
            console.log(' Updating setlist song data with complete information...');
            const updatedSongs = [];
            
            for (const song of songs) {
                try {
                    // If song already has complete data, keep it
                    if (song.artist && song.tempo && song.key) {
                        console.log(' Song already has complete data:', song.name);
                        updatedSongs.push(song);
                        continue;
                    }
                    
                    // Get complete data from Firestore
                    const songRef = window.firebase.doc(window.firebase.db, 'songs', song.id);
                    const songSnap = await window.firebase.getDoc(songRef);
                    
                    if (songSnap.exists()) {
                        const fullSongData = songSnap.data();
                        const updatedSong = {
                            ...song,
                            name: fullSongData.name || song.name,
                            artist: fullSongData.artist || song.artist || '',
                            tempo: fullSongData.tempo || song.tempo || null,
                            key: fullSongData.key || song.key || '',
                            timeSignature: fullSongData.timeSignature || song.timeSignature || '',
                            tracks: fullSongData.tracks || song.tracks || []
                        };
                        updatedSongs.push(updatedSong);
                        console.log(' Updated song data:', updatedSong.name, 'Artist:', updatedSong.artist);
                    } else {
                        console.warn(' Song not found in Firestore:', song.id);
                        updatedSongs.push(song);
                    }
                } catch (error) {
                    console.error(' Error updating song data:', song.id, error);
                    updatedSongs.push(song);
                }
            }
            
            return updatedSongs;
        }

        // Display songs in a specific setlist
        async function displaySongs(songs) {
            console.log(' displaySongs called with:', songs.length, 'songs');
            console.log(' First song data:', songs[0]);
            
            // Update song data with complete information
            const updatedSongs = await updateSetlistSongData(songs);
            console.log(' Updated songs data:', updatedSongs);
            
            const songList = document.getElementById('songList');
            if (!songList) return;

            songList.innerHTML = '';
            
            if (updatedSongs.length === 0) {
                // Show empty state message
                const emptyState = document.createElement('div');
                emptyState.className = 'empty-setlist-state';
                emptyState.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: #888;">
                        <div style="font-size: 48px; margin-bottom: 16px;"></div>
                        <div style="font-size: 16px; font-weight: bold; margin-bottom: 8px; color: #ccc;">Setlist Vaco</div>
                        <div style="font-size: 14px;">Selecciona un setlist para ver sus canciones</div>
                    </div>
                `;
                songList.appendChild(emptyState);
            } else {
                updatedSongs.forEach((song, index) => {
                    console.log(' Displaying song:', song.name, 'Artist:', song.artist, 'Full song data:', song);
                    
                    const songElement = document.createElement('div');
                    songElement.className = 'song-item';
                    songElement.onclick = () => loadSong(song.id);
                    songElement.innerHTML = `
                        <div class="song-number">${index + 1}</div>
                        <div class="song-info">
                            <div class="song-title">${song.name} ${song.onlinePlayback ? '' : ''}</div>
                            <div class="song-artist">${song.artist || 'Artista desconocido'}</div>
                            <div class="song-details">
                                <span class="song-tempo">${song.tempo ? song.tempo + ' BPM' : 'BPM N/A'}</span>
                                <span class="song-key">${song.key || 'Key N/A'}</span>
                                <span class="song-time-sig">${song.timeSignature || '4/4'}</span>
                            </div>
                        </div>
                        <div class="song-actions">
                            <div class="song-menu">
                                <button class="menu-btn" onclick="event.stopPropagation(); toggleSongMenu('${song.id}')" title="Opciones"></button>
                                <div class="menu-dropdown" id="menu-${song.id}" style="display: none;">
                                    <button class="menu-item" onclick="removeFromSetlist('${song.id}')" title="Eliminar del setlist"> Eliminar</button>
                                </div>
                            </div>
                        </div>
                    `;
                    songList.appendChild(songElement);
                });
            }
        }

        // Toggle song menu dropdown
        function toggleSongMenu(songId) {
            const menu = document.getElementById(`menu-${songId}`);
            if (menu) {
                // Close all other menus first
                document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                    if (dropdown.id !== `menu-${songId}`) {
                        dropdown.style.display = 'none';
                    }
                });
                
                // Toggle current menu
                menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
            }
        }
        
        // Close all menus when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.song-menu')) {
                document.querySelectorAll('.menu-dropdown').forEach(menu => {
                    menu.style.display = 'none';
                });
            }
        });
        
        // Load a specific song
        async function loadSong(songId) {
            try {
                console.log(' loadSong called with ID:', songId);
                
                // Check if song is already loaded and cached
                if (currentLoadedSongId === songId && songCache.has(songId)) {
                    console.log(' Song already loaded and cached, skipping reload:', songId);
                    return;
                }
                
                // Try to load from cache first
                if (songCache.has(songId)) {
                    console.log(' Loading song from cache:', songId);
                    if (loadFromCache(songId)) {
                        isLoadingSong = false;
                        return;
                    }
                }
                
                // Prevent multiple simultaneous loads
                if (isLoadingSong) {
                    console.log(' Song is already being loaded, ignoring request');
                    return;
                }
                
                isLoadingSong = true;
                
                // Pause progressive loading temporarily while user plays this song
                pauseProgressiveLoading();
                
                // Stop ALL audio completely before loading new song
                console.log(' Stopping ALL audio before loading new song...');
                
                // Stop all current audio sources
                audioSources.forEach((source, trackId) => {
                    try {
                        if (source && source.stop) {
                            source.stop();
                        }
                    } catch (e) {
                        // Ignore errors
                    }
                });
                
                // Clear everything INCLUDING audio buffers
                audioSources.clear();
                gainNodes.clear();
                tracks = [];
                audioBuffers.clear(); // THIS IS THE KEY - Clear audio buffers
                
                // Reset state
                isPlaying = false;
                currentTime = 0;
                pausedTime = 0;
                
                // Update UI
                const playBtn = document.getElementById('playBtn');
                if (playBtn) {
                    playBtn.textContent = '';
                    playBtn.classList.remove('active');
                }
                
                // Stop time update
                stopTimeUpdate();
                
                console.log(' ALL audio stopped and cleared');
                
                // Show small loading indicator (no modal)
                showSongLoadingIndicator(songId);
                
                // Ensure audio context is initialized
                if (!audioContext) {
                    console.log(' Initializing audio context before loading song...');
                    initAudioContext();
                }
                
                console.log(' Fetching song data from Firestore...');
                const songRef = window.firebase.doc(window.firebase.db, 'songs', songId);
                const songSnap = await window.firebase.getDoc(songRef);
                
                if (songSnap.exists()) {
                    const songData = songSnap.data();
                    console.log(' Song data retrieved:', songData);
                    console.log(' About to call loadSongTracks...');
                    await loadSongTracks(songData, false); // No modal for user clicks
                    console.log(` Cancin "${songData.name}" cargada con ${songData.tracks.length} tracks`);
                    
                    // Song loaded successfully, ready for playback
                    console.log(' Song loaded and ready for playback');
                    
                    // Display the loaded song in the interface
                    displaySongs([songData]);
                    
                    // Save user state (current setlist and song) to Firestore
                    if (currentSetlist) {
                        await saveUserState(currentSetlist, songData);
                    }
                    
                    // Cache the loaded song
                    cacheLoadedSong(songId, songData);
                } else {
                    console.error(' Song not found in Firestore');
                    alert('Cancin no encontrada');
                }
            } catch (error) {
                console.error(' Error in loadSong:', error);
                console.error(' Error message:', error.message);
                console.error(' Error stack:', error.stack);
                alert('Error al cargar la cancin: ' + error.message);
            } finally {
                isLoadingSong = false;
                console.log(' Hiding loading indicator for song:', songId);
                // Hide small loading indicator
                hideSongLoadingIndicator(songId);
                
                // Resume progressive loading after a short delay
                setTimeout(() => {
                    resumeProgressiveLoading();
                }, 2000); // 2 second delay to let the song start playing
            }
        }
        
        // Load song from setlist data (for auto-loading)
        async function loadSongFromSetlist(songData) {
            try {
                console.log(' Loading song from setlist:', songData.name);
                console.log(' Song data:', songData);
                
                // Stop current playback if playing (only if not auto-loading on startup)
                if (isPlaying && !document.hidden) {
                    console.log(' Stopping current playback before loading new song from setlist...');
                    isPlaying = false;
                    stopAllTracks();
                    stopTimeUpdate();
                    
                    // Update UI
                    const playBtn = document.getElementById('playBtn');
                    if (playBtn) {
                        playBtn.textContent = '';
                        playBtn.classList.remove('active');
                    }
                    
                    // Update progress bar
                    const progressBar = document.getElementById('progressBar');
                    if (progressBar) {
                        progressBar.classList.remove('playing');
                    }
                }
                
                // Use the same loading logic as loadSong but with setlist data
                if (!audioContext) {
                    console.log(' Initializing audio context before loading song...');
                    initAudioContext();
                }
                
                await loadSongTracks(songData);
                console.log(' Song loaded successfully from setlist');
            } catch (error) {
                console.error(' Error loading song from setlist:', error);
                console.error(' Error details:', error.message);
                console.error(' Error stack:', error.stack);
            }
        }
        
        // Update setlist display to show current setlist
        function updateSetlistDisplay() {
            if (currentSetlist) {
                console.log(' Updating setlist display for:', currentSetlist.name);
                
                // Update the setlist tab to show current setlist name
                const setlistTab = document.querySelector('.tab-btn[onclick="switchTab(\'setlist\')"]');
                if (setlistTab) {
                    setlistTab.textContent = ` ${currentSetlist.name}`;
                }
                
                // Also update the setlist header if it exists
                const setlistHeader = document.querySelector('.setlist-header');
                if (setlistHeader) {
                    const titleElement = setlistHeader.querySelector('h3');
                    if (titleElement) {
                        titleElement.textContent = currentSetlist.name;
                    }
                }
            }
        }

        // Initialize library event listeners
        function initLibrary() {
            // Category buttons
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentCategory = this.dataset.category;
                    loadLibraryItems();
                });
            });

            // Search functionality
            const searchInput = document.getElementById('librarySearch');
            if (searchInput) {
                searchInput.addEventListener('input', function() {
                    const searchTerm = this.value.toLowerCase();
                    const items = document.querySelectorAll('.library-item');
                    
                    items.forEach(item => {
                        const name = item.querySelector('.library-item-name').textContent.toLowerCase();
                        const details = item.querySelector('.library-item-details').textContent.toLowerCase();
                        
                        if (name.includes(searchTerm) || details.includes(searchTerm)) {
                            item.style.display = 'flex';
                        } else {
                            item.style.display = 'none';
                        }
                    });
                });
            }
        }

        // Handle auth form submission
        async function handleAuthSubmit(event) {
            event.preventDefault();
            hideAuthError(); // Clear any previous errors
            
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const displayName = document.getElementById('displayName').value;
            const isRegisterMode = document.getElementById('displayNameGroup').style.display !== 'none';
            
            try {
                let result;
                if (isRegisterMode) {
                    result = await registerUser(email, password, displayName);
                } else {
                    result = await signInUser(email, password);
                }
                
                if (result.success) {
                    hideAuthModal();
                    alert(isRegisterMode ? 'Registro exitoso!' : 'Inicio de sesin exitoso!');
                } else {
                    showAuthError(result.error);
                }
            } catch (error) {
                showAuthError('Error: ' + error.message);
            }
        }

        // Toggle between login and register mode
        function toggleAuthMode() {
            const title = document.getElementById('authTitle');
            const submitBtn = document.getElementById('authSubmit');
            const switchBtn = document.getElementById('authSwitch');
            const displayNameGroup = document.getElementById('displayNameGroup');
            
            const isRegisterMode = displayNameGroup.style.display !== 'none';
            
            if (isRegisterMode) {
                // Switch to login mode
                title.textContent = 'Iniciar Sesin';
                submitBtn.textContent = 'Iniciar Sesin';
                switchBtn.textContent = 'No tienes cuenta? Crear una';
                displayNameGroup.style.display = 'none';
            } else {
                // Switch to register mode
                title.textContent = 'Crear Cuenta';
                submitBtn.textContent = 'Crear Cuenta';
                switchBtn.textContent = 'Ya tienes cuenta? Iniciar sesin';
                displayNameGroup.style.display = 'flex';
            }
            
            hideAuthError();
        }
        
        // Transport Controls
        function togglePlay() {
            console.log(' Toggle play called - current state:', isPlaying);
            isPlaying = !isPlaying;
            const playBtn = document.getElementById('playBtn');
            playBtn.textContent = isPlaying ? '' : '';
            playBtn.classList.toggle('active', isPlaying);
            
            if (isPlaying) {
                console.log(' Starting playback...');
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                audioStartTime = audioContext.currentTime;
                playAllTracks();
                startTimeUpdate();
                startVUMeters(); // Start VU meters
                
                // Update progress bar to show it's not seekable during playback
                const progressBar = document.getElementById('progressBar');
                progressBar.classList.add('playing');
            } else {
                console.log(' Pausing playback...');
                pausedTime = currentTime;
                stopAllTracks();
                stopTimeUpdate();
                stopVUMeters(); // Stop VU meters
                
                // Update progress bar to show it's seekable when paused
                const progressBar = document.getElementById('progressBar');
                progressBar.classList.remove('playing');
            }
        }
        
        function stopPlayback() {
            // Stop all tracks
            stopAllTracks();
            
            // Reset playback state
            isPlaying = false;
            currentTime = 0;
            pausedTime = 0;
            
            // Update UI
            const playBtn = document.getElementById('playBtn');
            if (playBtn) {
                playBtn.textContent = '';
                playBtn.classList.remove('active');
            }
            
            // Update progress bar to show it's seekable when stopped
            const progressBar = document.getElementById('progressBar');
            if (progressBar) {
                progressBar.classList.remove('playing');
            }
            
            // Stop time update
            stopTimeUpdate();
            
            // Update time display and progress bar
            updateTimeDisplay();
            updateProgressBar();
            
            console.log(' Playback stopped and reset');
        }
        
        function toggleLoop() {
            isLooping = !isLooping;
            const loopBtn = document.querySelector('.transport-btn[onclick="toggleLoop()"]');
            loopBtn.classList.toggle('active', isLooping);
            
            console.log(` Loop ${isLooping ? 'enabled' : 'disabled'}`);
        }
        
        function updateMasterVolume(value) {
            masterVolume = value / 100; // Convert percentage to 0.0-1.0 range
            document.getElementById('masterVolumeValue').textContent = value + '%';
            
            // Update all track volumes based on current states
            updateTrackVolumes();
            
            console.log(` Master volume updated to ${value}%`);
        }
        
        function hotReload() {
            console.log(' Hot reload initiated...');
            
            // Stop all audio to prevent issues
            if (isPlaying) {
                stopPlayback();
            }
            
            // Save current state to localStorage if needed
            if (currentUser) {
                localStorage.setItem('lastUser', JSON.stringify({
                    uid: currentUser.uid,
                    email: currentUser.email,
                    displayName: currentUser.displayName
                }));
            }
            
            // Show loading message
            const button = event.target;
            const originalText = button.innerHTML;
            button.innerHTML = '';
            button.disabled = true;
            
            // Reload after a short delay
            setTimeout(() => {
                window.location.reload();
            }, 500);
        }
        
        function increaseBPM() {
            if (currentBPM < 200) { // Mximo 200 BPM
                currentBPM += 1;
                tempoMultiplier = currentBPM / originalBPM;
                updateBPMDisplay();
                applyTempoChange();
                console.log(` BPM increased to ${currentBPM} (${Math.round(tempoMultiplier * 100)}%)`);
            }
        }
        
        function decreaseBPM() {
            if (currentBPM > 60) { // Mnimo 60 BPM
                currentBPM -= 1;
                tempoMultiplier = currentBPM / originalBPM;
                updateBPMDisplay();
                applyTempoChange();
                console.log(` BPM decreased to ${currentBPM} (${Math.round(tempoMultiplier * 100)}%)`);
            }
        }
        
        function resetBPM() {
            currentBPM = originalBPM;
            tempoMultiplier = 1.0;
            updateBPMDisplay();
            applyTempoChange();
            console.log(` BPM reset to original: ${originalBPM}`);
        }
        
        function updateBPMDisplay() {
            document.getElementById('bpmDisplay').textContent = currentBPM + ' BPM';
        }
        
        function applyTempoChange() {
            // Aplicar cambio de tempo a todos los tracks activos
            if (audioContext && tracks.length > 0) {
                tracks.forEach(track => {
                    if (track.audioUrl && audioSources.has(track.id)) {
                        const source = audioSources.get(track.id);
                        if (source && source.playbackRate !== undefined) {
                            // Solo aplicar tempo, mantener pitch original
                            source.playbackRate.value = tempoMultiplier;
                            console.log(` Applied tempo change to track ${track.id}: ${tempoMultiplier}x (pitch unchanged)`);
                        }
                    }
                });
                
                // Re-aplicar pitch changes para mantener la separacin
                applyPitchChange();
            }
        }
        
        function setOriginalBPM(bpm) {
            originalBPM = bpm;
            currentBPM = bpm;
            tempoMultiplier = 1.0;
            updateBPMDisplay();
            console.log(` Original BPM set to ${bpm}`);
        }
        
        function setOriginalKey(key) {
            originalKey = key || 'C';
            currentKey = originalKey;
            keyOffset = 0;
            updateKeyDisplay();
            console.log(` Original Key set to ${originalKey}`);
        }
        
        function updateKeyDisplay() {
            document.getElementById('keyDisplay').textContent = currentKey;
        }
        
        function increaseKey() {
            console.log(' increaseKey() called, current keyOffset:', keyOffset);
            if (keyOffset < 12) { // Mximo +12 semitonos (1 octava)
                keyOffset += 1;
                currentKey = getKeyFromOffset(originalKey, keyOffset);
                updateKeyDisplay();
                applyPitchChange();
                console.log(` Key increased to ${currentKey} (+${keyOffset} semitones)`);
            } else {
                console.log(' Key already at maximum (+12 semitones)');
            }
        }
        
        function decreaseKey() {
            console.log(' decreaseKey() called, current keyOffset:', keyOffset);
            if (keyOffset > -12) { // Mnimo -12 semitonos (1 octava)
                keyOffset -= 1;
                currentKey = getKeyFromOffset(originalKey, keyOffset);
                updateKeyDisplay();
                applyPitchChange();
                console.log(` Key decreased to ${currentKey} (${keyOffset} semitones)`);
            } else {
                console.log(' Key already at minimum (-12 semitones)');
            }
        }
        
        function resetKey() {
            keyOffset = 0;
            currentKey = originalKey;
            updateKeyDisplay();
            applyPitchChange();
            console.log(` Key reset to original: ${originalKey}`);
        }
        
        function getKeyFromOffset(baseKey, offset) {
            const keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const baseIndex = keys.indexOf(baseKey);
            if (baseIndex === -1) return baseKey;
            
            let newIndex = (baseIndex + offset) % 12;
            if (newIndex < 0) newIndex += 12;
            
            return keys[newIndex];
        }
        
        function applyPitchChange() {
            console.log(' applyPitchChange() called');
            console.log(' audioContext:', !!audioContext);
            console.log(' tracks.length:', tracks.length);
            console.log(' audioSources.size:', audioSources.size);
            console.log(' keyOffset:', keyOffset);
            console.log(' toneInitialized:', toneInitialized);
            
            // Aplicar cambio de pitch a todos los tracks activos
            if (audioContext && tracks.length > 0) {
                let appliedCount = 0;
                tracks.forEach(track => {
                    console.log(` Processing track ${track.id}:`, {
                        hasAudioUrl: !!track.audioUrl,
                        hasSource: audioSources.has(track.id),
                        trackName: track.name
                    });
                    
                    if (track.audioUrl && audioSources.has(track.id)) {
                        const source = audioSources.get(track.id);
                        if (source) {
                            // Usar Tone.js pitch shifter si est disponible
                            if (source.pitchShift && typeof Tone !== 'undefined') {
                                // Aplicar pitch change usando Tone.js (NO afecta tempo)
                                source.pitchShift.pitch = keyOffset;
                                // Asegurar que el tempo se mantenga
                                source.playbackRate.value = tempoMultiplier;
                                console.log(` Applied Tone.js pitch shift to track ${track.id}: ${keyOffset} semitones (tempo: ${tempoMultiplier}x)`);
                            } else {
                                // Fallback: usar playbackRate (afecta tempo y pitch)
                                const pitchRatio = Math.pow(2, keyOffset / 12);
                                if (keyOffset !== 0) {
                                    const combinedRate = tempoMultiplier * pitchRatio;
                                    source.playbackRate.value = combinedRate;
                                    console.log(` Applied fallback pitch change to track ${track.id}: ${combinedRate.toFixed(3)}x (tempo: ${tempoMultiplier}x, pitch: ${pitchRatio.toFixed(3)}x)`);
                                } else {
                                    source.playbackRate.value = tempoMultiplier;
                                    console.log(` Reset pitch for track ${track.id}, tempo: ${tempoMultiplier}x`);
                                }
                            }
                            appliedCount++;
                        }
                    }
                });
                
                if (appliedCount === 0) {
                    console.log(' No active audio sources found to apply pitch change');
                    console.log(' Make sure audio is playing to hear pitch changes');
                } else {
                    console.log(` Applied pitch change to ${appliedCount} tracks`);
                }
            } else {
                console.log(` Audio context not available or no tracks loaded`);
                console.log(' Load a song and start playback to test pitch changes');
            }
        }
        
        
        
        function rewind() {
            seekToTime(0);
        }
        
        // VU Meter functions
        function startVUMeters() {
            if (vuMeterInterval) {
                clearInterval(vuMeterInterval);
            }
            
            vuMeterInterval = setInterval(updateVUMeters, 50); // Update every 50ms
            console.log(' VU meters started');
        }
        
        function stopVUMeters() {
            if (vuMeterInterval) {
                clearInterval(vuMeterInterval);
                vuMeterInterval = null;
            }
            
            // Reset all VU meters to 0
            tracks.forEach(track => {
                const vuBar = document.getElementById(`vu-meter-${track.id}`)?.querySelector('.vu-bar');
                if (vuBar) {
                    vuBar.style.height = '0%';
                }
            });
            
            console.log(' VU meters stopped');
        }
        
        function updateVUMeters() {
            if (!audioContext || analysers.size === 0) return;
            
            analysers.forEach((analyser, trackId) => {
                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                analyser.getByteFrequencyData(dataArray);
                
                // Calculate RMS (Root Mean Square) for better VU meter representation
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    sum += dataArray[i] * dataArray[i];
                }
                const rms = Math.sqrt(sum / dataArray.length);
                
                // Convert to percentage (0-100%)
                const percentage = Math.min((rms / 128) * 100, 100);
                
                // Update VU meter display
                const vuBar = document.getElementById(`vu-meter-${trackId}`)?.querySelector('.vu-bar');
                if (vuBar) {
                    vuBar.style.height = `${percentage}%`;
                }
            });
        }
        
        // Song cache functions
        function cacheLoadedSong(songId, songData) {
            console.log(' Caching loaded song:', songId, songData.name);
            
            // Create a deep copy of the current state
            const cachedSong = {
                songData: JSON.parse(JSON.stringify(songData)),
                tracks: JSON.parse(JSON.stringify(tracks)),
                audioBuffers: new Map(audioBuffers),
                loadedAt: Date.now()
            };
            
            // Store in cache
            songCache.set(songId, cachedSong);
            currentLoadedSongId = songId;
            
            console.log(' Song cached successfully:', songId);
            console.log(' Cache size:', songCache.size, 'songs');
        }
        
        function loadFromCache(songId) {
            if (!songCache.has(songId)) {
                console.log(' Song not found in cache:', songId);
                return false;
            }
            
            console.log(' Loading song from cache:', songId);
            const cachedSong = songCache.get(songId);
            
            // Restore the cached state
            tracks.length = 0; // Clear current tracks
            tracks.push(...cachedSong.tracks);
            
            // Clear and restore audio buffers
            audioBuffers.clear();
            cachedSong.audioBuffers.forEach((buffer, trackId) => {
                audioBuffers.set(trackId, buffer);
            });
            
            currentLoadedSongId = songId;
            
            // Update the UI
            updateTracksGrid();
            displaySongs([cachedSong.songData]);
            
            console.log(' Song loaded from cache:', songId);
            return true;
        }
        
        function clearSongCache() {
            console.log(' Clearing song cache');
            songCache.clear();
            currentLoadedSongId = null;
        }
        
        function fastForward() {
            seekToTime(totalTime);
        }
        
        function toggleLoop() {
            // Loop functionality
            console.log('Loop toggled');
        }
        
        function record() {
            // Record functionality
            console.log('Recording...');
        }
        
        function openSettings() {
            alert(' Configuracin\n\n Audio Settings\n MIDI Settings\n Display Settings\n Export Settings');
        }
        
        // Time Management
        function startTimeUpdate() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
            }
            
            timeUpdateInterval = setInterval(() => {
                if (isPlaying && totalTime > 0) {
                    // Calculate current time based on audio context time
                    // When resuming from seek, we need to account for the offset
                    const elapsed = audioContext.currentTime - audioStartTime;
                    currentTime = Math.min(elapsed + pausedTime, totalTime);
                    
                    // Debug logging every 5 seconds
                    if (Math.floor(currentTime) % 5 === 0 && Math.floor(currentTime) !== Math.floor(currentTime - 0.1)) {
                        console.log(' Time Debug:', {
                            currentTime: currentTime.toFixed(2),
                            totalTime: totalTime.toFixed(2),
                            audioContextTime: audioContext.currentTime.toFixed(2),
                            audioStartTime: audioStartTime.toFixed(2),
                            pausedTime: pausedTime.toFixed(2),
                            elapsed: elapsed.toFixed(2)
                        });
                    }
                    
                    if (currentTime >= totalTime) {
                        console.log(' Song finished - stopping playback');
                        console.log(' Current time:', currentTime.toFixed(2), 'Total time:', totalTime.toFixed(2));
                        currentTime = totalTime;
                        
                        // Only stop if not looping
                        if (!isLooping) {
                            stopAllTracks();
                            isPlaying = false;
                            document.getElementById('playBtn').textContent = '';
                            document.getElementById('playBtn').classList.remove('active');
                            
                            // Update progress bar to show it's seekable when stopped
                            const progressBar = document.getElementById('progressBar');
                            progressBar.classList.remove('playing');
                            
                            stopTimeUpdate();
                        } else {
                            console.log(' Loop enabled - restarting from beginning');
                            currentTime = 0;
                            pausedTime = 0;
                            audioStartTime = audioContext.currentTime;
                            playAllTracks();
                        }
                    }
                    
                    updateTimeDisplay();
                    updateProgressBar();
                }
            }, 100);
        }
        
        function stopTimeUpdate() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
                timeUpdateInterval = null;
            }
        }
        
        function updateTimeDisplay() {
            const currentTimeStr = formatTime(currentTime);
            const totalTimeStr = formatTime(totalTime);
            document.getElementById('currentTime').textContent = currentTimeStr;
            document.getElementById('totalTime').textContent = totalTimeStr;
        }
        
        function updateProgressBar() {
            if (totalTime > 0) {
                const progress = (currentTime / totalTime) * 100;
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('progressThumb').style.left = progress + '%';
            }
        }
        
        function seekToTime(seekTime) {
            if (totalTime > 0) {
                currentTime = Math.max(0, Math.min(seekTime, totalTime));
                pausedTime = currentTime;
                
                // Only update display - no restart during playback
                // Seeking during playback is now blocked in handleProgressBarClick
                updateTimeDisplay();
                updateProgressBar();
                
                console.log(' Seeked to:', currentTime.toFixed(2), 'seconds (paused only)');
            }
        }
        
        function handleProgressBarClick(event) {
            if (totalTime > 0) {
                // Only allow seeking when not playing
                if (isPlaying) {
                    console.log(' Cannot seek while playing - pause first');
                    return;
                }
                
                const progressBar = document.getElementById('progressBar');
                const rect = progressBar.getBoundingClientRect();
                const clickX = event.clientX - rect.left;
                const percentage = clickX / rect.width;
                const seekTime = percentage * totalTime;
                
                console.log(' Seeking to:', seekTime, 'seconds (paused)');
                seekToTime(seekTime);
            }
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Track Management
        function generateTracks() {
            // No tracks until a song is loaded
            tracks = [];
            updateTracksGrid();
        }
        
        function updateTracksGrid() {
            const tracksGrid = document.getElementById('tracksGrid');
            tracksGrid.innerHTML = '';
            
            if (tracks.length === 0) {
                // Show empty state message
                const emptyState = document.createElement('div');
                emptyState.className = 'empty-mixer-state';
                emptyState.style.cssText = `
                    grid-column: 1 / -1;
                    text-align: center;
                    padding: 60px 20px;
                    color: #888;
                `;
                emptyState.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 16px;"></div>
                    <div style="font-size: 16px; font-weight: bold; margin-bottom: 8px; color: #ccc;">Mixer Vaco</div>
                    <div style="font-size: 14px;">Carga una cancin para ver los tracks del mixer</div>
                `;
                tracksGrid.appendChild(emptyState);
            } else {
                // Sort tracks: click/cue tracks first, then others
                const sortedTracks = [...tracks].sort((a, b) => {
                    const aName = typeof a.name === 'string' ? a.name : (a.name?.name || `Track ${a.id}`);
                    const bName = typeof b.name === 'string' ? b.name : (b.name?.name || `Track ${b.id}`);
                    
                    const aIsClickCue = isClickOrCueTrack(aName);
                    const bIsClickCue = isClickOrCueTrack(bName);
                    
                    // Click/cue tracks come first
                    if (aIsClickCue && !bIsClickCue) return -1;
                    if (!aIsClickCue && bIsClickCue) return 1;
                    
                    // If both are click/cue or both are regular, maintain original order
                    return 0;
                });
                
                sortedTracks.forEach(track => {
                    const trackChannel = document.createElement('div');
                    trackChannel.className = 'track-channel';
                    
                    const volumePercent = Math.round(track.volume * 100);
                    const faderHeight = track.volume * 100;
                    
                    // Ensure track name is a string
                    const trackName = typeof track.name === 'string' ? track.name : (track.name?.name || `Track ${track.id}`);
                    
                    // Check if this is a click/cue track
                    const isClickCue = isClickOrCueTrack(trackName);
                    
                    // Add click-cue class to track channel if it's a click/cue track
                    if (isClickCue) {
                        trackChannel.classList.add('click-cue');
                    }
                    
                    // Check if track has audio buffer loaded
                    const hasBuffer = audioBuffers.has(track.id);
                    
                    trackChannel.innerHTML = `
                        <div class="track-name ${track.muted ? 'muted' : ''} ${track.solo ? 'solo' : ''} ${isClickCue ? 'click-cue' : ''}" title="${trackName}">
                            <div class="track-name-text">${trackName}</div>
                        </div>
                        <div class="track-status">
                            <div class="track-led ${hasBuffer ? 'led-on' : 'led-off'}"></div>
                        </div>
                        <div class="fader-container">
                            <div class="fader-track">
                                <div class="fader-thumb" style="bottom: ${faderHeight}%;" 
                                     onmousedown="startFaderDrag(${track.id}, event)"></div>
                                <div class="fader-level" style="height: ${faderHeight}%;"></div>
                            </div>
                        </div>
                        <div class="vu-meter-container">
                            <div class="vu-meter" id="vu-meter-${track.id}">
                                <div class="vu-bar" style="height: 0%;"></div>
                            </div>
                        </div>
                    <div class="track-controls">
                            <button class="track-control-btn mute-btn ${track.muted ? 'active' : ''}" 
                                    onclick="toggleMute(${track.id})" title="Mute ${trackName}">M</button>
                            <button class="track-control-btn solo-btn ${track.solo ? 'active' : ''}" 
                                    onclick="toggleSolo(${track.id})" title="Solo ${trackName}">S</button>
                    </div>
                `;
                    
                    tracksGrid.appendChild(trackChannel);
            });
            }
        }
        
        function startFaderDrag(trackId, event) {
            const track = tracks.find(t => t.id === trackId);
            if (!track) return;
            
            const faderTrack = event.target.parentElement;
            const rect = faderTrack.getBoundingClientRect();
            
            function updateFader(e) {
                const y = e.clientY - rect.top;
                const percentage = Math.max(0, Math.min(100, 100 - (y / rect.height) * 100));
                track.volume = percentage / 100;
                
                const thumb = faderTrack.querySelector('.fader-thumb');
                const level = faderTrack.querySelector('.fader-level');
                thumb.style.bottom = percentage + '%';
                level.style.height = percentage + '%';
                
                // Update audio volume
                setTrackVolume(trackId, track.volume);
            }
            
            function stopDrag() {
                document.removeEventListener('mousemove', updateFader);
                document.removeEventListener('mouseup', stopDrag);
            }
            
            document.addEventListener('mousemove', updateFader);
            document.addEventListener('mouseup', stopDrag);
        }
        
        function toggleMute(trackId) {
            const track = tracks.find(t => t.id === trackId);
            if (track) {
                track.muted = !track.muted;
                
                // Update all tracks based on mute and solo states
                updateTrackVolumes();
                
                const mutedTracks = tracks.filter(t => t.muted);
                console.log(` Mute ${track.muted ? 'ON' : 'OFF'} for track ${trackId} (${track.name})`);
                console.log(` Total muted tracks: ${mutedTracks.length}`);
                
                updateTracksGrid();
            }
        }
        
        function toggleSolo(trackId) {
            const track = tracks.find(t => t.id === trackId);
            if (track) {
                track.solo = !track.solo;
                
                // Update all tracks based on solo states
                updateTrackVolumes();
                
                const soloTracks = tracks.filter(t => t.solo);
                console.log(` Solo ${track.solo ? 'ON' : 'OFF'} for track ${trackId} (${track.name})`);
                console.log(` Total solo tracks: ${soloTracks.length}`);
                
                updateTracksGrid();
            }
        }
        
        // New function to update all track volumes based on solo and mute states
        function updateTrackVolumes() {
            const soloTracks = tracks.filter(t => t.solo);
            const hasSoloTracks = soloTracks.length > 0;
            
            tracks.forEach(track => {
                const gainNode = gainNodes.get(track.id);
                if (gainNode) {
                    let shouldPlay = true;
                    
                    // If there are solo tracks, only solo tracks should play
                    if (hasSoloTracks && !track.solo) {
                        shouldPlay = false;
                    }
                    
                    // If track is muted, it shouldn't play
                    if (track.muted) {
                        shouldPlay = false;
                    }
                    
                    if (shouldPlay) {
                        // Play track with original volume
                        const originalVolume = track.volume || 0.8;
                        gainNode.gain.value = originalVolume * masterVolume;
            } else {
                        // Mute track
                        gainNode.gain.value = 0;
                    }
                }
            });
        }
        
        
        // Song Management
        function generateSongs() {
            // Empty setlist - ready for real content
            const songs = [];
            
            const songList = document.getElementById('songList');
            if (songList) {
                songList.innerHTML = '';
            }
            
            if (songs.length === 0) {
                // Show empty state message
                const emptyState = document.createElement('div');
                emptyState.className = 'empty-setlist-state';
                emptyState.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: #888;">
                        <div style="font-size: 48px; margin-bottom: 16px;"></div>
                        <div style="font-size: 16px; font-weight: bold; margin-bottom: 8px; color: #ccc;">Setlist Vaco</div>
                        <div style="font-size: 14px;">Agrega canciones desde la biblioteca para crear tu setlist</div>
                    </div>
                `;
                if (songList) {
                    songList.appendChild(emptyState);
                }
            } else {
                songs.forEach(song => {
                    const songItem = document.createElement('div');
                    songItem.className = 'song-item';
                    songItem.innerHTML = `
                        <div class="song-number">${song.number}</div>
                        <div class="song-cover"></div>
                        <div class="song-info">
                            <div class="song-title">${song.title}</div>
                            <div class="song-artist">${song.artist}</div>
                        </div>
                        <div class="song-key">${song.key}</div>
                        <div class="song-bpm">${song.bpm}</div>
                        <div style="font-size: 12px;"></div>
                    `;
                    if (songList) {
                        songList.appendChild(songItem);
                    }
                });
            }
        }
        
        // Pad Management
        function generatePads() {
            const padNotes = ['Db', 'Eb', 'Gb', 'Ab', 'Bb', 'B', 'C', 'D', 'E', 'F', 'G', 'A'];
            const padsGrid = document.getElementById('padsGrid');
            
            if (padsGrid) {
                padsGrid.innerHTML = '';
                
                padNotes.forEach(note => {
                    const padBtn = document.createElement('button');
                    padBtn.className = 'pad-btn';
                    padBtn.textContent = note;
                    padBtn.onclick = () => togglePad(note);
                    padsGrid.appendChild(padBtn);
                });
            }
        }
        
        function togglePad(note) {
            const pad = event.target;
            pad.classList.toggle('active');
            console.log(`Pad ${note} ${pad.classList.contains('active') ? 'activated' : 'deactivated'}`);
        }
        
        // Initialize Web Audio API
        function initAudioContext() {
            try {
                // Create audio context if it doesn't exist
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log(' Audio context initialized');
                    console.log(' Audio context state:', audioContext.state);
                    console.log(' Audio context sample rate:', audioContext.sampleRate);
                } else {
                    console.log(' Audio context already exists, state:', audioContext.state);
                }
                
                // Initialize Tone.js if available
                initToneJS();
            } catch (error) {
                console.error(' Failed to initialize audio context:', error);
                audioContext = null;
            }
        }
        
        async function initToneJS() {
            if (typeof Tone !== 'undefined' && !toneInitialized) {
                try {
                    console.log(' Initializing Tone.js...');
                    await Tone.start();
                    toneInitialized = true;
                    console.log(' Tone.js initialized successfully');
                } catch (error) {
                    console.warn(' Could not initialize Tone.js:', error);
                    toneInitialized = false;
                }
            } else if (typeof Tone === 'undefined') {
                console.warn(' Tone.js library not loaded');
            }
        }

        // Load audio file from URL with browser cache
        async function loadAudioFile(url, trackId) {
            try {
                console.log(' Loading audio file:', url);
                console.log(' Track ID:', trackId);
                console.log(' Audio context state:', audioContext ? audioContext.state : 'Not initialized');
                
                // Ensure audio context is initialized
                if (!audioContext) {
                    console.log(' Audio context not initialized, initializing now...');
                    initAudioContext();
                }
                
                if (!audioContext) {
                    throw new Error('Failed to initialize audio context');
                }
                
                // Resume audio context if suspended (required for user interaction)
                if (audioContext.state === 'suspended') {
                    console.log(' Audio context suspended, resuming...');
                    await audioContext.resume();
                }
                
                // Check if audio buffer is already cached
                const cachedBuffer = audioBuffers.get(trackId);
                
                if (cachedBuffer) {
                    console.log(' Using cached audio buffer for track:', trackId);
                    console.log(' Cache hit! Buffer duration:', cachedBuffer.duration, 'seconds');
                    return cachedBuffer;
                }
                
                console.log(' Cache miss for track:', trackId, '- loading from URL');
                
                console.log(' Fetching audio file from URL...');
                const response = await fetch(url, {
                    cache: 'force-cache' // Use browser cache
                });
                console.log(' Fetch response status:', response.status);
                console.log(' Fetch response headers:', response.headers);
                console.log(' Response URL:', response.url);
                console.log(' Response type:', response.type);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                console.log(' Converting response to ArrayBuffer...');
                const arrayBuffer = await response.arrayBuffer();
                console.log(' ArrayBuffer size:', arrayBuffer.byteLength, 'bytes');
                console.log(' ArrayBuffer size in MB:', (arrayBuffer.byteLength / 1024 / 1024).toFixed(2), 'MB');
                
                if (arrayBuffer.byteLength === 0) {
                    throw new Error('Empty audio file received');
                }
                
                // Check if file is too small (likely corrupted)
                if (arrayBuffer.byteLength < 1000) {
                    throw new Error(`File too small (${arrayBuffer.byteLength} bytes) - likely corrupted or incomplete upload`);
                }
                
                // Log first few bytes to check file format
                const uint8Array = new Uint8Array(arrayBuffer.slice(0, 16));
                console.log(' First 16 bytes (hex):', Array.from(uint8Array).map(b => b.toString(16).padStart(2, '0')).join(' '));
                console.log(' First 16 bytes (ascii):', Array.from(uint8Array).map(b => String.fromCharCode(b)).join(''));
                
                console.log(' Decoding audio data...');
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                console.log(' AudioBuffer duration:', audioBuffer.duration, 'seconds');
                console.log(' AudioBuffer sample rate:', audioBuffer.sampleRate);
                console.log(' AudioBuffer channels:', audioBuffer.numberOfChannels);
                
                console.log(' Storing audio buffer for track:', trackId);
                audioBuffers.set(trackId, audioBuffer);
                console.log(' Audio buffer stored successfully. Map size:', audioBuffers.size);
                console.log(' Verifying buffer was stored:', audioBuffers.has(trackId));
                console.log(' Audio loaded for track:', trackId);
                
                return audioBuffer;
            } catch (error) {
                console.error(' Failed to load audio:', error);
                console.error(' Error message:', error.message);
                console.error(' Error stack:', error.stack);
                console.error(' URL was:', url);
                console.error(' Track ID:', trackId);
                return null;
            }
        }

        // Play audio track
        function playTrack(trackId) {
            // Use current time for individual track playback
            playTrackSync(trackId, audioContext.currentTime);
        }
        
        function playTrackSync(trackId, startTime, offsetTime = 0) {
            try {
                console.log(' Attempting to play track:', trackId, 'at time:', startTime.toFixed(3), 'with offset:', offsetTime.toFixed(3));
                
                if (!audioContext) {
                    console.error(' Audio context not initialized');
                    return;
                }

                // Resume audio context if suspended (required by browsers)
                if (audioContext.state === 'suspended') {
                    console.log(' Resuming audio context...');
                    audioContext.resume();
                }

                const audioBuffer = audioBuffers.get(trackId);
                if (!audioBuffer) {
                    console.error(' Audio buffer not found for track:', trackId);
                    console.error(' Available buffers:', Array.from(audioBuffers.keys()));
                    return;
                }

                console.log(' Audio buffer found, duration:', audioBuffer.duration);

                // Stop existing source if playing
                stopTrack(trackId);

                // Create new source
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;

                // Create gain node for volume control
                const gainNode = audioContext.createGain();
                
                // Create analyser node for VU meter
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                analyser.smoothingTimeConstant = 0.8;
                
                // Get track volume (default to 0.8 if not set) and apply master volume
                const track = tracks.find(t => t.id === trackId);
                const trackVolume = track && track.volume !== undefined ? track.volume : 0.8;
                const finalVolume = trackVolume * masterVolume;
                gainNode.gain.value = finalVolume;
                console.log(' Setting track volume to:', trackVolume, 'x master:', masterVolume, '= final:', finalVolume);

                // Create pitch shifter using Tone.js if available
                let pitchShiftNode = null;
                if (typeof Tone !== 'undefined' && toneInitialized) {
                    try {
                        // Create a Tone.js pitch shifter
                        pitchShiftNode = new Tone.PitchShift({
                            pitch: keyOffset,
                            windowSize: 0.1,
                            overlap: 0.5
                        });
                        
                        // Connect the audio chain: source -> pitchShift -> gain -> analyser -> destination
                        source.connect(pitchShiftNode.input);
                        pitchShiftNode.connect(gainNode);
                        gainNode.connect(analyser);
                        
                        console.log(' Created Tone.js pitch shifter for track:', trackId, 'with pitch:', keyOffset);
                    } catch (error) {
                        console.warn(' Could not create Tone.js pitch shifter:', error);
                        // Fallback to direct connection
                        source.connect(gainNode);
                        gainNode.connect(analyser);
                    }
                } else {
                    // Fallback: direct connection without pitch shifting
                    source.connect(gainNode);
                    gainNode.connect(analyser);
                }

                // Connect to destination
                analyser.connect(audioContext.destination);

                // Store references
                audioSources.set(trackId, source);
                gainNodes.set(trackId, gainNode);
                analysers.set(trackId, analyser);
                if (pitchShiftNode) {
                    // Store pitch shifter reference for later updates
                    source.pitchShift = pitchShiftNode;
                }

                // Add event listener to detect when source ends
                source.onended = () => {
                    console.log(' Track ended:', trackId, track.name);
                    // Remove from active sources
                    audioSources.delete(trackId);
                    gainNodes.delete(trackId);
                    
                    // Update track playing state
                    const track = tracks.find(t => t.id === trackId);
                    if (track) {
                        track.playing = false;
                    }
                };

                // Start playback at the specified time with offset
                if (offsetTime > 0) {
                    source.start(startTime, offsetTime);
                    console.log(' Playing track:', trackId, 'at time:', startTime.toFixed(3), 'from offset:', offsetTime.toFixed(3));
                } else {
                    source.start(startTime);
                    console.log(' Playing track:', trackId, 'at time:', startTime.toFixed(3), 'from beginning');
                }
                console.log(' Audio context state:', audioContext.state);

                // Update track playing state
                if (track) {
                    track.playing = true;
                }

            } catch (error) {
                console.error(' Failed to play track:', error);
            }
        }

        // Stop audio track
        function stopTrack(trackId) {
            const source = audioSources.get(trackId);
            if (source) {
                try {
                    source.stop();
                } catch (error) {
                    // Source might already be stopped
                }
                audioSources.delete(trackId);
                console.log(' Stopped track:', trackId);
            }
            
            // Update track playing state
            const track = tracks.find(t => t.id === trackId);
            if (track) {
                track.playing = false;
            }
        }

        // Set track volume
        function setTrackVolume(trackId, volume) {
            const track = tracks.find(t => t.id === trackId);
            if (track) {
                // Update the track's volume property
                track.volume = volume;
                
                // Update all track volumes based on current states
                updateTrackVolumes();
                
                console.log(' Volume set for track:', trackId, 'to', volume);
            }
        }

        // Play all tracks
        function playAllTracks() {
            console.log(' Playing all tracks - called at time:', audioContext.currentTime.toFixed(3));
            console.log(' Current playback state:', isPlaying);
            console.log(' Available tracks:', tracks.length);
            console.log(' Track details:', tracks.map(t => `${t.id}: ${t.name} (muted: ${t.muted}, hasUrl: ${!!t.audioUrl})`));
            console.log(' Active sources:', audioSources.size);
            console.log(' Paused time (seek position):', pausedTime.toFixed(3));
            
            // Check if tracks are already playing to avoid restarting
            const alreadyPlaying = Array.from(audioSources.keys()).length > 0;
            if (alreadyPlaying && isPlaying) {
                console.log(' Tracks already playing - skipping restart');
                return;
            }
            
            // Calculate a common start time for all tracks to ensure perfect sync
            const commonStartTime = audioContext.currentTime + 0.1; // Small delay to ensure all tracks start together
            
            tracks.forEach(track => {
                if (track.audioUrl && !track.muted) {
                    console.log(' Starting track:', track.id, track.name);
                    // Use pausedTime as offset if we're resuming from a seek position
                    playTrackSync(track.id, commonStartTime, pausedTime);
                } else {
                    console.log(' Skipping track:', track.id, track.name, '- muted:', track.muted, 'hasUrl:', !!track.audioUrl);
                }
            });
        }

        // Stop all tracks
        function stopAllTracks() {
            console.log(' Stopping all tracks');
            tracks.forEach(track => {
                stopTrack(track.id);
            });
        }

        // Test audio with a simple tone
        function testAudio() {
            try {
                console.log(' Testing audio with simple tone...');
                
                if (!audioContext) {
                    console.error(' Audio context not initialized');
                    return;
                }
                
                // Resume audio context if suspended
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                // Create oscillator for test tone
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Set frequency and volume
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4 note
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime); // Moderate volume
                
                // Play for 1 second
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 1);
                
                console.log(' Test tone played for 1 second');
                
            } catch (error) {
                console.error(' Test audio failed:', error);
            }
        }

        // Test volume levels
        function testVolumeLevels() {
            try {
                console.log(' Testing volume levels...');
                
                if (!audioContext) {
                    console.error(' Audio context not initialized');
                    return;
                }
                
                // Resume audio context if suspended
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                // Test different volume levels
                const volumes = [0.1, 0.3, 0.5, 0.8, 1.0];
                let currentIndex = 0;
                
                function playNextVolume() {
                    if (currentIndex >= volumes.length) {
                        console.log(' Volume test completed');
                        return;
                    }
                    
                    const volume = volumes[currentIndex];
                    console.log(` Testing volume: ${volume}`);
                    
                    // Create oscillator
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Set frequency and volume
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
                    
                    // Play for 0.5 seconds
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.5);
                    
                    currentIndex++;
                    setTimeout(playNextVolume, 600); // Wait 600ms between tests
                }
                
                playNextVolume();
                
            } catch (error) {
                console.error(' Volume test failed:', error);
            }
        }
        
        function debugAudioBuffers() {
            console.log(' === AUDIO BUFFERS DEBUG ===');
            console.log(' Audio context state:', audioContext ? audioContext.state : 'Not initialized');
            console.log(' Total tracks:', tracks.length);
            console.log(' Audio buffers map size:', audioBuffers.size);
            console.log(' Audio sources map size:', audioSources.size);
            console.log(' Gain nodes map size:', gainNodes.size);
            
            console.log(' Available buffer IDs:', Array.from(audioBuffers.keys()));
            console.log(' Available source IDs:', Array.from(audioSources.keys()));
            console.log(' Available gain node IDs:', Array.from(gainNodes.keys()));
            
            console.log(' Track details:');
            tracks.forEach(track => {
                const hasBuffer = audioBuffers.has(track.id);
                const hasSource = audioSources.has(track.id);
                const hasGainNode = gainNodes.has(track.id);
                
                console.log(` Track ${track.id} (${track.name}):`);
                console.log(`  - Buffer: ${hasBuffer ? '' : ''}`);
                console.log(`  - Source: ${hasSource ? '' : ''}`);
                console.log(`  - Gain Node: ${hasGainNode ? '' : ''}`);
                console.log(`  - Playing: ${track.playing ? '' : ''}`);
                console.log(`  - Volume: ${track.volume}`);
                console.log(`  - Audio URL: ${track.audioUrl ? '' : ''}`);
                if (track.audioUrl) {
                    console.log(`  - URL: ${track.audioUrl}`);
                }
            });
            
            console.log(' === END DEBUG ===');
        }
        
        // Test B2 URLs accessibility
        async function testB2Urls() {
            console.log(' === TESTING B2 URLs ===');
            
            if (!tracks || tracks.length === 0) {
                console.log(' No tracks loaded');
                return;
            }
            
            for (let track of tracks) {
                if (track.audioUrl) {
                    console.log(` Testing URL for track ${track.id} (${track.name}):`);
                    console.log(` URL: ${track.audioUrl}`);
                    
                    try {
                        const response = await fetch(track.audioUrl, { method: 'HEAD' });
                        console.log(` Response status: ${response.status}`);
                        console.log(` Response headers:`, response.headers);
                        
                        if (response.ok) {
                            console.log(` URL accessible for track ${track.id}`);
                        } else {
                            console.log(` URL not accessible for track ${track.id}: ${response.status}`);
                        }
                    } catch (error) {
                        console.log(` Error testing URL for track ${track.id}:`, error.message);
                    }
                } else {
                    console.log(` No URL for track ${track.id} (${track.name})`);
                }
            }
            
            console.log(' === END B2 URL TEST ===');
        }
        
        // Reload audio buffers for current tracks
        async function reloadAudioBuffers() {
            console.log(' === RELOADING AUDIO BUFFERS ===');
            
            if (!tracks || tracks.length === 0) {
                console.log(' No tracks loaded');
                return;
            }
            
            // Clear existing buffers
            audioBuffers.clear();
            audioSources.clear();
            gainNodes.clear();
            console.log(' Cleared existing audio buffers');
            
            // Reload each track
            for (let track of tracks) {
                if (track.audioUrl) {
                    console.log(` Reloading buffer for track ${track.id} (${track.name})`);
                    console.log(` URL: ${track.audioUrl}`);
                    
                    try {
                        const audioBuffer = await loadAudioFile(track.audioUrl, track.id);
                        if (audioBuffer) {
                            console.log(` Buffer reloaded for track ${track.id}`);
                        } else {
                            console.error(` Failed to reload buffer for track ${track.id}`);
                        }
                    } catch (error) {
                        console.error(` Error reloading buffer for track ${track.id}:`, error);
                    }
                } else {
                    console.warn(` No URL for track ${track.id} (${track.name})`);
                }
            }
            
            console.log(' === FINISHED RELOADING BUFFERS ===');
            console.log(' Total buffers loaded:', audioBuffers.size);
            console.log(' Available buffer IDs:', Array.from(audioBuffers.keys()));
        }
        
        // Check file sizes in B2
        async function checkFileSizes() {
            console.log(' === CHECKING FILE SIZES ===');
            
            if (!tracks || tracks.length === 0) {
                console.log(' No tracks loaded');
                return;
            }
            
            for (let track of tracks) {
                if (track.audioUrl) {
                    console.log(` Checking file size for track ${track.id} (${track.name}):`);
                    console.log(` URL: ${track.audioUrl}`);
                    
                    try {
                        const response = await fetch(track.audioUrl, { method: 'HEAD' });
                        console.log(` Response status: ${response.status}`);
                        
                        if (response.ok) {
                            const contentLength = response.headers.get('content-length');
                            const contentType = response.headers.get('content-type');
                            
                            console.log(` Content-Length: ${contentLength} bytes`);
                            console.log(` Content-Type: ${contentType}`);
                            
                            if (contentLength) {
                                const sizeKB = Math.round(parseInt(contentLength) / 1024);
                                const sizeMB = Math.round(parseInt(contentLength) / 1024 / 1024 * 100) / 100;
                                
                                console.log(` Size: ${sizeKB} KB (${sizeMB} MB)`);
                                
                                if (parseInt(contentLength) < 1000) {
                                    console.log(` File too small - likely corrupted!`);
                                } else if (parseInt(contentLength) < 10000) {
                                    console.log(` File very small - might be corrupted`);
                                } else {
                                    console.log(` File size looks normal`);
                                }
                            } else {
                                console.log(` No Content-Length header`);
                            }
                        } else {
                            console.log(` File not accessible: ${response.status}`);
                        }
                    } catch (error) {
                        console.log(` Error checking file size:`, error.message);
                    }
                } else {
                    console.log(` No URL for track ${track.id} (${track.name})`);
                }
            }
            
            console.log(' === END FILE SIZE CHECK ===');
        }
        
        // Test single audio file decoding
        async function testSingleAudioFile() {
            console.log(' === TESTING SINGLE AUDIO FILE ===');
            
            if (!tracks || tracks.length === 0) {
                console.log(' No tracks loaded');
                return;
            }
            
            // Test the first track with an audio URL
            const testTrack = tracks.find(track => track.audioUrl);
            if (!testTrack) {
                console.log(' No track with audio URL found');
                return;
            }
            
            console.log(` Testing track ${testTrack.id} (${testTrack.name})`);
            console.log(` URL: ${testTrack.audioUrl}`);
            
            try {
                console.log(' Step 1: Fetching file...');
                const response = await fetch(testTrack.audioUrl);
                console.log(' Fetch status:', response.status);
                console.log(' Content-Type:', response.headers.get('content-type'));
                console.log(' Content-Length:', response.headers.get('content-length'));
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                console.log(' Step 2: Converting to ArrayBuffer...');
                const arrayBuffer = await response.arrayBuffer();
                console.log(' ArrayBuffer size:', arrayBuffer.byteLength, 'bytes');
                console.log(' ArrayBuffer size in MB:', (arrayBuffer.byteLength / 1024 / 1024).toFixed(2), 'MB');
                
                // Check file format
                const uint8Array = new Uint8Array(arrayBuffer.slice(0, 16));
                console.log(' First 16 bytes (hex):', Array.from(uint8Array).map(b => b.toString(16).padStart(2, '0')).join(' '));
                console.log(' First 16 bytes (ascii):', Array.from(uint8Array).map(b => String.fromCharCode(b)).join(''));
                
                // Check if it's a WAV file
                const header = String.fromCharCode(...uint8Array.slice(0, 4));
                console.log(' File header:', header);
                
                if (header === 'RIFF') {
                    console.log(' File appears to be a WAV file (RIFF header)');
                } else {
                    console.log(' File does not appear to be a WAV file');
                }
                
                console.log(' Step 3: Decoding audio data...');
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                console.log(' Audio decoded successfully!');
                console.log(' Duration:', audioBuffer.duration, 'seconds');
                console.log(' Sample rate:', audioBuffer.sampleRate, 'Hz');
                console.log(' Channels:', audioBuffer.numberOfChannels);
                console.log(' Length:', audioBuffer.length, 'samples');
                
            } catch (error) {
                console.error(' Error testing audio file:', error);
                console.error(' Error message:', error.message);
                console.error(' Error name:', error.name);
                
                if (error.name === 'EncodingError') {
                    console.error(' This is an encoding error - the file format might not be supported');
                }
            }
            
            console.log(' === END SINGLE AUDIO FILE TEST ===');
        }
        
        function debugTimeSync() {
            console.log(' === TIME SYNCHRONIZATION DEBUG ===');
            console.log(' Current time:', currentTime.toFixed(2), 'seconds');
            console.log(' Total time:', totalTime.toFixed(2), 'seconds');
            console.log(' Audio context time:', audioContext ? audioContext.currentTime.toFixed(2) : 'Not available');
            console.log(' Audio start time:', audioStartTime.toFixed(2));
            console.log(' Paused time:', pausedTime.toFixed(2));
            console.log(' Is playing:', isPlaying);
            
            console.log(' Track durations:');
            tracks.forEach(track => {
                const buffer = audioBuffers.get(track.id);
                if (buffer) {
                    console.log(` Track ${track.id} (${track.name}): ${buffer.duration.toFixed(2)}s (${formatTime(buffer.duration)})`);
                }
            });
            
            console.log(' === END TIME DEBUG ===');
        }
        
        function debugPlaybackState() {
            console.log(' === PLAYBACK STATE DEBUG ===');
            console.log(' Is playing:', isPlaying);
            console.log(' Current time:', currentTime.toFixed(2));
            console.log(' Total time:', totalTime.toFixed(2));
            console.log(' Audio context time:', audioContext ? audioContext.currentTime.toFixed(2) : 'Not available');
            console.log(' Audio start time:', audioStartTime.toFixed(2));
            console.log(' Paused time:', pausedTime.toFixed(2));
            console.log(' Is looping:', isLooping);
            console.log(' Active audio sources:', audioSources.size);
            console.log(' Active gain nodes:', gainNodes.size);
            console.log(' Time update interval:', timeUpdateInterval ? 'Running' : 'Stopped');
            
            console.log(' Track states:');
            tracks.forEach(track => {
                const hasSource = audioSources.has(track.id);
                const hasGainNode = gainNodes.has(track.id);
                console.log(` Track ${track.id} (${track.name}): playing=${track.playing}, hasSource=${hasSource}, hasGainNode=${hasGainNode}, muted=${track.muted}`);
            });
            
            console.log(' === END PLAYBACK DEBUG ===');
        }
        
        // Check if a track is a click or cue track
        function isClickOrCueTrack(trackName) {
            if (!trackName) return false;
            
            // Normalize the name by removing accents and converting to lowercase
            const normalizedName = trackName.toLowerCase()
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '') // Remove accents
                .trim();
            
            const clickCueKeywords = ['click', 'clicks', 'cue', 'cues', 'guide', 'guia', 'guides'];
            
            return clickCueKeywords.some(keyword => normalizedName.includes(keyword));
        }
        
        function testSeek() {
            console.log(' === SEEK TEST ===');
            console.log(' Current time:', currentTime.toFixed(2));
            console.log(' Total time:', totalTime.toFixed(2));
            console.log(' Paused time:', pausedTime.toFixed(2));
            console.log(' Is playing:', isPlaying);
            
            if (totalTime > 0) {
                // Test seek to 50% of the song
                const testSeekTime = totalTime * 0.5;
                console.log(' Testing seek to:', testSeekTime.toFixed(2), 'seconds (50% of song)');
                seekToTime(testSeekTime);
            } else {
                console.log(' No song loaded - cannot test seek');
            }
            
            console.log(' === END SEEK TEST ===');
        }
        
        function testClickCueDetection() {
            console.log(' === CLICK/CUE DETECTION TEST ===');
            
            const testNames = [
                'Click',
                'Clicks',
                'Cue',
                'Cues', 
                'Guide',
                'Gua',
                'Guia',
                'Guides',
                'Guas',
                'Guias',
                'Click Track',
                'Cue Track',
                'Guide Track',
                'Gua Track',
                'Guia Track',
                'Bass',
                'Drums',
                'Guitar',
                'Vocals'
            ];
            
            console.log(' Testing track name detection:');
            testNames.forEach(name => {
                const isClickCue = isClickOrCueTrack(name);
                console.log(` "${name}" -> ${isClickCue ? ' Click/Cue' : ' Regular'}`);
            });
            
            console.log(' Current tracks:');
            tracks.forEach(track => {
                const trackName = typeof track.name === 'string' ? track.name : (track.name?.name || `Track ${track.id}`);
                const isClickCue = isClickOrCueTrack(trackName);
                console.log(` Track ${track.id}: "${trackName}" -> ${isClickCue ? ' Click/Cue' : ' Regular'}`);
            });
            
            console.log(' === END CLICK/CUE TEST ===');
        }
        
        // Toggle debug buttons visibility (for developers)
        function toggleDebugButtons() {
            const debugButtons = document.querySelectorAll('.test-b2-btn[style*="display: none"], .settings-btn[style*="display: none"]');
            const isHidden = debugButtons[0] && debugButtons[0].style.display === 'none';
            
            debugButtons.forEach(btn => {
                btn.style.display = isHidden ? 'inline-block' : 'none';
            });
            
            console.log(` Debug buttons ${isHidden ? 'shown' : 'hidden'}`);
        }
        
        // Load user state from Firestore (last setlist and song)
        async function loadUserState() {
            try {
                if (!currentUser) {
                    console.log(' No user logged in, cannot load user state');
                    return null;
                }
                
                console.log(' Loading user state from Firestore for user:', currentUser.uid);
                const userStateRef = window.firebase.doc(window.firebase.db, 'userStates', currentUser.uid);
                const userStateSnap = await window.firebase.getDoc(userStateRef);
                
                if (userStateSnap.exists()) {
                    const userState = userStateSnap.data();
                    console.log(' User state loaded:', userState);
                    return userState;
                } else {
                    console.log(' No user state found in Firestore');
                    return null;
                }
            } catch (error) {
                console.error(' Error loading user state:', error);
                return null;
            }
        }
        
        // Save user state to Firestore (last setlist and song)
        async function saveUserState(setlist, song) {
            try {
                if (!currentUser) {
                    console.log(' No user logged in, cannot save user state');
                    return;
                }
                
                const userState = {
                    userId: currentUser.uid,
                    lastSetlist: setlist ? {
                        id: setlist.id,
                        name: setlist.name,
                        songs: setlist.songs
                    } : null,
                    lastSong: song ? {
                        id: song.id,
                        name: song.name,
                        artist: song.artist,
                        tempo: song.tempo,
                        key: song.key,
                        timeSignature: song.timeSignature
                    } : null,
                    lastUpdated: new Date()
                };
                
                console.log(' Saving user state to Firestore:', userState);
                const userStateRef = window.firebase.doc(window.firebase.db, 'userStates', currentUser.uid);
                await window.firebase.setDoc(userStateRef, userState);
                console.log(' User state saved successfully');
            } catch (error) {
                console.error(' Error saving user state:', error);
            }
        }
        
        // Load last used setlist from localStorage (fallback)
        function loadLastUsedSetlist() {
            try {
                const lastSetlistData = localStorage.getItem('lastUsedSetlist');
                if (lastSetlistData) {
                    lastUsedSetlist = JSON.parse(lastSetlistData);
                    console.log(' Last used setlist loaded from localStorage:', lastUsedSetlist.name);
                    return lastUsedSetlist;
                }
            } catch (error) {
                console.error(' Error loading last used setlist from localStorage:', error);
            }
            return null;
        }
        
        // Save current setlist as last used (fallback to localStorage)
        function saveLastUsedSetlist(setlist) {
            try {
                lastUsedSetlist = setlist;
                localStorage.setItem('lastUsedSetlist', JSON.stringify(setlist));
                console.log(' Last used setlist saved to localStorage:', setlist.name);
                
                // Also save to Firestore if user is logged in
                if (currentUser) {
                    saveUserState(setlist, null);
                }
            } catch (error) {
                console.error(' Error saving last used setlist:', error);
            }
        }
        
        // Save setlist to Firebase
        async function saveSetlistToFirebase(setlist) {
            try {
                if (!currentUser) {
                    throw new Error('User not logged in');
                }
                
                if (!setlist || !setlist.id) {
                    throw new Error('Invalid setlist data');
                }
                
                console.log(' Saving setlist to Firebase:', setlist.name);
                
                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlist.id);
                
                await window.firebase.updateDoc(setlistRef, {
                    songs: setlist.songs,
                    updatedAt: new Date()
                });
                
                console.log(' Setlist saved to Firebase successfully');
                
            } catch (error) {
                console.error(' Error saving setlist to Firebase:', error);
                throw error;
            }
        }
        
        // Show initial loading screen
        function showInitialLoadingScreen() {
            console.log(' Judith 1.0 - Mostrando pantalla de carga inicial...');
            
            // Create initial loading overlay
            const loadingOverlay = document.createElement('div');
            loadingOverlay.id = 'initialLoadingOverlay';
            loadingOverlay.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%) !important;
                display: flex !important;
                flex-direction: column !important;
                justify-content: center !important;
                align-items: center !important;
                z-index: 999999 !important;
                color: white !important;
                font-family: Arial, sans-serif !important;
                text-align: center !important;
                margin: 0 !important;
                padding: 0 !important;
                border: none !important;
            `;
            
            const title = document.createElement('div');
            title.style.cssText = `
                font-size: 64px;
                font-weight: bold;
                color: #007AFF;
                margin-bottom: 20px;
                text-shadow: 0 0 30px #007AFF;
                animation: pulse 2s infinite;
            `;
            title.textContent = 'Judith 1.0';
            
            const subtitle = document.createElement('div');
            subtitle.style.cssText = `
                font-size: 28px;
                color: #ccc;
                margin-bottom: 40px;
                font-weight: 300;
            `;
            subtitle.textContent = 'Sistema de Audio Multitrack';
            
            const loadingText = document.createElement('div');
            loadingText.style.cssText = `
                font-size: 18px;
                color: #888;
                margin-top: 20px;
            `;
            loadingText.textContent = 'Inicializando sistema...';
            
            // Add CSS animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes pulse {
                    0% { transform: scale(1); opacity: 1; }
                    50% { transform: scale(1.05); opacity: 0.8; }
                    100% { transform: scale(1); opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            loadingOverlay.appendChild(title);
            loadingOverlay.appendChild(subtitle);
            loadingOverlay.appendChild(loadingText);
            
            document.body.appendChild(loadingOverlay);
            
            // Remove overlay after 3 seconds
            setTimeout(() => {
                if (loadingOverlay && loadingOverlay.parentNode) {
                    loadingOverlay.parentNode.removeChild(loadingOverlay);
                }
                console.log(' Judith 1.0 - Pantalla de carga inicial completada');
            }, 3000);
        }
        
        // Show countdown message after login
        function showCountdownMessage() {
            console.log(' Judith 1.0 - Iniciando sistema...');
            
            // Check if overlay already exists
            const existingOverlay = document.getElementById('countdownOverlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
            
            // Create countdown overlay
            const countdownOverlay = document.createElement('div');
            countdownOverlay.id = 'countdownOverlay';
            countdownOverlay.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                background: rgba(0, 0, 0, 0.95) !important;
                display: flex !important;
                flex-direction: column !important;
                justify-content: center !important;
                align-items: center !important;
                z-index: 999999 !important;
                color: white !important;
                font-family: Arial, sans-serif !important;
                text-align: center !important;
                margin: 0 !important;
                padding: 0 !important;
                border: none !important;
            `;
            
            const title = document.createElement('div');
            title.style.cssText = `
                font-size: 48px;
                font-weight: bold;
                color: #007AFF;
                margin-bottom: 20px;
                text-shadow: 0 0 20px #007AFF;
            `;
            title.textContent = 'Judith 1.0';
            
            const subtitle = document.createElement('div');
            subtitle.style.cssText = `
                font-size: 24px;
                color: #ccc;
                margin-bottom: 40px;
            `;
            subtitle.textContent = 'Sistema de Audio Multitrack';
            
            const countdown = document.createElement('div');
            countdown.style.cssText = `
                font-size: 72px;
                font-weight: bold;
                color: #4CAF50;
                text-shadow: 0 0 30px #4CAF50;
                margin-bottom: 20px;
            `;
            
            const status = document.createElement('div');
            status.style.cssText = `
                font-size: 18px;
                color: #888;
            `;
            status.textContent = 'Cargando sistema...';
            
            countdownOverlay.appendChild(title);
            countdownOverlay.appendChild(subtitle);
            countdownOverlay.appendChild(countdown);
            countdownOverlay.appendChild(status);
            
            document.body.appendChild(countdownOverlay);
            
            // Countdown sequence
            let count = 3;
            const countdownInterval = setInterval(() => {
                if (count > 0) {
                    countdown.textContent = count;
                    countdown.style.color = count === 3 ? '#FF5722' : count === 2 ? '#FF9800' : '#4CAF50';
                    countdown.style.textShadow = `0 0 30px ${countdown.style.color}`;
                    status.textContent = `Lista en ${count}...`;
                    count--;
                } else {
                    countdown.textContent = 'LISTA!';
                    countdown.style.color = '#4CAF50';
                    countdown.style.textShadow = '0 0 30px #4CAF50';
                    status.textContent = 'Sistema cargado y listo';
                    
                    // Remove overlay after a short delay
                    setTimeout(() => {
                        if (countdownOverlay && countdownOverlay.parentNode) {
                            countdownOverlay.parentNode.removeChild(countdownOverlay);
                        }
                        console.log(' Judith 1.0 - Sistema listo!');
        }, 1000);
                    
                    clearInterval(countdownInterval);
                }
            }, 1000);
        }
        
        // Load first available setlist
        async function loadFirstAvailableSetlist() {
            try {
                console.log(' LOAD-FIRST - Loading first available setlist...');
                console.log(' LOAD-FIRST - Current user:', currentUser ? currentUser.uid : 'No user');
                console.log(' LOAD-FIRST - Firebase object:', window.firebase);
                console.log(' LOAD-FIRST - Firebase db:', window.firebase?.db);
                
                if (!currentUser) {
                    console.log(' LOAD-FIRST - No user logged in');
                    return;
                }
                
                if (!window.firebase || !window.firebase.db) {
                    console.log(' LOAD-FIRST - Firebase not initialized');
                    return;
                }
                
                console.log(' LOAD-FIRST - Querying setlists from Firestore...');
                const setlistsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'setlists'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );
                
                console.log(' LOAD-FIRST - Query created, getting docs...');
                const querySnapshot = await window.firebase.getDocs(setlistsQuery);
                const setlists = [];
                
                console.log(' LOAD-FIRST - Query result:', querySnapshot.size, 'setlists found');
                
                querySnapshot.forEach((doc) => {
                    const setlistData = { id: doc.id, ...doc.data() };
                    console.log(' LOAD-FIRST - Found setlist:', setlistData.name, 'with', setlistData.songs?.length || 0, 'songs');
                    setlists.push(setlistData);
                });
                
                if (setlists.length > 0) {
                    const firstSetlist = setlists[0];
                    console.log(' LOAD-FIRST - Loading first setlist in sidebar:', firstSetlist.name);
                    console.log(' LOAD-FIRST - First setlist data:', firstSetlist);
                    
                    // Set as current setlist
                    currentSetlist = firstSetlist;
                    console.log(' LOAD-FIRST - Set currentSetlist:', currentSetlist);
                    
                    // Update LED display
                    console.log(' LOAD-FIRST - Updating LED display...');
                    updateSetlistLedDisplay(firstSetlist.name);
                    
                    // Load setlist in sidebar (lateral izquierdo)
                    console.log(' LOAD-FIRST - Loading setlist in sidebar...');
                    loadCurrentSetlistForSidebar();
                    
                    console.log(' LOAD-FIRST - First setlist loaded in sidebar successfully!');
                } else {
                    console.log(' LOAD-FIRST - No setlists found for user');
                }
                
            } catch (error) {
                console.error(' LOAD-FIRST ERROR - Error loading first available setlist:', error);
                console.error(' LOAD-FIRST ERROR - Error details:', error.message);
                console.error(' LOAD-FIRST ERROR - Error stack:', error.stack);
            }
        }
        
        // Auto-load last used setlist and song from Firestore
        async function autoLoadLastSetlist() {
            try {
                console.log(' AUTO-LOAD STARTED - Starting auto-load of first available setlist...');
                console.log(' AUTO-LOAD - Current user:', currentUser ? currentUser.uid : 'No user');
                console.log(' AUTO-LOAD - User object:', currentUser);
                
                if (!currentUser) {
                    console.log(' AUTO-LOAD - No user logged in, exiting');
                    return;
                }
                
                // Always load the first available setlist
                console.log(' AUTO-LOAD - Calling loadFirstAvailableSetlist...');
                await loadFirstAvailableSetlist();
                console.log(' AUTO-LOAD - First setlist auto-loaded successfully!');
                
            } catch (error) {
                console.error(' AUTO-LOAD ERROR - Error auto-loading first setlist:', error);
                console.error(' AUTO-LOAD ERROR - Error details:', error.message);
                console.error(' AUTO-LOAD ERROR - Error stack:', error.stack);
            }
        }
        
        // Load setlist from data
        async function loadSetlistFromData(setlistData) {
            try {
                console.log(' Loading setlist from data:', setlistData.name);
                currentSetlist = setlistData;
                
                // Update LED display
                updateSetlistLedDisplay(setlistData.name);
                
                // Display songs from this specific setlist
                console.log(' Displaying setlist songs...');
                await displaySetlistSongs(setlistData);
                
                console.log(' Setlist loaded successfully!');
            } catch (error) {
                console.error(' Error loading setlist from data:', error);
            }
        }
        
        // Load first song from setlist
        async function loadFirstSongFromSetlist(setlistData) {
            try {
                if (!setlistData.songs || setlistData.songs.length === 0) {
                    console.log(' No songs in setlist');
                    return;
                }
                
                // Sort songs by order number if they have one
                const sortedSongs = [...setlistData.songs].sort((a, b) => {
                    const aOrder = a.order || 0;
                    const bOrder = b.order || 0;
                    return aOrder - bOrder;
                });
                
                console.log(' Sorted songs by order:', sortedSongs.map(s => `${s.name} (order: ${s.order || 0})`));
                
                // Load the first song (lowest order number)
                if (sortedSongs.length > 0) {
                    const firstSong = sortedSongs[0];
                    console.log(' Auto-loading first song:', firstSong.name, 'Order:', firstSong.order || 0);
                    console.log(' First song data:', firstSong);
                    
                    // Show loading indicator for the first song
                    showSetlistLoading(firstSong.id);
                    
                    await loadSongFromSetlist(firstSong);
                    
                    // Hide loading indicator
                    hideSetlistLoading(firstSong.id);
                    
                    console.log(' First song loaded successfully!');
                }
            } catch (error) {
                console.error(' Error loading first song from setlist:', error);
            }
        }

        // Test authentication state
        function testAuthState() {
            console.log(' Testing authentication state...');
            console.log(' Current user:', currentUser);
            console.log(' Firebase auth:', window.firebase?.auth);
            console.log(' Auth button:', document.getElementById('authButton'));
            
            if (window.firebase?.auth) {
                window.firebase.auth.currentUser.then(user => {
                    console.log(' Firebase current user:', user);
                    if (user) {
                        alert(` Usuario autenticado:\n\nEmail: ${user.email}\nUID: ${user.uid}\nDisplay Name: ${user.displayName || 'N/A'}`);
                    } else {
                        alert(' No hay usuario autenticado en Firebase');
                    }
                }).catch(error => {
                    console.error(' Error getting current user:', error);
                    alert(' Error al verificar usuario: ' + error.message);
                });
            } else {
                alert(' Firebase no est disponible');
            }
        }

        // Clear setlist songs
        function clearSetlistSongs() {
            const songList = document.getElementById('songList');
            if (songList) {
                songList.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: #888;">
                        <div style="font-size: 48px; margin-bottom: 16px;"></div>
                        <div style="font-size: 16px; font-weight: bold; margin-bottom: 8px; color: #ccc;">Setlist Vaco</div>
                        <div style="font-size: 14px;">Selecciona un setlist para ver sus canciones</div>
                    </div>
                `;
            }
        }

        // Tab switching functionality
        function switchTab(tabName) {
            // Remove active class from all tabs and content
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to selected tab and content
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
            document.getElementById(`${tabName}Tab`).classList.add('active');
            
            // Load content based on tab
            if (tabName === 'library') {
                loadLibrarySongs();
            } else if (tabName === 'setlist') {
                // Clear the song list when switching to setlist tab
                clearSetlistSongs();
            }
        }

        // Load library songs (songs uploaded by user)
        async function loadLibrarySongs() {
            try {
                console.log(' Loading library songs...');
                console.log(' Current user:', currentUser ? currentUser.uid : 'No user');
                
                if (!currentUser) {
                    console.log(' No user logged in');
                    return;
                }

                console.log(' Querying Firestore for songs...');
                const songsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'songs'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );
                
                const querySnapshot = await window.firebase.getDocs(songsQuery);
                const songs = [];
                
                console.log(' Query snapshot size:', querySnapshot.size);
                
                querySnapshot.forEach((doc) => {
                    const songData = { id: doc.id, ...doc.data() };
                    console.log(' Found song:', songData.name, 'with', songData.tracks?.length || 0, 'tracks');
                    songs.push(songData);
                });
                
                console.log(' Library songs loaded:', songs.length);
                displayLibrarySongs(songs);
                
            } catch (error) {
                console.error(' Error loading library songs:', error);
            }
        }

        // Display library songs
        function displayLibrarySongs(songs) {
            console.log(' Displaying library songs:', songs.length);
            const libraryItems = document.getElementById('libraryItems');
            
            if (!libraryItems) {
                console.error(' Library items element not found');
                return;
            }
            
            if (songs.length === 0) {
                console.log(' No songs found, showing empty state');
                libraryItems.innerHTML = `
                    <div class="empty-state">
                        <p>No tienes canciones en tu biblioteca</p>
                        <p>Sube un archivo ZIP para comenzar</p>
                    </div>
                `;
                return;
            }
            
            libraryItems.innerHTML = songs.map(song => `
                <div class="library-song-item" onclick="selectLibrarySong('${song.id}')">
                    <div class="song-info">
                        <h4>${song.name}</h4>
                        <p>${song.tracks ? song.tracks.length : 0} tracks</p>
                        <p class="song-date">${new Date(song.createdAt?.toDate()).toLocaleDateString()}</p>
                    </div>
                    <div class="song-actions">
                        <button class="action-btn" onclick="event.stopPropagation(); downloadSong('${song.id}')" title="Descargar"></button>
                        <button class="action-btn" onclick="event.stopPropagation(); addToSetlist('${song.id}')" title="Agregar a Setlist"></button>
                        <button class="action-btn" onclick="event.stopPropagation(); deleteSongFromLibrary('${song.id}', '${song.name}')" title="Eliminar cancin" style="background: #ff4444;"></button>
                    </div>
                </div>
            `).join('');
        }

        // Load setlists
        async function loadSetlists() {
            try {
                console.log(' Loading setlists...');
                
                if (!currentUser) {
                    console.log(' No user logged in');
                    return;
                }

                const setlistsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'setlists'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );
                
                const querySnapshot = await window.firebase.getDocs(setlistsQuery);
                const setlists = [];
                
                querySnapshot.forEach((doc) => {
                    setlists.push({ id: doc.id, ...doc.data() });
                });
                
                console.log(' Setlists loaded:', setlists.length);
                displaySetlists(setlists);
                
            } catch (error) {
                console.error(' Error loading setlists:', error);
            }
        }

        // Toggle setlist sidebar
        function toggleSetlistSidebar() {
            const sidebar = document.getElementById('setlistSidebar');
            if (sidebar.classList.contains('open')) {
                sidebar.classList.remove('open');
            } else {
                sidebar.classList.add('open');
                loadSetlistSidebar();
            }
        }
        
        // Load setlists in sidebar
        async function loadSetlistSidebar() {
            try {
                console.log(' Loading setlists for sidebar...');
                
                if (!currentUser) {
                    console.log(' No user logged in');
                    return;
                }

                const setlistsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'setlists'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );
                
                const querySnapshot = await window.firebase.getDocs(setlistsQuery);
                const setlists = [];
                
                querySnapshot.forEach((doc) => {
                    setlists.push({ id: doc.id, ...doc.data() });
                });
                
                console.log(' Setlists loaded for sidebar:', setlists.length);
                
                const setlistSidebarList = document.getElementById('setlistSidebarList');
                
                if (setlists.length === 0) {
                    setlistSidebarList.innerHTML = `
                        <div style="text-align: center; padding: 20px; color: #888;">
                            <p>No tienes setlists creados</p>
                        </div>
                    `;
                    return;
                }
                
                setlistSidebarList.innerHTML = setlists.map(setlist => `
                    <div class="setlist-sidebar-item" onclick="loadSetlistFromSidebar('${setlist.id}')">
                        <h4>${setlist.name}</h4>
                        <p>${setlist.songs ? setlist.songs.length : 0} canciones</p>
                    </div>
                `).join('');
                
            } catch (error) {
                console.error(' Error loading setlists for sidebar:', error);
            }
        }
        
        // Load setlist from sidebar
        async function loadSetlistFromSidebar(setlistId) {
            try {
                console.log(' Loading setlist from sidebar:', setlistId);
                
                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistSnap = await window.firebase.getDoc(setlistRef);
                
                if (setlistSnap.exists()) {
                    const setlistData = setlistSnap.data();
                    setlistData.id = setlistId;
                    
                    // Set as current setlist
                    currentSetlist = setlistData;
                    
                    // Update LED display
                    updateSetlistLedDisplay(setlistData.name);
                    
                    // Display songs in the main area
                    displaySetlistSongs(setlistData);
                    
                    // Close sidebar
                    toggleSetlistSidebar();
                    
                    // Success message removed
                    
                    console.log(' Setlist loaded from sidebar:', setlistData.name);
                } else {
                    alert(' Setlist no encontrado');
                }
                
            } catch (error) {
                console.error(' Error loading setlist from sidebar:', error);
                alert(' Error al cargar el setlist');
            }
        }
        
        // Update setlist LED display
        function updateSetlistLedDisplay(setlistName) {
            const ledDisplay = document.getElementById('setlistLedDisplay');
            if (ledDisplay) {
                const ledText = ledDisplay.querySelector('.led-text');
                if (ledText) {
                    ledText.textContent = setlistName || 'Sin Setlist';
                }
            }
        }
        
        // Display setlist songs in main area
        async function displaySetlistSongs(setlistData) {
            try {
                console.log(' Displaying setlist songs:', setlistData.name);
                
                const cancionesList = document.getElementById('cancionesList');
                
                if (!setlistData.songs || setlistData.songs.length === 0) {
                    cancionesList.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #888;">
                            <p>Este setlist no tiene canciones</p>
                        </div>
                    `;
                    return;
                }
                
                // Update setlist LED display
                updateSetlistLedDisplay(setlistData.name);
                
                // Update song data with complete information from Firestore
                console.log(' Updating song data from Firestore...');
                const updatedSongs = await updateSetlistSongData(setlistData.songs);
                console.log(' Updated songs data:', updatedSongs);
                
                cancionesList.innerHTML = `
                    ${updatedSongs.map((song, index) => `
                        <div class="song-item" onclick="loadSong('${song.id}')">
                            <div class="song-number-container">
                                <div class="song-number">${index + 1}</div>
                                <div class="song-loading-indicator" id="loading-${song.id}" style="display: none;">
                                    <div class="mini-progress-bar" id="progress-${song.id}"></div>
                                </div>
                            </div>
                            <div class="song-info">
                                <div class="song-title">${song.name} ${song.onlinePlayback ? '' : ''}</div>
                                <div class="song-artist">${song.artist || 'Artista desconocido'}</div>
                            </div>
                            <div class="song-meta">
                                <span class="song-tempo">${song.tempo ? song.tempo + ' BPM' : 'BPM N/A'}</span>
                                <span class="song-key">${song.key || 'Key N/A'}</span>
                                <span class="song-time-sig">${song.timeSignature || '4/4'}</span>
                            </div>
                            <div class="song-actions">
                                <div class="song-menu">
                                    <button class="menu-btn" onclick="event.stopPropagation(); toggleSongMenu('${song.id}')" title="Opciones"></button>
                                    <div class="menu-dropdown" id="menu-${song.id}" style="display: none;">
                                        <button class="menu-item" onclick="removeFromSetlist('${song.id}')" title="Eliminar del setlist"> Eliminar</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                `;
                
                console.log(' Setlist songs displayed successfully');
                
                // Start progressive loading of songs
                startProgressiveLoading(updatedSongs);
                
            } catch (error) {
                console.error(' Error displaying setlist songs:', error);
            }
        }

        // Start progressive loading of songs
        async function startProgressiveLoading(songs) {
            try {
                console.log(' Starting progressive loading for', songs.length, 'songs');
                
                // Initialize progressive loading
                progressiveLoadingQueue = [...songs];
                isProgressiveLoading = true;
                currentLoadingSongIndex = 0;
                
                // Load first song immediately
                if (songs.length > 0) {
                    await loadSongProgressively(songs[0], 0);
                }
                
            } catch (error) {
                console.error(' Error starting progressive loading:', error);
            }
        }

        // Load a single song progressively
        async function loadSongProgressively(song, index) {
            try {
                console.log(` Loading song ${index + 1}/${progressiveLoadingQueue.length}: ${song.name}`);
                
                // Update current loading index
                currentLoadingSongIndex = index;
                
                // Show loading indicator for this song
                showSongLoadingIndicator(song.id);
                
                // Load the song tracks (cache only, don't play)
                await loadSongTracksForCache(song);
                
                // Hide loading indicator
                hideSongLoadingIndicator(song.id);
                
                console.log(` Song ${index + 1} cached successfully: ${song.name}`);
                
                // Load next song after a short delay (continue in background)
                if (index + 1 < progressiveLoadingQueue.length && isProgressiveLoading) {
                    setTimeout(() => {
                        // Check if progressive loading is still active before continuing
                        if (isProgressiveLoading) {
                            loadSongProgressively(progressiveLoadingQueue[index + 1], index + 1);
                        }
                    }, 1000); // 1 second delay between songs
                } else {
                    console.log(' Progressive loading completed!');
                    isProgressiveLoading = false;
                }
                
            } catch (error) {
                console.error(` Error loading song ${index + 1}:`, error);
                hideSongLoadingIndicator(song.id);
                
                // Continue with next song even if this one failed
                if (index + 1 < progressiveLoadingQueue.length && isProgressiveLoading) {
                    setTimeout(() => {
                        // Check if progressive loading is still active before continuing
                        if (isProgressiveLoading) {
                            loadSongProgressively(progressiveLoadingQueue[index + 1], index + 1);
                        }
                    }, 1000);
                }
            }
        }

        // Load song tracks for cache only (without playing)
        async function loadSongTracksForCache(songData) {
            try {
                console.log(' Loading song tracks for cache:', songData.name);
                
                // Tracks already cleared above - no need to clear again
                console.log(' Using existing cleared tracks array');
                gainNodes.clear();
                
                // Handle different track data structures
                let trackData = [];
                if (songData.tracks && Array.isArray(songData.tracks)) {
                    if (typeof songData.tracks[0] === 'object' && songData.tracks[0] !== null) {
                        trackData = songData.tracks;
                    } else {
                        trackData = songData.tracks.map(name => ({ name: name }));
                    }
                } else {
                    trackData = [
                        { name: 'Drums' },
                        { name: 'Bass' },
                        { name: 'Guitar' },
                        { name: 'Keys' },
                        { name: 'Vocals' },
                        { name: 'Backing Vocals' }
                    ];
                }
                
                const tempTracksForCache = trackData.map((track, index) => {
                    let trackName = '';
                    if (typeof track === 'string') {
                        trackName = track;
                    } else if (track && typeof track === 'object') {
                        trackName = track.name || track.title || `Track ${index + 1}`;
                    } else {
                        trackName = `Track ${index + 1}`;
                    }
                    
                    return {
                        id: `${songData.id}-${index + 1}`, // Unique ID for each track
                        name: trackName,
                        volume: 0.8,
                        muted: false,
                        solo: false,
                        playing: false,
                        audioUrl: track.downloadUrl || track.audioUrl || null,
                        originalUrl: track.originalUrl || null
                    };
                });
                
                // Load audio files for each track (cache only)
                for (let i = 0; i < tempTracksForCache.length; i++) {
                    const track = tempTracksForCache[i];
                    let audioUrl = track.audioUrl;
                    
                    if (track.originalUrl) {
                        audioUrl = track.originalUrl;
                    } else if (track.downloadUrl) {
                        audioUrl = track.downloadUrl;
                    }
                    
                    if (audioUrl) {
                        try {
                            const audioBuffer = await loadAudioFile(audioUrl, track.id);
                            if (audioBuffer) {
                                console.log(` Cached track ${i + 1}/${tempTracksForCache.length}: ${track.name}`);
                            }
                        } catch (error) {
                            console.error(` Error caching track ${track.name}:`, error);
                        }
                    }
                }
                
                // Restore original tracks
                tracks = tempTracks;
                
                console.log(` Song "${songData.name}" cached successfully`);
                
            } catch (error) {
                console.error(' Error loading song tracks for cache:', error);
            }
        }

        // Show loading indicator for specific song
        function showSongLoadingIndicator(songId) {
            const loadingIndicator = document.getElementById(`loading-${songId}`);
            const progressBar = document.getElementById(`progress-${songId}`);
            if (loadingIndicator) {
                loadingIndicator.style.display = 'block';
            }
            if (progressBar) {
                progressBar.style.width = '0%';
            }
        }

        // Hide loading indicator for specific song
        function hideSongLoadingIndicator(songId) {
            const loadingIndicator = document.getElementById(`loading-${songId}`);
            const progressBar = document.getElementById(`progress-${songId}`);
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
            if (progressBar) {
                progressBar.style.width = '0%';
            }
        }

        // Update progress for specific song
        function updateSongLoadingProgress(songId, progress) {
            const progressBar = document.getElementById(`progress-${songId}`);
            if (progressBar) {
                progressBar.style.width = `${progress}%`;
            }
        }

        // Stop progressive loading
        function stopProgressiveLoading() {
            isProgressiveLoading = false;
            progressiveLoadingQueue = [];
            currentLoadingSongIndex = 0;
            console.log(' Progressive loading stopped');
        }

        // Pause progressive loading temporarily (when user is playing)
        function pauseProgressiveLoading() {
            if (isProgressiveLoading) {
                console.log(' Pausing progressive loading temporarily');
                // Don't stop completely, just pause the current process
                // The setTimeout will check isProgressiveLoading and continue if true
            }
        }

        // Resume progressive loading
        function resumeProgressiveLoading() {
            if (progressiveLoadingQueue.length > 0 && !isProgressiveLoading) {
                console.log(' Resuming progressive loading');
                isProgressiveLoading = true;
                // Continue from where we left off
                if (currentLoadingSongIndex < progressiveLoadingQueue.length) {
                    loadSongProgressively(progressiveLoadingQueue[currentLoadingSongIndex], currentLoadingSongIndex);
                }
            }
        }
        
        // Display all songs from library
        async function displayAllSongs() {
            try {
                console.log(' Loading all songs from library...');
                
                if (!currentUser) {
                    console.log(' No user logged in');
                    return;
                }

                const songsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'songs'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );
                
                const querySnapshot = await window.firebase.getDocs(songsQuery);
                const songs = [];
                
                querySnapshot.forEach((doc) => {
                    songs.push({ id: doc.id, ...doc.data() });
                });
                
                console.log(' Songs loaded:', songs.length);
                
                const cancionesList = document.getElementById('cancionesList');
                
                if (songs.length === 0) {
                    cancionesList.innerHTML = `
                        <div class="empty-state">
                            <p>No tienes canciones en tu biblioteca</p>
                        </div>
                    `;
                    return;
                }
                
                cancionesList.innerHTML = songs.map(song => `
                    <div class="song-item" onclick="loadSong('${song.id}')">
                        <div class="song-number"></div>
                        <div class="song-cover"></div>
                        <div class="song-info">
                            <div class="song-title">${song.name} ${song.onlinePlayback ? '' : ''}</div>
                            <div class="song-artist">${song.artist || 'Artista desconocido'}</div>
                            <div class="song-details">
                                <span class="song-tempo">${song.tempo ? song.tempo + ' BPM' : 'BPM N/A'}</span>
                                <span class="song-key">${song.key || 'Key N/A'}</span>
                                <span class="song-time-sig">${song.timeSignature || '4/4'}</span>
                            </div>
                        </div>
                        <div class="song-actions">
                            <div class="song-menu">
                                <button class="menu-btn" onclick="event.stopPropagation(); addToSetlist('${song.id}')" title="Agregar al setlist"></button>
                            </div>
                        </div>
                    </div>
                `).join('');
                
            } catch (error) {
                console.error(' Error loading all songs:', error);
            }
        }
        
        // Display setlists
        function displaySetlists(setlists) {
            const setlistList = document.getElementById('setlistList');
            
            if (setlists.length === 0) {
                setlistList.innerHTML = `
                    <div class="empty-state">
                        <p>No tienes setlists creados</p>
                        <button class="create-setlist-btn" onclick="createNewSetlist()">Crear Setlist</button>
                    </div>
                `;
                return;
            }
            
            setlistList.innerHTML = setlists.map(setlist => `
                <div class="setlist-item" onclick="loadSetlist('${setlist.id}')">
                    <div class="setlist-info">
                        <h4>${setlist.name}</h4>
                        <p>${setlist.songs ? setlist.songs.length : 0} canciones</p>
                        <p class="setlist-date">${new Date(setlist.date?.toDate()).toLocaleDateString()}</p>
                    </div>
                    <div class="setlist-actions">
                        <button class="action-btn" onclick="event.stopPropagation(); editSetlist('${setlist.id}')" title="Editar"></button>
                        <button class="action-btn" onclick="event.stopPropagation(); deleteSetlist('${setlist.id}')" title="Eliminar"></button>
                    </div>
                </div>
            `).join('');
        }

        // Create new setlist
        function createNewSetlist() {
            const name = prompt('Nombre del setlist:');
            if (!name) return;
            
            const date = prompt('Fecha (YYYY-MM-DD):', new Date().toISOString().split('T')[0]);
            if (!date) return;
            
            createSetlist(name, date);
        }

        // Create setlist in Firestore
        async function createSetlist(name, date) {
            try {
                console.log(' Creating setlist:', name);
                
                const setlistData = {
                    userId: currentUser.uid,
                    name: name,
                    date: new Date(date),
                    songs: [],
                    createdAt: new Date()
                };
                
                const docRef = await window.firebase.addDoc(
                    window.firebase.collection(window.firebase.db, 'setlists'),
                    setlistData
                );
                
                console.log(' Setlist created:', docRef.id);
                alert(` Setlist "${name}" creado exitosamente`);
                loadSetlists(); // Refresh the list
                
            } catch (error) {
                console.error(' Error creating setlist:', error);
                alert(` Error al crear setlist: ${error.message}`);
            }
        }

        // Delete setlist
        async function deleteSetlist(setlistId) {
            try {
                // Get setlist data first
                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistSnap = await window.firebase.getDoc(setlistRef);
                
                if (!setlistSnap.exists()) {
                    alert(' Setlist no encontrado');
                    return;
                }
                
                const setlistData = setlistSnap.data();
                const setlistName = setlistData.name;
                
                // Confirm deletion
                const confirmDelete = confirm(`Ests seguro de que quieres eliminar el setlist "${setlistName}"?\n\nEsta accin no se puede deshacer.`);
                if (!confirmDelete) return;
                
                // Delete the setlist
                await window.firebase.deleteDoc(setlistRef);
                
                console.log(' Setlist deleted:', setlistId);
                alert(` Setlist "${setlistName}" eliminado exitosamente`);
                
                // Refresh the list
                loadSetlists();
                
            } catch (error) {
                console.error(' Error deleting setlist:', error);
                alert(` Error al eliminar setlist: ${error.message}`);
            }
        }

        // Load a specific setlist
        async function loadSetlist(setlistId) {
            try {
                console.log(' Loading setlist:', setlistId);
                
                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistSnap = await window.firebase.getDoc(setlistRef);
                
                if (setlistSnap.exists()) {
                    const setlistData = setlistSnap.data();
                    setlistData.id = setlistId; // Add ID to the data
                    console.log(' Setlist data:', setlistData);
                    
                    // Save as current setlist and last used
                    currentSetlist = setlistData;
                    saveLastUsedSetlist(setlistData);
                    
                    // Show setlist header with edit button
                    showSetlistHeader(setlistData, setlistId);
                    
                    // Display songs in the setlist
                    if (setlistData.songs && setlistData.songs.length > 0) {
                        displaySongs(setlistData.songs);
                    } else {
                        displayEmptySetlist();
                    }
                    
                    // Update setlist display
                    updateSetlistDisplay();
                } else {
                    alert('Setlist no encontrado');
                }
            } catch (error) {
                console.error(' Error loading setlist:', error);
                alert('Error al cargar el setlist: ' + error.message);
            }
        }

        // Show setlist header with edit button
        function showSetlistHeader(setlistData, setlistId) {
            const setlistHeader = document.querySelector('.setlist-header');
            if (setlistHeader) {
                setlistHeader.innerHTML = `
                    <div class="setlist-title"> ${setlistData.name}</div>
                    <div>
                        <button class="setlist-btn" onclick="editSetlist('${setlistId}')" title="Editar setlist"></button>
                        <button class="setlist-btn" onclick="addSongsToSetlist('${setlistId}')" title="Agregar canciones"></button>
                        <button class="setlist-btn" onclick="showDownloadInfo('${setlistId}')" title="Ver informacin de reproduccin"></button>
                        <button class="setlist-btn" onclick="testSetlistAudio('${setlistId}')" title="Probar audio del setlist"></button>
                        <button class="setlist-btn" onclick="testSpecificB2Url()" title="Probar CORS de B2"></button>
                        <button class="setlist-btn" onclick="backToSetlists()" title="Volver a setlists"></button>
                    </div>
                `;
            }
        }

        // Display empty setlist
        function displayEmptySetlist() {
            const songList = document.getElementById('songList');
            if (songList) {
                songList.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px; color: #888;">
                        <div style="font-size: 48px; margin-bottom: 16px;"></div>
                        <div style="font-size: 16px; font-weight: bold; margin-bottom: 8px; color: #ccc;">Setlist Vaco</div>
                        <div style="font-size: 14px;">Haz clic en "" para agregar canciones desde tu biblioteca</div>
                    </div>
                `;
            }
        }

        // Back to setlists view
        function backToSetlists() {
            const setlistHeader = document.querySelector('.setlist-header');
            if (setlistHeader) {
                setlistHeader.innerHTML = `
                    <div class="setlist-title"> Mi Setlist</div>
                    <div>
                        <button class="setlist-btn" onclick="createNewSetlist()" title="Crear nuevo setlist"></button>
                        <button class="setlist-btn" onclick="debugSetlists()" title="Debug setlists"></button>
                    </div>
                `;
            }
            
            // Clear song list and show setlists
            clearSetlistSongs();
        }

        // Add songs to setlist
        async function addSongsToSetlist(setlistId) {
            try {
                console.log(' Adding songs to setlist:', setlistId);
                console.log(' Current user:', currentUser?.uid);
                
                // First verify the setlist exists
                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistSnap = await window.firebase.getDoc(setlistRef);
                
                if (!setlistSnap.exists()) {
                    console.error(' Setlist not found:', setlistId);
                    alert('Error: Setlist no encontrado. ID: ' + setlistId);
                    return;
                }
                
                console.log(' Setlist exists:', setlistSnap.data().name);
                
                // Get user's songs from library
                const songsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'songs'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );
                
                const querySnapshot = await window.firebase.getDocs(songsQuery);
                const songs = [];
                
                querySnapshot.forEach((doc) => {
                    songs.push({ id: doc.id, ...doc.data() });
                });
                
                console.log(' Found songs in library:', songs.length);
                
                if (songs.length === 0) {
                    alert('No tienes canciones en tu biblioteca. Sube un archivo ZIP primero.');
                    return;
                }
                
                // Show song selection modal
                showSongSelectionModal(songs, setlistId);
                
            } catch (error) {
                console.error(' Error adding songs to setlist:', error);
                alert('Error al agregar canciones: ' + error.message);
            }
        }

        // Show song selection modal
        function showSongSelectionModal(songs, setlistId) {
            // Create modal HTML
            const modalHTML = `
                <div id="songSelectionModal" style="display: flex; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.8); align-items: center; justify-content: center; z-index: 1003;">
                    <div style="background-color: #1a1a1a; border-radius: 10px; padding: 30px; width: 600px; max-width: 90vw; max-height: 80vh; border: 1px solid #333; overflow-y: auto;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h2 style="color: #fff; font-size: 24px; font-weight: bold; margin: 0;">Agregar Canciones al Setlist</h2>
                            <button onclick="hideSongSelectionModal()" style="background: none; border: none; color: #ccc; font-size: 24px; cursor: pointer; padding: 5px;"></button>
                        </div>
                        
                        <div id="songSelectionList" style="display: flex; flex-direction: column; gap: 10px; max-height: 400px; overflow-y: auto;">
                            ${songs.map(song => `
                                <div class="library-song-item" style="cursor: pointer;" onclick="selectSongForSetlist('${song.id}', '${setlistId}')">
                                    <div class="song-info">
                                        <h4>${song.name}</h4>
                                        <p>${song.tracks ? song.tracks.length : 0} tracks</p>
                                        <p class="song-date">${new Date(song.createdAt?.toDate()).toLocaleDateString()}</p>
                                    </div>
                                    <div class="song-actions">
                                        <button class="action-btn" title="Agregar"></button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                            <button onclick="hideSongSelectionModal()" style="padding: 12px 24px; background-color: #666; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;">Cancelar</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add modal to page
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        // Hide song selection modal
        function hideSongSelectionModal() {
            const modal = document.getElementById('songSelectionModal');
            if (modal) {
                modal.remove();
            }
        }

        // Select song for setlist
        async function selectSongForSetlist(songId, setlistId) {
            try {
                console.log(' Adding song to setlist:', songId, setlistId);
                console.log(' Song ID:', songId);
                console.log(' Setlist ID:', setlistId);
                
                // Get song data
                const songRef = window.firebase.doc(window.firebase.db, 'songs', songId);
                const songSnap = await window.firebase.getDoc(songRef);
                
                if (!songSnap.exists()) {
                    console.error(' Song not found:', songId);
                    alert('Cancin no encontrada');
                    return;
                }
                
                const songData = songSnap.data();
                console.log(' Song found:', songData.name);
                
                // Get current setlist
                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistSnap = await window.firebase.getDoc(setlistRef);
                
                if (!setlistSnap.exists()) {
                    console.error(' Setlist not found:', setlistId);
                    alert('Setlist no encontrado. ID: ' + setlistId);
                    return;
                }
                
                console.log(' Setlist found:', setlistSnap.data().name);
                
                const setlistData = setlistSnap.data();
                const currentSongs = setlistData.songs || [];
                
                // Check if song already exists in setlist
                if (currentSongs.some(song => song.id === songId)) {
                    alert('Esta cancin ya est en el setlist');
                    return;
                }
                
                // Prepare tracks for online playback
                console.log(' Preparing tracks for online playback...');
                const preparedTracks = prepareTracksForSetlist(songData);
                
                // Add song to setlist with online track references
                currentSongs.push({
                    id: songId,
                    name: songData.name,
                    tracks: preparedTracks, // Use prepared tracks for online playback
                    originalTracks: songData.tracks, // Keep original B2 references
                    addedAt: new Date(),
                    onlinePlayback: true
                });
                
                // Update setlist in Firestore
                await window.firebase.updateDoc(setlistRef, {
                    songs: currentSongs,
                    updatedAt: new Date()
                });
                
                console.log(' Song added to setlist');
                alert(` Cancin agregada al setlist\n\n La cancin "${songData.name}" se ha agregado al setlist.\n\n Los archivos se reproducirn directamente desde Backblaze B2 para una experiencia online fluida.`);
                
                // Hide modal and refresh setlist view
                hideSongSelectionModal();
                loadSetlist(setlistId);
                
            } catch (error) {
                console.error(' Error adding song to setlist:', error);
                alert('Error al agregar cancin: ' + error.message);
            }
        }

        // Edit setlist
        async function editSetlist(setlistId) {
            try {
                console.log(' Editing setlist:', setlistId);
                
                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistSnap = await window.firebase.getDoc(setlistRef);
                
                if (!setlistSnap.exists()) {
                    alert('Setlist no encontrado');
                    return;
                }
                
                const setlistData = setlistSnap.data();
                
                // Show edit modal
                const newName = prompt('Nuevo nombre del setlist:', setlistData.name);
                if (!newName || newName === setlistData.name) return;
                
                // Update setlist name
                await window.firebase.updateDoc(setlistRef, {
                    name: newName,
                    updatedAt: new Date()
                });
                
                console.log(' Setlist updated');
                alert('Setlist actualizado');
                
                // Refresh setlist view
                loadSetlist(setlistId);
                
            } catch (error) {
                console.error(' Error editing setlist:', error);
                alert('Error al editar setlist: ' + error.message);
            }
        }

        // Debug setlists
        async function debugSetlists() {
            try {
                console.log(' Debugging setlists...');
                console.log(' Current user:', currentUser?.uid);
                
                if (!currentUser) {
                    alert(' No hay usuario autenticado');
                    return;
                }
                
                // Get all setlists
                const setlistsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'setlists'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );
                
                const querySnapshot = await window.firebase.getDocs(setlistsQuery);
                const setlists = [];
                
                querySnapshot.forEach((doc) => {
                    setlists.push({ id: doc.id, ...doc.data() });
                });
                
                console.log(' Found setlists:', setlists);
                
                let debugInfo = ` Debug Info:\n\n`;
                debugInfo += `Usuario: ${currentUser.email}\n`;
                debugInfo += `UID: ${currentUser.uid}\n\n`;
                debugInfo += `Setlists encontrados: ${setlists.length}\n\n`;
                
                setlists.forEach((setlist, index) => {
                    debugInfo += `${index + 1}. ID: ${setlist.id}\n`;
                    debugInfo += `   Nombre: ${setlist.name}\n`;
                    debugInfo += `   Canciones: ${setlist.songs?.length || 0}\n`;
                    debugInfo += `   Creado: ${setlist.createdAt?.toDate?.()?.toLocaleString() || 'N/A'}\n\n`;
                });
                
                alert(debugInfo);
                
            } catch (error) {
                console.error(' Error debugging setlists:', error);
                alert('Error al debuggear setlists: ' + error.message);
            }
        }

        // Delete song from library
        async function deleteSongFromLibrary(songId, songName) {
            try {
                console.log(' Deleting song from library:', songId, songName);
                
                // Show confirmation dialog
                const confirmMessage = `Ests seguro de que quieres eliminar la cancin "${songName}"?\n\nEsta accin eliminar:\n La cancin de tu biblioteca\n Todos los archivos de audio asociados\n La cancin de cualquier setlist donde est incluida\n\n Esta accin NO se puede deshacer.`;
                
                if (!confirm(confirmMessage)) {
                    console.log(' Song deletion cancelled by user');
                    return;
                }
                
                console.log(' User confirmed deletion');
                
                // Get song data first to check tracks
                const songRef = window.firebase.doc(window.firebase.db, 'songs', songId);
                const songSnap = await window.firebase.getDoc(songRef);
                
                if (!songSnap.exists()) {
                    alert('Error: La cancin no existe');
                    return;
                }
                
                const songData = songSnap.data();
                console.log(' Song data:', songData);
                
                // Check if song is in any setlists
                const setlistsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'setlists'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );
                
                const setlistsSnapshot = await window.firebase.getDocs(setlistsQuery);
                const setlistsWithSong = [];
                
                setlistsSnapshot.forEach((doc) => {
                    const setlistData = doc.data();
                    if (setlistData.songs && setlistData.songs.some(song => song.id === songId)) {
                        setlistsWithSong.push({ id: doc.id, name: setlistData.name });
                    }
                });
                
                if (setlistsWithSong.length > 0) {
                    const setlistNames = setlistsWithSong.map(s => s.name).join(', ');
                    const removeFromSetlists = confirm(`Esta cancin est en los siguientes setlists: ${setlistNames}\n\nQuieres eliminarla tambin de estos setlists?`);
                    
                    if (removeFromSetlists) {
                        // Remove song from setlists
                        for (const setlist of setlistsWithSong) {
                            const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlist.id);
                            const setlistSnap = await window.firebase.getDoc(setlistRef);
                            const setlistData = setlistSnap.data();
                            
                            const updatedSongs = setlistData.songs.filter(song => song.id !== songId);
                            
                            await window.firebase.updateDoc(setlistRef, {
                                songs: updatedSongs,
                                updatedAt: new Date()
                            });
                            
                            console.log(' Removed song from setlist:', setlist.name);
                        }
                    }
                }
                
                // Delete audio files from B2 (if needed)
                if (songData.tracks && songData.tracks.length > 0) {
                    console.log(' Deleting audio files from B2...');
                    // Note: B2 file deletion would require additional API calls
                    // For now, we'll just delete the metadata
                    console.log(' Audio files in B2 will remain (manual cleanup needed)');
                }
                
                // Delete song document from Firestore
                await window.firebase.deleteDoc(songRef);
                console.log(' Song deleted from Firestore');
                
                // Refresh library
                loadLibrarySongs();
                
                alert(` Cancin "${songName}" eliminada correctamente`);
                
            } catch (error) {
                console.error(' Error deleting song:', error);
                alert('Error al eliminar la cancin: ' + error.message);
            }
        }

        // Show delete multiple songs modal
        async function showDeleteMultipleModal() {
            try {
                console.log(' Showing delete multiple songs modal...');
                
                // Get user's songs
                const songsQuery = window.firebase.query(
                    window.firebase.collection(window.firebase.db, 'songs'),
                    window.firebase.where('userId', '==', currentUser.uid)
                );
                
                const querySnapshot = await window.firebase.getDocs(songsQuery);
                const songs = [];
                
                querySnapshot.forEach((doc) => {
                    songs.push({ id: doc.id, ...doc.data() });
                });
                
                if (songs.length === 0) {
                    alert('No tienes canciones en tu biblioteca para eliminar');
                    return;
                }
                
                // Create modal HTML
                const modalHTML = `
                    <div id="deleteMultipleModal" style="display: flex; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.8); align-items: center; justify-content: center; z-index: 1004;">
                        <div style="background-color: #1a1a1a; border-radius: 10px; padding: 30px; width: 600px; max-width: 90vw; max-height: 80vh; border: 1px solid #333; overflow-y: auto;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                                <h2 style="color: #fff; font-size: 24px; font-weight: bold; margin: 0;"> Eliminar Mltiples Canciones</h2>
                                <button onclick="hideDeleteMultipleModal()" style="background: none; border: none; color: #ccc; font-size: 24px; cursor: pointer; padding: 5px;"></button>
                            </div>
                            
                            <div style="margin-bottom: 20px; color: #ff4444; font-size: 14px;">
                                 Selecciona las canciones que quieres eliminar. Esta accin NO se puede deshacer.
                            </div>
                            
                            <div id="deleteSongsList" style="display: flex; flex-direction: column; gap: 10px; max-height: 400px; overflow-y: auto;">
                                ${songs.map(song => `
                                    <div style="display: flex; align-items: center; gap: 10px; padding: 10px; background: #222; border-radius: 6px;">
                                        <input type="checkbox" id="delete_${song.id}" value="${song.id}" style="transform: scale(1.2);">
                                        <div style="flex: 1;">
                                            <div style="color: #fff; font-weight: bold;">${song.name}</div>
                                            <div style="color: #888; font-size: 12px;">${song.tracks ? song.tracks.length : 0} tracks  ${new Date(song.createdAt?.toDate()).toLocaleDateString()}</div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                            
                            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                                <button onclick="hideDeleteMultipleModal()" style="padding: 12px 24px; background-color: #666; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;">Cancelar</button>
                                <button onclick="deleteSelectedSongs()" style="padding: 12px 24px; background-color: #ff4444; color: white; border: none; border-radius: 6px; font-size: 14px; cursor: pointer;">Eliminar Seleccionadas</button>
                            </div>
                        </div>
                    </div>
                `;
                
                // Add modal to page
                document.body.insertAdjacentHTML('beforeend', modalHTML);
                
            } catch (error) {
                console.error(' Error showing delete multiple modal:', error);
                alert('Error al mostrar modal de eliminacin: ' + error.message);
            }
        }

        // Hide delete multiple modal
        function hideDeleteMultipleModal() {
            const modal = document.getElementById('deleteMultipleModal');
            if (modal) {
                modal.remove();
            }
        }

        // Delete selected songs
        async function deleteSelectedSongs() {
            try {
                console.log(' Deleting selected songs...');
                
                // Get selected songs
                const checkboxes = document.querySelectorAll('#deleteSongsList input[type="checkbox"]:checked');
                const selectedSongIds = Array.from(checkboxes).map(cb => cb.value);
                
                if (selectedSongIds.length === 0) {
                    alert('Por favor selecciona al menos una cancin para eliminar');
                    return;
                }
                
                const confirmMessage = `Ests seguro de que quieres eliminar ${selectedSongIds.length} cancin(es)?\n\nEsta accin NO se puede deshacer.`;
                
                if (!confirm(confirmMessage)) {
                    console.log(' Multiple deletion cancelled by user');
                    return;
                }
                
                console.log(' User confirmed multiple deletion');
                
                let deletedCount = 0;
                let errorCount = 0;
                
                // Delete each selected song
                for (const songId of selectedSongIds) {
                    try {
                        // Get song data
                        const songRef = window.firebase.doc(window.firebase.db, 'songs', songId);
                        const songSnap = await window.firebase.getDoc(songRef);
                        
                        if (songSnap.exists()) {
                            const songData = songSnap.data();
                            
                            // Remove from setlists
                            const setlistsQuery = window.firebase.query(
                                window.firebase.collection(window.firebase.db, 'setlists'),
                                window.firebase.where('userId', '==', currentUser.uid)
                            );
                            
                            const setlistsSnapshot = await window.firebase.getDocs(setlistsQuery);
                            
                            setlistsSnapshot.forEach(async (doc) => {
                                const setlistData = doc.data();
                                if (setlistData.songs && setlistData.songs.some(song => song.id === songId)) {
                                    const updatedSongs = setlistData.songs.filter(song => song.id !== songId);
                                    await window.firebase.updateDoc(doc.ref, {
                                        songs: updatedSongs,
                                        updatedAt: new Date()
                                    });
                                }
                            });
                            
                            // Delete song document
                            await window.firebase.deleteDoc(songRef);
                            deletedCount++;
                            console.log(' Deleted song:', songData.name);
                        }
                    } catch (error) {
                        console.error(' Error deleting song:', songId, error);
                        errorCount++;
                    }
                }
                
                // Hide modal and refresh
                hideDeleteMultipleModal();
                loadLibrarySongs();
                
                if (errorCount === 0) {
                    alert(` ${deletedCount} cancin(es) eliminada(s) correctamente`);
                } else {
                    alert(` ${deletedCount} cancin(es) eliminada(s)\n ${errorCount} error(es) encontrado(s)`);
                }
                
            } catch (error) {
                console.error(' Error deleting selected songs:', error);
                alert('Error al eliminar canciones: ' + error.message);
            }
        }

        // Simple function to prepare tracks for setlist (no download)
        function prepareTracksForSetlist(songData) {
            console.log(' Preparing tracks for setlist:', songData.name);
            
            // Simply return the original tracks with B2 URLs
            return songData.tracks.map(track => ({
                ...track,
                originalUrl: track.downloadUrl,
                onlinePlayback: true
            }));
        }

        // Get file extension from URL
        function getFileExtension(url) {
            const match = url.match(/\.([^.?]+)(\?|$)/);
            return match ? match[1] : 'mp3';
        }

        // Retrieve audio from IndexedDB
        async function getAudioFromIndexedDB(path) {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('AudioCache', 1);
                
                request.onerror = () => reject(request.error);
                
                request.onsuccess = () => {
                    const db = request.result;
                    const transaction = db.transaction(['audioFiles'], 'readonly');
                    const store = transaction.objectStore('audioFiles');
                    const getRequest = store.get(path);
                    
                    getRequest.onsuccess = () => {
                        if (getRequest.result) {
                            const objectUrl = URL.createObjectURL(getRequest.result.blob);
                            resolve(objectUrl);
                        } else {
                            reject(new Error('Audio not found in cache'));
                        }
                    };
                    
                    getRequest.onerror = () => reject(getRequest.error);
                };
            });
        }

        // Show playback information for a setlist
        async function showDownloadInfo(setlistId) {
            try {
                console.log(' Showing playback info for setlist:', setlistId);
                
                // Get setlist data
                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistSnap = await window.firebase.getDoc(setlistRef);
                
                if (!setlistSnap.exists()) {
                    alert('Setlist no encontrado');
                    return;
                }
                
                const setlistData = setlistSnap.data();
                const songs = setlistData.songs || [];
                
                let onlineCount = 0;
                let totalTracks = 0;
                let playbackInfo = ` Informacin de Reproduccin - ${setlistData.name}\n\n`;
                
                songs.forEach(song => {
                    totalTracks += song.tracks ? song.tracks.length : 0;
                    if (song.onlinePlayback) {
                        onlineCount += song.tracks ? song.tracks.length : 0;
                        playbackInfo += ` ${song.name}: ${song.tracks ? song.tracks.length : 0} tracks (online)\n`;
                    } else {
                        playbackInfo += ` ${song.name}: No configurado\n`;
                    }
                });
                
                playbackInfo += `\n Resumen:\n`;
                playbackInfo += ` Total de tracks: ${totalTracks}\n`;
                playbackInfo += ` Tracks online: ${onlineCount}\n`;
                playbackInfo += ` Modo: Reproduccin online desde Backblaze B2\n\n`;
                playbackInfo += ` Los archivos se reproducen directamente desde la nube para una experiencia fluida.`;
                
                alert(playbackInfo);
                
            } catch (error) {
                console.error(' Error showing playback info:', error);
                alert('Error al mostrar informacin de reproduccin: ' + error.message);
            }
        }

        // Test B2 URL accessibility
        async function testB2UrlAccessibility(url) {
            try {
                console.log(' Testing B2 URL accessibility:', url);
                
                const response = await fetch(url, { 
                    method: 'HEAD',
                    mode: 'cors'
                });
                
                console.log(' Response status:', response.status);
                console.log(' Response headers:', Object.fromEntries(response.headers.entries()));
                
                if (response.ok) {
                    console.log(' B2 URL is accessible');
                    return { accessible: true, status: response.status, headers: response.headers };
                } else {
                    console.log(' B2 URL returned error:', response.status, response.statusText);
                    return { accessible: false, status: response.status, error: response.statusText };
                }
                
            } catch (error) {
                console.error(' Error testing B2 URL:', error);
                return { accessible: false, error: error.message };
            }
        }

        // Test a specific B2 URL directly
        async function testSpecificB2Url() {
            // Use one of the URLs from the logs
            const testUrl = 'https://f005.backblazeb2.com/file/cc12bbd592366bde909b0a1a/audio_Xj0QCnL6W2hdWAs3ZA6aAKQPhzo2_1758489707663_Click.wav';
            
            console.log(' Testing specific B2 URL with CORS enabled...');
            const result = await testB2UrlAccessibility(testUrl);
            
            if (result.accessible) {
                alert(` CORS funcionando!\n\n URL: ${testUrl}\n Estado: ${result.status}\n\n Las reglas CORS de B2 estn configuradas correctamente.`);
            } else {
                alert(` CORS an no funciona\n\n URL: ${testUrl}\n Estado: ${result.status}\n Error: ${result.error}\n\n Las reglas CORS pueden tardar unos minutos en propagarse.`);
            }
            
            return result;
        }

        // Test setlist audio
        async function testSetlistAudio(setlistId) {
            try {
                console.log(' Testing setlist audio for:', setlistId);
                
                // Get setlist data
                const setlistRef = window.firebase.doc(window.firebase.db, 'setlists', setlistId);
                const setlistSnap = await window.firebase.getDoc(setlistRef);
                
                if (!setlistSnap.exists()) {
                    alert('Setlist no encontrado');
                    return;
                }
                
                const setlistData = setlistSnap.data();
                const songs = setlistData.songs || [];
                
                if (songs.length === 0) {
                    alert('No hay canciones en este setlist para probar');
                    return;
                }
                
                // Test the first song
                const firstSong = songs[0];
                console.log(' Testing first song:', firstSong.name);
                
                if (firstSong.tracks && firstSong.tracks.length > 0) {
                    const firstTrack = firstSong.tracks[0];
                    console.log(' Testing first track:', firstTrack.name);
                    
                    // Test audio loading
                    const audioUrl = firstTrack.originalUrl || firstTrack.downloadUrl;
                    if (audioUrl) {
                        console.log(' Testing audio URL:', audioUrl);
                        
                        // Test URL accessibility with CORS enabled
                        console.log(' Testing B2 URL with CORS enabled...');
                        const urlTest = await testB2UrlAccessibility(audioUrl);
                        
                        if (urlTest.accessible) {
                            console.log(' B2 URL is accessible with CORS, testing audio playback...');
                            testAudioWithUrl(audioUrl, firstSong, firstTrack);
                        } else {
                            console.error(' B2 URL is not accessible:', urlTest);
                            alert(` URL no accesible\n\n URL: ${audioUrl}\n\n Estado: ${urlTest.status || 'Error'}\n Error: ${urlTest.error || 'Desconocido'}\n\n Posibles causas:\n Archivo no existe en B2\n URL mal formada\n Reglas CORS no configuradas\n Archivo corrupto\n\n Si acabas de configurar CORS, espera unos minutos para que se propague.`);
                        }
                        
                    } else {
                        alert(' No se encontr URL de audio para probar');
                    }
                } else {
                    alert(' No hay tracks en la primera cancin para probar');
                }
                
            } catch (error) {
                console.error(' Error testing setlist audio:', error);
                alert('Error al probar audio del setlist: ' + error.message);
            }
        }
        
        // Test audio with specific URL
        function testAudioWithUrl(audioUrl, firstSong, firstTrack) {
            console.log(' Testing audio with URL:', audioUrl);
            
            // Create a test audio element
            const testAudio = new Audio();
            testAudio.src = audioUrl;
            
            testAudio.onloadeddata = () => {
                console.log(' Audio loaded successfully');
                alert(` Audio funcionando correctamente\n\n Cancin: ${firstSong.name}\n Track: ${firstTrack.name}\n Duracin: ${testAudio.duration.toFixed(2)} segundos\n URL: ${audioUrl}\n\n Reproduccin online desde Backblaze B2 funcionando perfectamente.`);
            };
            
            testAudio.onerror = (error) => {
                console.error(' Audio loading error:', error);
                console.error(' Audio element error details:', {
                    error: error,
                    src: testAudio.src,
                    networkState: testAudio.networkState,
                    readyState: testAudio.readyState
                });
                
                let errorMessage = 'Error desconocido';
                if (testAudio.error) {
                    switch(testAudio.error.code) {
                        case 1:
                            errorMessage = 'MEDIA_ERR_ABORTED - El usuario cancel la carga';
                            break;
                        case 2:
                            errorMessage = 'MEDIA_ERR_NETWORK - Error de red';
                            break;
                        case 3:
                            errorMessage = 'MEDIA_ERR_DECODE - Error al decodificar el archivo';
                            break;
                        case 4:
                            errorMessage = 'MEDIA_ERR_SRC_NOT_SUPPORTED - Formato no soportado';
                            break;
                        default:
                            errorMessage = `Error de cdigo: ${testAudio.error.code}`;
                    }
                }
                
                const networkStateText = {
                    0: 'EMPTY',
                    1: 'IDLE',
                    2: 'LOADING', 
                    3: 'NO_SOURCE'
                };
                
                const readyStateText = {
                    0: 'NOTHING',
                    1: 'METADATA',
                    2: 'CURRENT_DATA',
                    3: 'FUTURE_DATA',
                    4: 'ENOUGH_DATA'
                };
                
                alert(` Error al cargar audio\n\n Cancin: ${firstSong.name}\n Track: ${firstTrack.name}\n URL: ${audioUrl}\n\n Estado del elemento:\n Network: ${testAudio.networkState} (${networkStateText[testAudio.networkState]})\n Ready: ${testAudio.readyState} (${readyStateText[testAudio.readyState]})\n\n Error: ${errorMessage}\n\n Diagnstico:\n Network 3 = No se pudo encontrar el recurso\n Ready 0 = No hay datos disponibles\n\n Posibles soluciones:\n Verificar que la URL sea correcta\n Comprobar que el archivo existe en B2\n Revisar la configuracin de CORS\n Probar con un archivo ms pequeo`);
            };
            
            // Try to load the audio
            testAudio.load();
        }

        // Add song to setlist
        async function addToSetlist(songId) {
            try {
                console.log(' Adding song to setlist:', songId);
                
                if (!currentSetlist) {
                    alert(' No hay setlist activo. Crea un setlist primero.');
                    return;
                }
                
                // Get full song data from Firestore
                const songRef = window.firebase.doc(window.firebase.db, 'songs', songId);
                const songSnap = await window.firebase.getDoc(songRef);
                
                if (!songSnap.exists()) {
                    alert(' Cancin no encontrada en la biblioteca.');
                    return;
                }
                
                const fullSongData = songSnap.data();
                console.log(' Full song data for setlist:', fullSongData);
                
                // Check if song is already in setlist
                const existingSong = currentSetlist.songs.find(song => song.id === songId);
                if (existingSong) {
                    alert(' Esta cancin ya est en el setlist.');
                    return;
                }
                
                // Add song to setlist with complete information
                const newSong = {
                    id: songId,
                    name: fullSongData.name || '',
                    artist: fullSongData.artist || '',
                    tempo: fullSongData.tempo || null,
                    key: fullSongData.key || '',
                    timeSignature: fullSongData.timeSignature || '',
                    tracks: fullSongData.tracks || [],
                    order: currentSetlist.songs.length + 1
                };
                
                currentSetlist.songs.push(newSong);
                
                // Save to Firebase
                await saveSetlistToFirebase(currentSetlist);
                
                // Update display
                loadCurrentSetlistForSidebar();
                updateSetlistDisplay();
                
                // Update main setlist display
                if (currentSetlist.songs && currentSetlist.songs.length > 0) {
                    displaySongs(currentSetlist.songs);
                }
                
                console.log(' Song added to setlist:', fullSongData.name);
                alert(` "${fullSongData.name}" agregada al setlist`);
                
            } catch (error) {
                console.error(' Error adding song to setlist:', error);
                alert(' Error al agregar cancin al setlist: ' + error.message);
            }
        }

        // Download song locally
        async function downloadSong(songId) {
            // TODO: Implement local download functionality
            console.log(' Downloading song locally:', songId);
        }

        // Initialize when page loads
        console.log(' ADDING DOMContentLoaded listener for init()...');
        document.addEventListener('DOMContentLoaded', init);
        console.log(' DOMContentLoaded listener added successfully');
    </script>
</body>
</html>

